---
layout: post
title: "[04] DeepLearning, 옵티마이저"
categories: [AI, DeepLearning]
tags: [AI, DeepLearning, TensorFlow, Keras, Python, Jupyter Notebook]
fullview: false
comments: false
---

본 포스팅은 **"케라스 창시자에게 배우는 딥러닝"** - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김)을 바탕으로 공부한 내용을 정리한 것입니다.

1. 텐서와 층 예시
    + 배치 데이터
2. 텐서 계산
    + 브로드캐스팅
    + 브로드캐스팅 예시
3. 그래디언트 기반 최적화

---

**[이전 포스팅 1](https://19tak.github.io/posts/02-dl/ "[02] DeepLearning, MNIST 손글씨 숫자 분류 문제")**, 
**[이전 포스팅 2](https://19tak.github.io/posts/03-dl/ "[03] DeepLearning, 활성화 함수")**과 함께 보자.

MNIST 손글씨 예제에서 데이터셋 적재, 신경망 생성을 거치고 컴파일, 모델 학습의 차례이다. 

신경망 생성 시 층의 선택 방법에 대해, 배치가 무엇인지 간략하게 서술하고, 옵티마이저 정리들어가고 다음 포스팅.

# 1. 텐서와 층 예시

텐서플로우는 channel-last 방식, 씨아노는 channel-first 방식

- **벡터 데이터:** **(samples, features)** 크기의 **2D 텐서**
    + 나이, 우편번호, 소득으로 구성된 10만명의 인구 통계 데이터셋은 (100000, 3) 크기의 텐서에 저장
    + (단어 2만개로 만든 사전에서) 각 단어가 등장한 횟수로 표현된 500개 문서의 데이터셋은 (500, 20000)
    + 완전 연결 층 (fully connected layer), 밀집 층 (dense layer), 밀집 연결 층 (densley connected layer)
- **시계열, 시퀀스 (sequence) 데이터:** **(samples, timesteps, features)** 크기의 **3D 텐서**
    + 1분마다 현재 주식 가격, 최고와 최소 가격을 저장한 250일 치의 데이터는 (250, 390, 3)
    > 미국 증권 거래소 개장시간 09:30 ~ 16:00로 390분
    + 128개의 알파벳으로 구성된 280개의 문자 시퀀스인 100만개의 트윗 데이터셋은 (1000000, 280, 128)
    + LSTM 같은 순환 층 (recurrent layer)
- **이미지:** **(samples, height, width, channels)** 또는 (samples, channels, height, width) **4D 텐서**
    + 256x256 크기 흑백 이미지에 대한 128개의 배치는 (128, 256, 256, 1)
    + 256x256 크기 컬러 이미지에 대한 128개의 배치는 (128, 256, 256, 3)
    + 2D 합성곱 층 (convolution layer)
- **동영상:** **(samples, frames, height, width, channels)** 또는 (samples, frames, channels, height, width) **5D 텐서**
    + 60초 144x256 비디오를 초당 4프레임 샘플링 (총 240 프레임), 비디오 4개 가진 배치는 (4, 240, 144, 256, 3)

## 배치 데이터

일반적으로 딥러닝에서 사용하는 모든 데이터 텐서의 0번째 축은 **샘플 축, 샘플 차원** (sample axis, dimension)이라 부른다.

딥러닝 모델은 한번엔 전체 데이터셋을 처리하지 않고, 작은 **배치 (batch)**로 나눈다.

배치 데이터를 다룰 때는 0번 축을 **배치 축, 배치 차원** (batch axis, dimension)이라 부른다.

---

# 2. 텐서 계산

## 브로드캐스팅

크기가 다른 두 텐서가 더해질 때, 작은 텐서가 큰 텐서의 크기에 맞추어 브로드캐스팅 (broadcasting)이 된다.

1. 큰 텐서의 ndim에 맞게 작은 텐서에 브로드캐스팅 축이 추가된다.
2. 작은 텐서가 새 축을 따라서 큰 텐서의 크기에 맞도록 반복된다.

## 브로드캐스팅 예시

X의 크기는 (32,10)이고 y는 (10,)이라 할때 y에 비어 있는 첫 번째 축을 추가하여 크기를 (1,10)으로 만든다.

이 y를 이 축에 32번 반복하면 Y의 크기는 (32,10)

구현 입장에서는 새로운 텐서가 만들어지면 비효율적이므로 

반복되는 연산은 가상으로, 알고리즘 수준으로 일어난다.

> 새로운 축을 따라 반복된다고 생각하는 것이 이해하기 쉽다고 한다. 

---

# 3. 그래디언트 기반 최적화

그래디언트는 텐서 연산의 변화율이다.

## 확률적 경사 하강법 (SGD, Stochastic Gradient Descent)

미분 가능한 함수가 주어지면, 최솟값을 변화율이 0인 지점이라고 해석적으로 구할 수 있다.

변화율이 0이 되는 지점을 모두 찾고 어떤 함수 값이 가장 작은지 확인할 때, 실제 신경망에서는 파라미터 개수가 매우 많기에 이 과정이 어렵다.

**미니 배치 확률적 경사 하강법** (mini-batch SGD)로 파라미터를 수정하며 손실을 감소시켜 나간다.

1. 훈련 샘플 배치 x와 이에 상응하는 타깃 y를 추출
2. x로 네트워크를 실행하고 예측 y_pred를 구함
3. 이 배치에서 y_pred와 y 사이의 오차를 측정, 네트워크 손실 계산
4. 네트워크 파라미터에 대한 손실 함수의 그래디언트 계산 (역방향 패스 (backward pass))
5. 그래디언트 반대 방향으로 파라미터 조금 이동

step 값이 너무 작으면 지역 최솟값에 갇힐 수도, 너무 많은 반복이 필요할 수도 있다.

너무 크면 손실 함수 곡선에서 완전히 임의의 위치로 이동할 수 있다.

업데이트된 사중치를 고려하는 Adagrad, **RMSProp** 등의 SGD 변종들이 있다. 

이런 변종들을 **최적화 방법 (optimization method)** 또는 **옵티마이저**라 부른다.

**모멘텀 (momentum)** 개념을 통해 수렴 속도와 지역 최솟값 문제를 해결한다.

> 요약을 하자면 **학습**은 손실 함수 최소화하는 모델 파라미터 조합을 찾는 것.
> 
> 전체 학습 과정은 신경망이 **미분 가능**한 텐서 연산으로 연결되어서 가능하다. 
> 
> 현재 파라미터와 배치 데이터를 그래디언트 값에 매핑 해주는 그래디언트 함수를 구성하기 위해 미분의 연쇄 법칙 사용.
> 
> **손실**과 **옵티마이저**는 네트워크에 데이터 주입전에 정의되야함.
> 
> 옵티마이저는 손실에 대한 그래디언트가 파라미터를 업데이트하는 방식.
> 
> 손실은 훈련하는 동안 최소화해야할 양, 문제 해결의 성공을 측정.

---

# 4. 손실 함수 (loss function)

목적 함수 (objective function)으로도 불린다. 훈련동안 최소화될 값이며 성공 지표다.

여러 출력을 내는 신경망은 출력당 하나씩, 여러 손실 함수를 가질 수 있다.

경사 하강법 과정은 하나의 스칼라 손실 값을 기준으로 하기 때문에, 모든 손실의 평균을 내서 하나의 스칼라 양으로 합쳐서 진행하게 된다.

## 손실 함수 선택 지침

분류, 회귀, 시퀀스 예측 같은 일반적인 문제에서는 올바른 손실 함수를 선택하는 지침이 있다고 한다.

- **2개의 클래스가 있는 분류 문제:** 이진 크로스엔트로피 (binary crossentropy)
- **여러개의 클래스가 있는 분류 문제:** 범주형 크로스엔트로피 (categorical crossentropy)
- **회귀 문제:** 평균 제곱 오차 (MSE)
- **시퀀스 학습 문제:** CTC (Connection Temporal Classification)

일반적인 간단화한 지침이라 하여, 공부를 진행하며 업데이트 해가거나, 따로 게시글을 작성할 예정이다.

---

# 참고

**"케라스 창시자에게 배우는 딥러닝"** - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김)

- 깃허브: <http://github.com/gilbutITbook/006975>
- 길벗출판사 홈페이지: <http://www.gilbut.co.kr>
- tensorflow 2.4 버전 코드 <https://github.com/rickiepark/deep-learning-with-python-notebooks/tree/tf2>