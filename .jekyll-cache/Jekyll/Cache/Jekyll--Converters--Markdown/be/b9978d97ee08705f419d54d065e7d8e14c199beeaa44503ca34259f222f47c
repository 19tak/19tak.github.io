I"?%<h1 id="문제">문제</h1>

<p>그동안 읽어오던 csv 파일과는 다르게 해당 data set은 많은 수의 feature와 데이터들로 이루어져서 파일이 나뉘어져있다.</p>

<p>​features.txt 에는 중복을 포함한 561개의 feature에 대한 index와 name이
_text.tx, _train.txt 에는 각 feature에 대한 data들의 test, train split이 담겨져있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline

# features.txt 파일에는 피처 이름 index와 피처명이 공백으로 분리되어 있음. 이를 DataFrame으로 로드.
feature_name_df = pd.read_csv('./human_activity/features.txt',sep='\s+',
                        header=None,names=['column_index','column_name'])

# 피처명 index를 제거하고, 피처명만 리스트 객체로 생성한 뒤 샘플로 10개만 추출
feature_name = feature_name_df.iloc[:, 1].values.tolist()
print('전체 피처명에서 10개만 추출:', feature_name[:10])
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767492-c04d488e-e2a8-4844-bf71-23afefa70a85.png" alt="image" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature_dup_df = feature_name_df.groupby('column_name').count()
feature_name_df.groupby('column_name').count()
print(feature_dup_df[feature_dup_df['column_index']&gt;1].count())
feature_dup_df[feature_dup_df['column_index']&gt;1].head()
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767570-c87988f7-999b-4dad-9da7-ebe30a0aea20.png" alt="image" />
<img src="https://user-images.githubusercontent.com/84369912/126767591-4396e768-3f70-462f-abc1-cd6cdba34a5d.png" alt="image" /></p>

<p>중복된 feature name을 피하는 것을 원칙으로 하기 때문에 중복된 feature name들을 확인해주었다.</p>

<p>중복된 원본 feature name 뒤에 _1 또는 _2를 추가하여 중복을 피해주는 함수를 작성.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def get_new_feature_name_df(old_feature_name_df):
    feature_dup_df = pd.DataFrame(data=old_feature_name_df.groupby('column_name').cumcount(),
                                 columns=['dup_cnt'])
    feature_dup_df = feature_dup_df.reset_index()
    new_feature_dup_df = pd.merge(old_feature_name_df.reset_index(), feature_dup_df, how='outer')
    new_feature_dup_df['column_name'] = new_feature_dup_df[['column_name',
                                                            'dup_cnt']].apply(lambda x: x[0]+'_'+
                                                                             str(x[1])
                                                                             if x[1]&gt;0
                                                                             else x[0], axis=1)
    new_feature_dup_df = new_feature_dup_df.drop(['index'],axis=1)
    return new_feature_dup_df
</code></pre></div></div>
<p>중복된 feature name을 처리해주고 test, train split 된 데이터를 로드한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def get_human_dataset():
    
    # 각 데이터 파일은 공백으로 분리, read_csv에서 공백 문자를 sep으로 할당
    feature_name_df = pd.read_csv('./human_activity/features.txt',sep='\s+',
                             header=None, names=['column_index','column_name'])
    
    # 중복된 피쳐명을 수정하는 get_new_feature_name_df()를 이용, 신규 피처명 DataFrame 생성
    new_feature_name_df = get_new_feature_name_df(feature_name_df)
    
    # DataFrame에 피처명을 칼럼으로 부여하기 위해 리스트 객체로 다시 변환
    feature_name = new_feature_name_df.iloc[:,1].values.tolist()
    
    # 학습 피처 데이터세트와 테스트 피처 데이터를 DataFrame으로 로딩. 칼럼명은 feature_name 적용
    X_train = pd.read_csv('./human_activity/train/X_train.txt',sep='\s+',names=feature_name)
    X_test = pd.read_csv('./human_activity/test/X_test.txt',sep='\s+',names=feature_name)
    
    # 학습 레이블과 테스트 레이블 데이터를 DataFrame으로 로딩하고 칼럼명은 action으로 부여
    y_train = pd.read_csv('./human_activity/train/y_train.txt',sep='\s+',header=None,names=['action'])
    y_test = pd.read_csv('./human_activity/test/y_test.txt',sep='\s+',header=None,names=['action'])
    
    # 로드된 학습/테스트용 DataFrame을 모두 반환
    return X_train, X_test, y_train, y_test

X_train, X_test, y_train, y_test = get_human_dataset()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print('## 학습 피처 데이터셋 info()')
print(X_train.info())
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767718-7810d623-005d-4873-9a97-d476e450127c.png" alt="image" /></p>

<p>로드된 학습용 피처 데이터 세트</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print(y_train['action'].value_counts())
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767755-0ca66017-ea1c-4159-b498-c24e33fee585.png" alt="image" /></p>

<p>로드된 학습용 레이블 데이터 세트에서 숫자형의 레이블 확인 별도의 카테고리 인코딩 불필요</p>

<h1 id="decision-tree">Decision Tree</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

# 예제 반복 시 마다 동일한 예측 결과 도출을 위해 random_state 설정
dt_clf = DecisionTreeClassifier(random_state=156)
dt_clf.fit(X_train , y_train)
pred = dt_clf.predict(X_test)
accuracy = accuracy_score(y_test , pred)
print('결정 트리 예측 정확도: {0:.4f}'.format(accuracy))

# DecisionTreeClassifier의 하이퍼 파라미터 추출
print('DecisionTreeClassifier 기본 하이퍼 파라미터:\n', dt_clf.get_params())
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767838-0588b0c2-5152-48ba-98aa-ad88ed9b0521.png" alt="image" /></p>

<p>decision tree accuracy 값과 default hyper parameter 값을 확인</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from sklearn.model_selection import GridSearchCV

params = {
    'max_depth' : [ 6, 8 ,10, 12, 16 ,20, 24]
}

grid_cv = GridSearchCV(dt_clf, param_grid=params, scoring='accuracy', cv=5, verbose=1 )
grid_cv.fit(X_train , y_train)
print('GridSearchCV 최고 평균 정확도 수치:{0:.4f}'.format(grid_cv.best_score_))
print('GridSearchCV 최적 하이퍼 파라미터:', grid_cv.best_params_)
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767887-a3c4d8a8-5bbb-4f83-9d10-d09b89cc7042.png" alt="image" /></p>

<p>gridsearchCV를 사용하여 tree depth를 변화</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># GridSearchCV객체의 cv_results_ 속성을 DataFrame으로 생성. 
cv_results_df = pd.DataFrame(grid_cv.cv_results_)

# max_depth 파라미터 값과 그때의 테스트(Evaluation)셋, 학습 데이터 셋의 정확도 수치 추출
cv_results_df[['param_max_depth', 'mean_test_score']]
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767928-59fc3521-157b-425e-86fb-5b680b2f0b76.png" alt="image" /></p>

<p>max_depth의 변화에 따른 평균 정확도 수치 추출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>max_depths = [ 6, 8 ,10, 12, 16 ,20, 24]
# max_depth 값을 변화 시키면서 그때마다 학습과 테스트 셋에서의 예측 성능 측정
for depth in max_depths:
    dt_clf = DecisionTreeClassifier(max_depth=depth, random_state=156)
    dt_clf.fit(X_train , y_train)
    pred = dt_clf.predict(X_test)
    accuracy = accuracy_score(y_test , pred)
    print('max_depth = {0} 정확도: {1:.4f}'.format(depth , accuracy))
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126767975-fc5ce7d0-2838-49d7-8617-18cdb7fa8462.png" alt="image" /></p>

<p>gridsearchCV 없이 별도의 테스트 데이터 세트에서 depth 변화</p>

<p>깊이 8을 넘으면 over fitting이 일어나는것을 확인.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>params = {
    'max_depth' : [ 8 , 12, 16 ,20], 
    'min_samples_split' : [16,24],
}

grid_cv = GridSearchCV(dt_clf, param_grid=params, scoring='accuracy', cv=5, verbose=1 )
grid_cv.fit(X_train , y_train)
print('GridSearchCV 최고 평균 정확도 수치: {0:.4f}'.format(grid_cv.best_score_))
print('GridSearchCV 최적 하이퍼 파라미터:', grid_cv.best_params_)
</code></pre></div></div>
<p><img src="https://user-images.githubusercontent.com/84369912/126768011-7d983335-519a-4a10-b6cd-c8860b931aeb.png" alt="image" /></p>

<p>gridsearchCV로 depth와 min samples split도 변화해보았다.</p>

<p>max depth가 8 main sample split이 16일때 최고의 정확도를 확인</p>

:ET