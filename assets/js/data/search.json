[ { "title": "[주식] 12.[초보] 초보도 이해할 수 있는 주식투자 - 작성중", "url": "/posts/01-stock_study_01/", "categories": "Study, Stock", "tags": "Stock, 강환국", "date": "2023-04-05 00:00:00 +0900", "snippet": "본 포스팅은 “할 수 있다! 알고 투자” 유튜브 온라인 강의 컨텐츠를 바탕으로 공부한 내용을 정리한 것입니다.투자에서 돈은 어떻게 버나?자산배분 : 각 자산군에 총 자산을 어떻게 배분? 자산군: 주식, 채권, 부동산, 원자재, 코인 등마켓타이밍 : 언제 사고 언제 파나?종목 선정 (자산군 내 무엇을 사나?)주식 투자, 정석이 있습니다(주식 종목 선정) 모든 논문의 테마 어떤 전략으로 주가지수보다 높은 수익을 내나? 수천명의 교수들이 수만개에 논문에 저걸 연구 주가지수 수익 KODEX, 200, ETF 등으로 달성 가능 주식투자정석의 핵심이란?저평가 주식 수익 굿우량주 주식 수익 굿최근 많이 오른 주식 (모멘텀) 수익 굳1. 저평가 싸게사서, 비싸게 팔아라 싸다는 것은 무엇을 의미? 낮은 주가? 가격대비 기업 회계 지표!저평가지표 PER : 시가총액/순이익 시가총액: 기업의 모든 주식을 사는데 필요한 돈 주식: 기업의 일부 기업의 목적: 이익 내기 PER가 낮으면: 이익 대비 기업 가격이 싸네 PBR : 시가총액/순자산 순자산: 보유 자산 - 부채 주주는 기업 순자산의 오너 PBR가 낮으면: 자산 대비 기업 가격이 싸네 PCR : 시가총액/영업현금흐름 PER와 매우 비슷한 개념 회계상 이익과 현금흐름의 개념은 조금 다름 예: 감가상각 (- 수익, 현금흐름 0) PSR : 시가총액/매출액 매출은 궁극적 목적 수익과는 다르나 중요한 지표 PSR가 낮으면: 가격 대비 매출이 높네 배당수익률 : 주당 배당/주가 배당: 기업이 돈을 벌고 주주에게 나눠주는 돈 나머지는 기업 내에 유보, 투자 또는 짱박기 배당수익: 은행 이자와 비교 가능. 높으면 일단 유리 저평가지표 천차만별. 왜 그렇지? PER: 5~500까지 있음 (평균: 10-15) PBR: 0.2-20 (평균: 1 언저리) PER, PBR 높으면 기대가 높음 지금은 보잘 것 없으나 미래는 화려하리 반대로 PER, PBR가 낮으면 투자자들의 기대가 적음저평가지표 낮으면 진짜 저평가? 시나리오1: 투자자들의 기대가 맞음 현재 수익, 현금흐름 등은 좋으나 기대대로 박살 시나리오2: 투자자들의 기대가 틀림 수익, 현금흐름 등 유지 또는 증가 결론: 시나리오2 확률이 좀더 높음, 따라서 지표 낮은 주식 수익 높음2. 우량주좋은 기업을 사서 오래 보유하라 (버핏 형)우량주의 의미는 무엇?주요 회계지표로 확인 가능! (가격 안 중요)우량주 지표 (수익성) 투입 자본/자산 대비 돈 많이 버는 놈 장땡 ROE : 순이익/순자산 ROA : 순이익/총자산 GP/A : (매출-매출원가) / 총자산우량주지표 (안정성) 호경기에 돈 잘 벌어도 불경기에 파산하면 쪽박 부채비율: 부채/총자산 이익변동성: 이익이 고르게 - 들쭉날쭉하면 안 좋음우량주지표 (성장성) 수익이 늘거나 수익성 지표가 개선되면 좋음 매출, 영업이익, 순이익 증가율 ROE, ROA 등의 증가율우량주지표 (배당성향) 배당 잘 주는 기업 좋은 기업, 주식 찍어내는 기업 나쁜 기업 이익 : 배당 또는 유보 가능 배당받은 돈은 내 거 (좋음), 유보하면 이상한데 쓰이겠지 특히 주식을 찍는 기업 나쁜 기업! (돈 찍으면 인플레)지금 우량주 기업, 미래에도 우량직위 유지? 대체로 그렇다 투자자들, 우량주 기업의 포텐을 과소평가 따라서 우량주 기업 저평가, 미래수익 굿3. 모멘텀 최근 3~12개월간 많이 오른 주식 계속 오른다 최근 1개월간 많이 오른 주식은 다시 추락! 매우 무식하나 학계에서 가장 강력한 정석으로 인정 최근 1년간 가장 많이 오른 대형주들 20개 매수모멘텀 어떻게 이게 말이되나처음에는 과소평가 (앵커 효과)나중에는 과열효과 (가즈아)그래서 한동안 오름현상 지속4. 요약저평가 기업 구매, 굿 (PER, PBR 등 낮음)저평가 기업보다 저평가 우량주가 유력?중소형주는 이렇게 뽑자저평가 기업보다 최근 많이 오른 저평가 우량주대형주는 이렇게 뽑자거의 모든 계량 투자 전략은 소형주에서 잘 먹힘무늬만 저평가보다 진짜 저평가 확률 높음대형주는 보는 눈 많음, 무늬만 저평가 가능성 높음한국 모멘텀 투자는 대형주만 잘된다이해불가, 그냥 그런가보다 라고 이해하시기 바람참고 “할 수 있다! 알고 투자” 유튜브 채널 12. [초보] 초보도 이해할 수 있는 주식투자! " }, { "title": "[IT] 프로세스 모델링 이해 04 - 분석 / 현행 시스템 분석", "url": "/posts/04-process_modeling/", "categories": "Study, IT", "tags": "IT, Process Modeling", "date": "2022-09-25 00:00:00 +0900", "snippet": "본 포스팅은 “프로세스 모델링 이해” 온라인 강의를 바탕으로 공부한 내용을 정리한 것입니다. 현행 시스템 분석 현행 시스템 분석의 중요성 절차 현행 시스템 분석 전략 수립 현행 시스템 자료 요청 및 수집 현행 시스템 분석 현행 시스템 분석 결과 확인 개선 사항 정의하기 현행 시스템 분석시 주의 사항 역공학 도구를 활용한 현행 시스템 분석 현행 시스템 분석 현행 시스템 및 업무를 비즈니스와 데이터 관점에서 분석하는 작업 목적 To-Be 시스템을 구축하기 전, 현행 시스템 및 업무/데이터에 대한 이해를 도와주며 향후 데이터 분석 및 데이터 전환의 자료로 활용할 수 있게 해줌 또한 업무영역의 핵심 프로세스를 파악할 수 있게 해줌. 현장에서 현행 시스템 분석이 제대로 이루어지지 않으면 프로젝트 납기 지연으로 이어짐개발대상 업무 범위에 대한 누락 수집자료의 원천적인 누락 통합이 아닌 부분별 업무 수집으로 누락 Owner가 변경된 영역 또는 공통영역의 누락 설계 및 개발 시 ‘예츨 불가한’ 일정 지연, 품질 미흡 프로그램 복잡도 수준 파악이 개발단계에서도 이루어지지 않음 상세 업무 로직 파악을 위한 현행 소스를 보지 않음 업무에 대해 이해하지 않고 현행 소스만 봄 (왜 그런 로직이 있는지 모름)현행 시스템 분석 절차 단계 태스크 현행 시스템 분석 전략 수립 고객사의 시스템 상황별 분석 전략 수립 현행 시스템 자료 요청 및 수집 요구사항 수집, 정의, 검토 현행 시스템 분석 현행 프로세스와 데이터 분석 분석 결과 확인 현행 시스템의 프로세스와 데이터 분석 결과 고객 확인 워크샵 수행 개선사항 정의 현행 시스템 분석 결과를 토대로 개선 사항 정의, 향후 요구사항 및 프로세스 정의에 활용 현행 시스템 분석 전략 수립보안에 관해서는 소스/데이터에 대한 보안 정책을 수립하여 고객 승인을 득하고현행 시스템의 환경을 구성하여 해결프로그램의 난이도와 업무 중요도를 고려하여 소스의 선택적 분석짧은 분석 기간과 복잡한 프로그램의 호출구조는 역공학을 통해 분석 수행을 하도록 전략 수립 주의점. 현장의 ㅏ항을 이해하고 현장에 맞는 분석 전략을 세우는 것. 현행 시스템 자료 요청 및 수집현행 시스템 산출물을 확보하고 검토 현행 업무 기능 관련 자료 요청 및 수집 현행 업무 흐름 관련 자료 요청 및 수집 현행 프로그램 자료 수집 (온라인/배치/보고서/인터페이스) 현행 트랜잭션 발생 건수 자료 수집 (우선순위 결정시 사용) 현행 테이블 자료 요청 및 수집 코드 자료 요청 및 수집 현행 시스템 접속 권한 요청이때, 수집하는 산출물은 출처와 버전관리가 반드시 필요! 유지보수 산출물, 모델, 현행 시스템 접속, 소스 분석 현행 시스템 분석 현행 시스템 및 업무를 파악할 수 있는 수집된 자료 (업무 규정집, 현행 시스템 관련 문서) 반영 비즈니스/데이터 관점에서 분석 후, 현행 시스템 분석서를 작성 업무 영역의 핵심 프로세스를 파악하고, 향후 데이터 분석 및 데이터 전환의 자료로 활용 현행화면 분석 현행데이터 분석 현행기능 (프로그램목록) 분석 현행 업무기능분해도 / 현행 업무흐름도 분석 현행시슽현행시스템 분석서 현행업무기능분해도 현행업무흐름도 현행프로그램목록 현행테이블정의서 현행코드정의서 현행 시스템 분석 결과 확인 현행 시스템 분석의 충분성과 완전성을 고객 참여 워크샵을 통해 고객 확인을 받음 불용 여부가 표시된 현행 화면/ 테이블/프로그램/인터페이스 목록 등 확인 워크샵에는 의사 결정권자가 반드시 참여하여 결정 개선 사항 정의하기 현행시스템 분석을 통해 개선 사항 도출 고객의 입장에서 개선사항이 필요한 내용을 스스로 정리 현행 시스템과 제안서 대비 분석 내용 정리 To-Be 시스템 설계 시 반영 여부는 내부 및 고객으로부터 반드시 확인 능동적인 업무 진행으로 고객의 신뢰 획득 현행 시스템 분석시 주의 사항시스템 산출물을 통해 요구사항을 분석하는 경우, 원천의 정확성 반드시 확인 (공식 채널을 통해 요청)하드 코딩된 기능 요구 사항을 식별하기 위해서는 소스코드도 접근해야함 고객에서 받은 현행 시스템 자료는 완전하지 않다는 전제로 꼼꼼히 체크해야함 수집된 프로그램 목록은 최신의 소스 목록과 비교하여 최신화, 테이블 정보는 DB를 Reverser하여 추출 먼저 분석하고, 집중해야하는 중요한 영역을 식별 중요 기능 영역으로 분류, 프로그램 사용량 분석요구사항 유형에 따라 접근 방식이 달라짐 화면인 경우 현행 시스템에 필히 접속하여 분석 역공학 도구를 활용한 현행 시스템 분석현행 시스템 정보를 분석하여 결과를 다양한 분석 산출물 (문서, 모델 등)로 제공하는 역공학 도구 소스코드를 분서가형 결과를 DB에 저장, 다양한 관점의 데이터를 실시간으로 조회하거나 분석 산출물을 제공 현행시스템분석 시 역공학 산출물을 참고하여 활용주요 제공산출물 프로그램목록 호출관계도 cRUD 매트릭스 모듈 유사도 인터페이스 목록역공학산출물분석-&gt; 불용 프로그램/불용테이블파악 타 시스템과 연관관계 파악 통합 대상 프로그램 선정 재사용 모듈화 대상 정리 공통 모듈 정리 분리 대상 모듈 선정현행 시스템 분석을 위한 자료들을 다 수집했는가?현장에 맞는 현행 시스템 분석 전략을 수립하고 효율적으로 실행하였는가?불용 프로그램/엔터티를 분석하고 인터페이스를 파악하였는가?현행 시스템의 업무와 시스템 기능을 이해하였는가?현행 시스템의 문제점을 파악하였는가?현행 시스템의 범위가 누락 없이 정의되었는가?참고" }, { "title": "[IT] 프로세스 모델링 이해 03 - 분석 개요", "url": "/posts/03-process_modeling/", "categories": "Study, IT", "tags": "IT, Process Modeling", "date": "2022-09-25 00:00:00 +0900", "snippet": "본 포스팅은 “프로세스 모델링 이해” 온라인 강의를 바탕으로 공부한 내용을 정리한 것입니다.시스템 개발 단계의 스텝 시스템 개발 진행 시 분석 -&gt; 기본설계 -&gt; 상세설계 -&gt; 개발 -&gt; 테스트 -&gt; 전개 등의 단계로 진행시스템 개발 단계별 산출물 연관관계도 - 분석현행 시스템 분석, 요구사항 정의 분석 구축 대상 업무 및 시스템에 대해 철저히 분석/이해하여 핵심업무를 선정하는 단계현행업무 흐름도, 현행프로그램목록, 현행테이블 정의서 등의 산출물현행시스템 분석 완료 후 요구사항 정의작업현행시스템의 문제점, 개선사항을 고객 인터뷰나 설문을 통해 수집한 후, 요구사항 정의서에 반영비즈니스 업무기능에 관한 요구사항은 To-be프로세스 분석 단계에사용자 인터페이스에 관한 요구사항은 화면정의 단계에데이터 관련 업무기능에 관한 요구사항은 데이터 분석 단계에내부/외부 시스템 연계에 대한 요구사항은 인터페이스 정의 단계에 사용 To-Be 프로세스 분석 현행시스템을 분석한 내용을 바탕으로 정의된 요구사항을 반영, 개선된 프로세스를 업무기느분해도, 업무흐름도를 통해 기술하는 작업산출물 업무배경도, 업무기능분해도, 업무흐름도, 통합업무흐름도 화면 정의 주요한 화면의 레이아웃 및 입/출력을 정의하여, 고객과의 협의를 통해 요구사항을 구체적으로 확정하는 활동 산출물 화면정의서, 메뉴구조도 등 데이터 분석 현행시스템에서 분석한 용어/도메인을 조사데이터 관련 업무기능에 관한 요구사항을 반영하여 엔터티 도출속성/식별자/관계를 정의하는 활동산출물 논리ERD, 엔터티 정의서 등 인터페이스 정의 요구사항에서 정의된 내부/외부 연계 요구사항과To-Be 프로세스 분석 단계에서 도출된 업무간 내부/외부 연계를 반영하여내부 인터페이스 명세서와 외부 인터페이스 명세서를 작성 단계말 검토 검토내용을 반영하여 검토결과서 작성, 검토 내용중 발생된 변경사항은 분석 산출물에 재반영요구사항추적 매트릭스는 요구사항을 추적할 수 있도록 해 주는 문서분석 시 도출된 요구사항이 설계 단계를 거쳐 구축단계에 어떻게 반영되었는지를 확인 해 주는 지표로 사용요구사항을 추적하는 ID로는 요구사항ID, 업무기능 ID, 화면 ID 등이 사용참고" }, { "title": "[IT] 프로세스 모델링 이해 02 - 프로세스 모델링 개요, 절차", "url": "/posts/02-process_modeling/", "categories": "Study, IT", "tags": "IT, Process Modeling", "date": "2022-09-21 00:00:00 +0900", "snippet": "본 포스팅은 “프로세스 모델링 이해” 온라인 강의를 바탕으로 공부한 내용을 정리한 것입니다. SW 개발 방법론 정의 및 필요성 개발 방법론의 정의 개발 방법론의 필요성 SW 개발 방법론 발전 SW 개발 방법론의 발전 프로젝트에서의 적용 1. SW 개발 방법론 정의 및 필요성개발 방법론의 정의시스템을 개발하기 위한 활동 절차, 도구, 산출물, 기법 등을 체계적으로 정리한 것개발 방법론의 필요성 품질보증의 기준 제공 프로젝트 계획 수립의 효율적인 길잡이 역할 위험 요소 분석을 위한 가이드 표준화를 통한 기술 축적/진화 의사소통의 기반 따라서 표준화, 모듈화, BP (Best Practice), 재활용을 통한 개발생산성 향상 정형화된 절차, 표준 용어를 이용한 효과적인 의사소통 수단2. SW 개발 방법론 발전SW 개발 방법론의 발전1. 구조적 방법론SW개발 방법론도 프로젝트에 적용되면서 지속적으로 변화해 왔다. 구조적 방법론 기능 분할을 활용한 업무 기능을 파악하여, 프로세스 중심으로 분석/설계하는 방법론.대표 산출물은 Data Flow Diagram, Structure Chart2. 정보공학 방법론 정보공학 방법론 기업 레벨의 프로세스와 데이터를 분석/설계하는 기법. 구조적 방법과의 차이점은 데이터 중심의 접근법을 통해 분석/설계를 진행하는 점.대표 산출물은 업무기능분해도, ERD3. 객체지향 방법론 객체지향 방법론 프로세스와 데이터를 포함하는 object단위의 분석/설계를 진행. Object (객체) : 속성과 메소드가 결한된 형태 주요산출물은 Usecase Diagram, Sequence Diagram 등4. CBD 방법론 CBD 방법론 (Component Based Development) 컴포넌트 기반의 분석/설계를 진행하며 SW 유지보수성 및 높은 재사용성. 컴포넌트 : 특정기능을 수행하는 모듈로, 시스템에 종속적이지 않아 재사용 가능하고 교체가 가능한 단위. 주요산출물은 컴포넌트 명세서, Interface Diagram 등5. SOA (Service Oriented Architecture) 방법론 SOA 외부 제공 및 재사용 가능한 업무 프로세스 기반 서비스 단위의 분석/설계. 프로세스 중심에서 프로세스와 데이터 중심으로, 프로세스와 데이터를 포함하는 객체단위에서 컴포넌트 단위, 외부 제공 가능한 서비스 단위까지 발전해왔다.프로젝트에서의 적용1. Monolithic AApplication 초기 SW개발시의 모습. 하나의 Application 영역과 DB 영역을 관리하는 형태. 유사한 성격의 logic이 여기저기 흩어져 있고, DB와의 연결관계도 스파게티처럼 연결됨. logic의 변경/삭제 발생시 범위 파악과 수정이 어렵고 전반적으로 관리가 어려움. 하나의 프로세스로 운영되다 보니 서비스 반영을 위해서 한번에 빌드/배포해야 하는 어려움. 서비스 on/off시 모든 서비스를 이용할 수 없는 일괄장애 상태의 문제점 발생.2. Internally Componentized Application 관리의 규모와 SW복잡성이 증가하며 Monolithic Application에서 진화. 모듈화, CBD, SOA 등의 방법으로 거대한 하나의 Application의 논리적 분리 진행. 유사한 연결성이 높은 logic들 그룹화하여 관리. 공공, 금융 등의 아웃소싱 프로젝트 대부분에서 해당 구조 채택. 논리적 분리의 한계점 발생, 스파게티 logic 여전히 존재하여 서비스 장애와 빌드/배포에서 문제 발생.3. Microservice Architecture (MSA) MSA는 서비스별로 application과 DB를 분리, 각 프로세스로 실행되는 형태. 서비스 분할시에는 업무중심으로 분할됨. MSA는 물리적 분리를 반영, 장애 발생시 다른 서비스들의 중단없이 제공 가능, 빌드/배포 용이.4. 최적의 방법론은?가장 좋은 방법론이란 타 사이트가 했다, 최신이라 적용했다가 아닌,관리의 규모와 복잡성에 따라, 현행시스템의 문제점과 해결의 관점에 따라,각각의 상황에 맞는 방법론을 선택 적용할 것.참고" }, { "title": "[IT] 프로세스 모델링 이해 01 - 개요", "url": "/posts/01-process_modeling/", "categories": "Study, IT", "tags": "IT, Process Modeling", "date": "2022-09-21 00:00:00 +0900", "snippet": "본 포스팅은 “프로세스 모델링 이해” 온라인 강의를 바탕으로 공부한 내용을 정리한 것입니다. 모델링 모델링의 세 가지 관점 프로세스 모델링이란? 프로세스 모델링을 이해할 때 가장 중요한 개념 프로세스 프로세스의 종류 1. 모델링모델링의 세 가지 관점 데이터 관점 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해 모델링하는 방법 (What, Data) 프로세스 관점 업무가 실제 하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링하는 방법 (How, Process) 데이터와 프로세스의 상관 관점 업무가 처리하는 일의 방법에 따라 데이터가 어떻게 영향을 받고 있는지 모델링하는 방법 (Interaction)프로세스 모델링이란? 정보 시스템을 구축하기 위해 해당 업무에 어떤 프로세스가 존재하는지 또는 업무 처리에 필요한 프로세스는 무엇인지 분석하는 방법. 정해진 기간 내에 업무를 효율적으로 분석하여, 목표시스템에서 요구하는 기능을 만족할 수 있게 누락되거나 불필요한 업무를 골라내는 일. 프로세스를 실행함으로써 데이터의 입력과 출력이 수행프로세스 모델링을 이해할 때 가장 중요한 개념 단위 프로세스 트랜잭션 데이터 무결성 보장 데이터 무결성 데이터의 정확성과 일관성을 유지하고 보증하는 것을 말함.2. 프로세스프로세스의 종류 기능 영역 업무기능의 집합. 일반적으로 ‘부문’, ‘본부’ 등의 커다란 조직 단위에서 수행하는 업무 전체를 말한다. 업무 기능 기업이나 기관의 한 분야를 완전하게 지원하는 업무활동들의 집합. 한 기능을 구성하고 있는 그룹은 일반적으로 유사한 업무 데이터를 사용하기 때문에 서로 관련되어 있다. 예) 경영 관리, 자재 관리, 생산 관리, 영업 관리, … 업무 프로세스 잘 정의된 업무 활동들로 그것의 실행은 특정 엔티티의 입력 및 출력으로 규정될 수 있다. 예) 프로젝트 계획수립, 프로젝트 계획변경 단위 프로세스 프로세스를 구성하는 최하위 단위로 일반적으로 입력처리, 출력처리 등을 정의. 다시 말해 특정 데이터의 항목에 대한 입력 또는 출력에 관계되는데 엔티티에 대한 4가지 기본 작업(CRUD)중 한가지 작업을 규정. 예) 고객 엔티티 조회, 상품 엔티티 조회, 주문내역 엔티티 생성, …참고 IT Story 님의 포스팅프로세스 모델링“데이터베이스 설계와 구축 - 성능까지 고려한 데이터 모델링” - (한빛미디어, 저자 이춘식)" }, { "title": "[FMTC] FMTC 원격주행 시스템 개발 02 - ", "url": "/posts/fmtc_02/", "categories": "Project, FMTC", "tags": "FMTC, SNU, remote driving, car, HSH, HJT, 19tak", "date": "2022-09-11 00:00:00 +0900", "snippet": "본 포스팅은 FMTC 서울대학교 미래 모빌리티 기술 센터에서 진행한 원격주행 시스템 개발 프로젝트에 관한 포스팅입니다.프로젝트 깃허브 : https://github.com/19tak/fmtc_udp프로젝트 진행 기간 2022년 6월 1일 수요일 ~ 7월 15일 금요일 1.2.##참고" }, { "title": "[FMTC] FMTC 원격주행 시스템 개발 01", "url": "/posts/fmtc_01/", "categories": "Project, FMTC", "tags": "FMTC, SNU, remote driving, car, HSH, HJT, 19tak", "date": "2022-09-11 00:00:00 +0900", "snippet": "본 포스팅은 FMTC 서울대학교 미래 모빌리티 기술 센터에서 진행한 원격주행 시스템 개발 프로젝트에 관한 포스팅입니다.프로젝트 깃허브 : https://github.com/19tak/fmtc_udp제안서제안서 느낀점좋은 기회로 서울대학교 미래 모빌리티 기술 센터 (FMTC)에서 자그마한 프로젝트에 참여할 수 있었습니다.프로젝트 참여 당시에도 비슷한 생각을 가지고 있었지만,죽을 때까지 이처럼 실차를 가지고 프로젝트에 다시 참여할 수 있을지 모르겠습니다.초기 tcp 통신을 사용하려다 여러 문제점에 udp로 변경하기까지, 큰 공부가 되었습니다.통신 프로토콜과 비젼, 파이썬 GUI 설계 등 프로젝트를 진행하며 새롭게 배운 내용들을 정리해두겠습니다.좋은 기회를 주신 한승호 연구원님께 언제나 감사의 말씀 올립니다.프로젝트 진행 기간 2022년 6월 1일 수요일 ~ 7월 15일 금요일" }, { "title": "[Tips] ubuntu teamviewer 설치", "url": "/posts/teamviewr/", "categories": "Etc, Tips", "tags": "ubuntu, teamviewer", "date": "2022-06-07 00:00:00 +0900", "snippet": "설치 방법wget https://download.teamviewer.com/download/linux/teamviewer_amd64.debsudo apt install ./teamviewer_amd64.deb참고 쵸코쿠키 님의 포스팅Ubuntu 18.04 : TeamViewer 설치 방법, 예제, 명령어" }, { "title": "[Tips] pandas / converting pandas groupby output from series to dataframe", "url": "/posts/01-pandas/", "categories": "Etc, Tips", "tags": "Python, Pandas, Series, Dataframe, Groupby", "date": "2022-06-04 00:00:00 +0900", "snippet": "pandas로 데이터핸들링하는 과정에서 groupby()한 output을 Dataframe형태로 사용하기 위해 공부한 내용이다.df.groupby(['뭐로','그룹지을지']).reset_index() 이런느낌으로 사용하면 된다.예제import pandas as pddf = pd.read_csv(\"example.csv\",encoding='cp949')df.info()&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 1000000 entries, 0 to 999999Data columns (total 26 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 IDV_ID 1000000 non-null int64 1 SEX 1000000 non-null int64 2 AGE_GROUP 1000000 non-null int64 ... dtypes: float64(19), int64(6), object(1) memory usage: 198.4+ MB26개의 column을 가진 df를 로드했다.이 df를 성별과 연령별로 사람 수를 보려한다면, 그 중에서도 성별이 1(남자)만 보겠다~면~dff = df.groupby(['SEX','AGE_GROUP'])dff.IDV_ID.size().reset_index()[dff.IDV_ID.size().reset_index().SEX==1]이런 느낌으로 사용하면된다~참고 Stackoverflow 게시글Converting a Pandas GroupBy output from Series to DataFrame" }, { "title": "[Tips] Python Matplotlib / plt.savefig 가 빈이미지를 저장할 때", "url": "/posts/01-matplotlib/", "categories": "Etc, Tips", "tags": "Python, Matplotlib, savefig", "date": "2022-06-04 00:00:00 +0900", "snippet": "Matplotlib으로 이미지를 저장할 때 빈 이미지가 저장되는 것을 해결하며 공부한 내용이다.MatplotlibPython으로 시각화할때 자주 사용하는 Matplotlib이를 사용할때 보통 다음과 같은 프로세스로 진행한다.import matplotlib.pyplot as plt'''그래프 그릴거 다 그리고'''plt.savefig(\"저장할이름.jpg\")plt.show()여기서 plt.savefig()를 사용할때 종종 빈 이미지가 저장되는 것을 확인할 수 있다.확인해야할 것은 plt.show()와 plt.savefig()의 서순.plt.show()는 그래프를 보여준 이후 지운다. 캔버스를 리셋하는 느낌.그렇기 때문에 비어있는 이미지가 저장된 것이다.요약plt.show() 보다 plt.savefig()가 먼저 호출되어야 한다.참고 리뷰나라 게시글[python] Matplotlib (pyplot) savefig는 빈 이미지를 출력합니다." }, { "title": "[Tips] ubuntu 카메라 디바이스 관련, v4l2", "url": "/posts/ubuntu-webcam/", "categories": "Etc, Errors", "tags": "ubuntu, webcam", "date": "2022-06-01 00:00:00 +0900", "snippet": "카메라 디바이스우분투 환경에서 카메라 등의 디바이스가 설치 되어있을 때 확인하는 방법이 여러가지가 있다.프로젝트를 진행하며 Usb 웹 캠을 사용했고, 디바이스 번호 및 호환 해상도 등을 확인하기 위해 사용했다.dmesg | grep -i \"Camera\"ls -ltrh /dev/video*v4l2-ctl --list-devicesv4l2v4l2가 있다면 다음의 메세지로 편하게 확인할 수 있다.sudo apt install v4l-utilsv4l2-ctl --list-devicesv4l2-ctl --list-formats-ext--list-devices 옵션으로는 모든 카메라 디바이스를 확인할 수 있다.--listformats-ext 옵션은 디바이스의 지원 해상도를 확인 할 수 있다.특정 디바이스의 정보만을 확인하기 위해서는 -d 옵션으로 디바이스를 지정해준다.v4l2-ctl -d /dev/video0 --list-formats외에도 치즈와 guvc 등 다른 카메라 연동 프로그램들이 있다고는 하는데개인적으로는 v4l2에 익숙해지는 것이 가장 편한 것 같다.sudo apt install cheesesudo apt install guvcview참고 Lubos Rendek 님의 포스팅How to test webcam on Ubuntu 20.04 Focal Fossa Dave Jansen 님의 포스팅Using a Logitech StreamCam on Linux 미니멀공대생 님의 포스팅ROS:: usb캠 사용하기, fps 향상 (usb_cam, logitech c920) Wonjae Cho 님의 포스팅[참고] ROS kinetic에서 WebCam 사용하기 (Ubuntu 16.04) " }, { "title": "[Error] Ubuntu, Failed to idle channel 2", "url": "/posts/nouveau/", "categories": "Etc, Errors", "tags": "ubuntu, nouveau, idle", "date": "2022-05-27 00:00:00 +0900", "snippet": "해결 방법Nouveau 비활성화sudo vim /etc/modprobe.d/blacklist.confblacklist nouveauoptions nouveau modeset=0sudo update-initramfs -u이후 재부팅확인lsmod |grep nouveau에서 아무것도 나오지 않으면 비활성화가 된 것.이후 CUDA 설치 또는 호환 드라이버 설치ubuntu-drivers devicessudo ubuntu-drivers autoinstallsudo apt install nvidia-&lt;driver number&gt;참고 reddit 포스팅Failed to idle channel 2 TheMailArchive 포스팅systemd-login failed to idle channel 2 - kernel panic LeeJaeWon 님의 포스팅Ubuntu 20.04 LTS에서 Nouveau 비활성화 및 CUDA 설치하기 CONORY 님의 포스팅kernel panic not syncing vfs unable to mount root fs on unknown block 0 0 " }, { "title": "[Error] apt-get error / Hash sum mismatch error", "url": "/posts/apt-get-error/", "categories": "Etc, Errors", "tags": "ubuntu, apt-get", "date": "2022-05-26 00:00:00 +0900", "snippet": "오류 메세지오랜만에 우분투로 부팅하고 apt 설치 및 업그레이드를 하려는데아래와 비슷한 메세지로 Hash Sum mismatch 를 포함하는 에러가 발생하였다.root@Desktop:/mnt/c/Users$ sudo apt --fix-missing updateHit:1 http://security.ubuntu.com/ubuntu bionic-security InReleaseHit:2 http://kr.archive.ubuntu.com/ubuntu bionic InReleaseHit:4 http://kr.archive.ubuntu.com/ubuntu bionic-backports InReleaseGet:3 http://kr.archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]Get:5 http://kr.archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [1034 kB]Get:6 http://kr.archive.ubuntu.com/ubuntu bionic-updates/main Translation-en [347 kB]Get:7 http://kr.archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [84.7 kB]Get:8 http://kr.archive.ubuntu.com/ubuntu bionic-updates/restricted Translation-en [18.7 kB]Get:9 http://kr.archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [1097 kB]Err:9 http://kr.archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages Hash Sum mismatch Hashes of expected file: - Filesize:1097184 [weak] - SHA256:46824ffcb2d3fcdjfhbje3eb417e3f25b49e8929644621c1d64djnwiorewfe31bc - SHA1:dc07575d9d383bfdefgnji239819755e5ef44f [weak] - MD5Sum:3f0a5f1e283914818aaa044ceb3d [weak] Hashes of received file: - SHA256:614d04fa59f6f2541e8ddcc320baa8eajfsklf978dc3283911f0cca3516a98e7 - SHA1:23bhkgcca9d2f334dsjfnjke7285ecdfd11b1c74 [weak] - MD5Sum:23nj4k3fjkower3a97509ac5c1720cc2 [weak] - Filesize:1097184 [weak] Last modification reported: Sun, 16 Aug 2020 00:53:49 +0000 Release file created at: Mon, 17 Aug 2020 06:50:31 +0000Get:10 http://kr.archive.ubuntu.com/ubuntu bionic-updates/universe Translation-en [342 kB]Get:11 http://kr.archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [19.2 kB]Get:12 http://kr.archive.ubuntu.com/ubuntu bionic-updates/multiverse Translation-en [6712 B]Fetched 1186 kB in 4s (337 kB/s)Reading package lists... DoneE: Failed to fetch http://kr.archive.ubuntu.com/ubuntu/dists/bionic-updates/universe/binary-amd64/by-hash/SHA256/46824ffcb2d3fcdjfhbje3eb417e3f25b49e8929644621c1d64djnwiorewfe31bc Hash Sum mismatch Hashes of expected file: - Filesize:1097184 [weak] - SHA256:46824ffcb2d3fcdjfhbje3eb417e3f25b49e8929644621c1d64djnwiorewfe31bc - SHA1:dc07575d9d383bfdefgnji239819755e5ef44f [weak] - MD5Sum:3f0a5f1e283914818aaa044ceb3d [weak] Hashes of received file: - SHA256:614d04fa59f6f2541e8ddcc320baa8eajfsklf978dc3283911f0cca3516a98e7 - SHA1:23bhkgcca9d2f334dsjfnjke7285ecdfd11b1c74 [weak] - MD5Sum:23nj4k3fjkower3a97509ac5c1720cc2 [weak] - Filesize:1097184 [weak] Last modification reported: Sun, 16 Aug 2020 00:53:49 +0000 Release file created at: Mon, 17 Aug 2020 06:50:31 +0000E: Some index files failed to download. They have been ignored, or old ones used instead.원인기존의 apt repository의 주소가 지원을 멈췄을 확률이 높다.본인은 검색을 통해 daumkakao 에서 지원하는 주소로 변경하였다.해결 방법sudo vi /etc/apt/sources.listvi나 vim 에디터를 활용해서 기존의 주소들을 바꿔준다.:%s/kr.archive.ubuntu.com/ftp.daumkakao.comgedit이나 다른 에디터를 활용해도 좋다.참고 melonicedlatte 님의 포스팅[Error solve] apt-get update Hash sum mismatch error Jade 님의 포스팅[Ubuntu] apt update [Some index files …] 오류 해결방법 " }, { "title": "[Algorithm] 코딩테스트 알고리즘 09 - 탐색", "url": "/posts/09-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-05-19 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 순차탐색 이진탐색1. 순차탐색순차 탐색 (Sequential Search)란 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법이다.보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다.최악의 경우 시간 복잡도는 O(N)이다.# 순차 탐색 소스코드 구현def sequential_search(n, target, array): # 각 원소를 하나씩 확인하며 for i in range(n): # 현재의 원소가 찾고자 하는 원소와 동일한 경우 if array[i] == target: return i + 1 # 현재의 위치 반환 (인덱스는 0부터이므로 +1) print(\"생성할 원소 개수를 입력한 다음 한 칸 띄고 찾을 문자열을 입력하세요.\")input_data = input().split()n = int(input_data[0]) # 원소의 개수target = input_data[1] # 찾고자 하는 문자열print(\"앞서 적은 원소 개수만큼 문자열을 입력하세요. 구분은 띄어쓰기 한 칸으로 합니다.\")array = input().split()# 순차 탐색 수행 결과 출력print(sequential_search(n,target,array))2. 이진탐색이진 탐색 (Binary Search)은 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘이다.찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 게 이진 탐색 과정이다.시간복잡도는 O(logN)이다.# 이진탐색 소스코드 구현 (재귀 함수)def binary_search(array, target, start, end): if start &gt; end: return None mid = (start + end) // 2 # 찾은 경우 중간점 인덱스 반환 if array[mid] == target: return mid # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인 elif array[mid] &gt; target: return binary_search(array, target, start, mid-1) # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인 else: return binary_search(array, target, mid+1, end) # n(원소의 개수)과 target(찾고자 하는 문자열)을 입력받기n, target = list(map(int,input().split()))# 전체 원소 입력받기array = list(map(int,input().split()))# 이진 탐색 수행 결과 출력result = binary_search(array, target, 0, n-1)if result == None: print(\"원소가 존재하지 않습니다.\")else: print(result + 1)3. 트리 자료구조이진 탐색은 전제 조건이 데이터 정렬이다.데이터베이스는 내부적으로 대용량 데이터 처리에 적합한 트리 자료구조를 이용하여 항상 데이터가 정렬되어 있다.따라서 데이터베이스에서의 탐색은 이진 탐색과는 조금 다르지만, 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있어서 데이터가 많아도 탐색하는 속도가 빠르다.이진 탐색 트리에 데이터를 넣고 빼는 방법은 알고리즘보다는 자료구조에 가까우며, 이진 탐색 트리 자료구조를 구현하도록 요구하는 문제는 출제 빈도가 낮다.4. 실전 문제 1부품 찾기N개의 부품이 있고 각 정수 형태의 고유 번호가 있다. 손님이 M개 종류의 부품을 대량 구매하기 위해 견적서를 요청했다. 문의 부품 M개 종류를 모두 확인해서 있는지 확인한다. 첫째 줄에 정수 N이 주어진다. (1&lt;=N&lt;=1,000,000) 둘째 줄에는 공백으로 구분하여 N개의 정수가 주어진다. 정수는 1 초과 1,000,000 이하이다. 셋째 줄에는 정수 M이 주어진다. (1&lt;=M&lt;=100,000) 넷째 줄에는 공백으로 구분하여 M개의 정수가 주어진다. 정수는 1초과 1,000,000 이하이다. 첫째 줄에 공백으로 구분하여 각 부품이 존재하면 yes, 없으면 no를 출력한다.이진 탐색 풀이부품을 찾는 과정에서 O(MxlogN)이, 정렬에 O(NxlogN)이 필요하여, 결과적으로 이진 탐색으로 풀이할 경우 시간 복잡도는 O((M+N) x logN)이다.# 이진 탐색 소스코드 구현(반복문)def binary_search(array, target, start, end): while start &lt;= end: mid = (start+end)//2 # 찾은 경우 중간점 인덱스 반환 if array[mid] == target: return mid # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인 elif array[mid] &gt; target: end = mid - 1 # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인 else: start = mid + 1 return None# N(가게의 부품 개수) 입력n = int(input())# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력array = list(map(int,input().split()))array.sort() # 이진 탐색 수행 위해 정렬 수행# M(손님이 확인 요청한 부품 개수) 입력m = int(input())# 손님이 확인 요청한 전체 부품 번호를 공백으로 구분하여 입력x = list(map(int,input().split()))# 손님이 확인 요청한 부품 번호를 하나씩 확인for i in x: # 해당 부품이 존재하는지 확인 result = binary_search(array, i, 0, n-1) if result != None: print('yes',end=' ') else: print('no',end=' ')계수 정렬 풀이모든 원소의 번호를 포함할 수 있는 크기의 리스트를 만든 뒤에, 리스트의 인덱스에 직접 접근하여 특정한 번호의 부품이 매장에 존재하는지 확인.# N(가게의 부품 개수)을 입력받기n = int(input())array = [0] * 1000001# 가게에 있는 전체 부품 번호를 입력받아서 기록for i in input().split(): array[int(i)] = 1# M(손님이 확인 요청한 부품 개수)을 입력받기m = int(input())# 손님이 확인 요청한 전체 부품 번호를 공백으로 구분하여 입력x = list(map(int,input().split()))# 손님이 확인 요청한 부품 번호를 하나씩 확인for i in x: # 해당 부품이 존재하는지 확인 if array[i] == 1: print('yes',end=' ') else: print('no',end=' ')집합 자료형 풀이해당 문제는 단순히 특정 수가 한번이라도 등장했는지만 검사하면 되므로 집합 자료형을 이용해도 된다.set() 함수는 집합 자료형을 초기화할 때 사용한다. 단순히 특정한 데이터가 존재하는지 검사할 때에 매우 효과적으로 사용한다.# N(가게의 부품 개수)을 입력받기n = int(input())# 가게에 있는 전체 부품 번호를 입력받아서 집합(set) 자료형에 기록array = set(map(int,input().split()))# M(손님이 확인 요청한 부품 개수)을 입력받기m = int(input())# 손님이 확인 요청한 전체 부품 번호를 공백으로 구분하여 입력x = list(map(int,input().split()))# 손님이 확인 요청한 부품 번호를 하나씩 확인for i in x: # 해당 부품이 존재하는지 확인 if i in array: print('yes',end=' ') else: print('no',end=' ')참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Algorithm] 코딩테스트 알고리즘 08 - 정렬", "url": "/posts/08-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-05-19 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 서론 코딩 테스트에서 정렬 알고리즘이 사용되는 경우의 3가지 유형 실전 문제 1 위에서 아래로 실전 문제 2 성적이 낮은 순서로 학생 출력하기 실전 문제 3 두 배열의 원소 교체 1. 서론코딩테스트 공부를 진행하면서 효율성 검사에서 자주 실패를 겪으며 시간복잡도에 대해 생각을 많이 하게 되었다.그 중에서도 가장 적용이 많이 되는 부분이 정렬 파트라고 생각한다. 선택 정렬의 시간 복잡도는 O(N^2) 삽입 정렬의 시간 복잡도는 O(N^2) 단, 거의 정렬이 되어있는 상태 (최선의 경우) O(N)의 시간 복잡도를 가진다. 특정 상황에서는 타 알고리즘보다 유리하다. 퀵 정렬의 시간 복잡도는 O(NlogN) 단, 최악의 경우 O(N^2)으로, 이미 데이터가 정렬되어 있는 경우에는 삽입 정렬을 사용하자. 계수 정렬의 시간 복잡도는 O(N+K) 위의 세 정렬 알고리즘 (비교기반)과는 다르게 별도의 리스트를 선언하고 새로 정보를 담는다. 위의 내용들을 바탕으로 코딩테스트를 위해서 무엇을 위주로 공부하는게 좋을지를 자주 고민 중이다.파이썬의 기본 정렬 라이브러의 sorted() 함수의 시간 복잡도는 O(NlogN)을 보장한다고 한다.코딩 테스트에서 정렬 알고리즘이 사용되는 경우의 3가지 유형 정렬 라이브러리로 풀 수 있는 문제 단순히 정렬 기법을 알고 있는지 정렬 알고리즘의 원리에 대해서 물어보는 문제 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 더 빠른 정렬이 필요한 문제 계수 정렬 등의 다른 정렬 알고리즘을 이용,, 등 2. 실전 문제 1파이썬 기본 정렬 라이브러리 이용 문제위에서 아래로수열을 내림차순으로 정렬하는 프로그램을 만드시오. 첫째 줄에 수열에 속해 있는 수의 개수 N이 주어진다. (1 &lt;= N &lt;= 500) 둘째 줄부터 N+1 번째 줄까지 N개의 수가 입력된다. 1 ~ 10만 이하의 자연수. 입력으로 주어진 수열이 내림차순으로 정렬된 결과를 공백으로 구분하여 출력.# N을 입력받기n = int(input())# N개의 정수를 입력받아 리스트에 저장array = []for i in range(n): array.append(int(input()))# 파이썬 기본 정렬 라이브러리를 이용하여 정렬 수행array = sorted(array, reverse=True)# 정렬이 수행된 결과를 출력for i in array: print(i, end = ' ')3. 실전 문제 2계수 정렬 이용 문제 + 튜플 정렬성적이 낮은 순서로 학생 출력하기각 학생의 이름과 성적 정보가 주어졌을 때 성적이 낮은 순서대로 학생의 이름을 출력. 첫째 줄에 학생의 수 N이 입력 (1 &lt;= N &lt;= 100000) 둘째 줄부터 N+1 줄에는 학생의 이름을 나타내는 문자열 A와 학생성적 B가 공백으로.# N을 입력받기n = int(input())# N명의 학생 정보를 입력받아 리스트에 저장array = []for i in range(n): input_data = input().split() # 이름은 무자열 그대로, 점수는 정수형으로 변환하여 저장 array.append(input_data[0], int(input_data[1]))# 키(Key)를 이용하여, 점수를 기준으로 정렬array = sorted(array, key=lambda student: student[1])# 정렬이 수행된 결과를 출력for student in array: print(student[0], end=' ')4. 실전 문제 3O(NlogN)을 보장하는 정렬 알고리즘을 사용두 배열의 원소 교체두 개의 배열 A와 B는 N개의 자연수 원소로 구성되어 있다.최대 K번의 바꿔치기 연산을 수행할 수 있다. 서로의 배열에서 원소 하나씩을 골라서 바꾸는 것이다.최종 목표는 배열 A의 모든 원소 합이 최대가 되도록 하는 것이다. 첫째 줄에 N, K가 공백으로 구분되어 입력. (1 &lt;= N &lt;= 100000, 0 &lt;= K &lt;= N) 둘째, 셋째 줄에 A와 B의 원소들이 공백으로 구분되어 입력. 천만 이하의 자연수. 최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력.n, k = map(int, input().split()) # N과 K를 입력받기a = list(map(int, input().split())) # 배열 A의 모든 원소를 입력받기b = list(map(int, input().split())) # 배열 B의 모든 원소를 입력받기a.sort() # 배열 A는 오름차순 정렬 수행b.sort(reverse=True) # 배열 B는 내림차순 정렬 수행# 첫번째 인덱스부터 확인하며, 두배열의 원소를 최대 K번 비교for i in range(k): # A의 원소가 B의 원소보다 작은 경우 if a[i] &lt; b[i]: # 두 원소를 교체 a[i], b[i] = b[i], a[i] else: # A의 원소가 B의 원소보다 크거나 같을 때, 반복문을 탈출 breakprint(sum(a)) # 배열 A의 모든 원소의 합을 출력참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Algorithm] 코딩테스트 알고리즘 07 - DFS/BFS", "url": "/posts/07-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-05-10 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 탐색 주요 개념 스택 큐 재귀함수 DFS BFS 실전 문제 1 음료수 얼려 먹기 실전 문제 2 미로 찾기 1. 탐색탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정이다.프로그래밍에서는 그래프, 트리 등의 자료구조 안에서 탐색하는 문제를 자주 다룬다.대표적인 탐색 알고리즘으로 DFS와 BFS를 꼽을 수 있다.이를 제대로 사용하려면 기본 자료구조 스택, 큐와 재귀 함수에 대한 이해가 전제되어야한다.2. 주요 개념자료구조란 ‘데이터를 표현하고 관리하고 처리하기 위한 구조’를 의미한다. 삽입 (Push) : 데이터를 삽입한다. 삭제 (Pop) : 데이터를 삭제한다. 오버플로 (Overflow) : 자료구조가 수용할 수 있는 데이터 크기가 가득 찬 상태에서 삽입 연산 언더플로 (Underflow) : 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산스택가장 최근에 들어간 데이터가 가장 먼저 나오는 선입후출 (First In Last Out) 또는 후입선출 (Last In First Out) 구조.보통 deque 내장 모듈을 활용한다.큐가장 먼저 들어간 데이터가 가장 먼저 나오는 선입선출 (First In First Out) 구조.역시 통상적으로 deque 내장 모듈로 사용한다.from collections import dequedq = deque() # 덱 생성dq.append() # 덱의 가장 오른쪽에 원소 삽입dq.popleft() # 가장 왼쪽 원소 반환dq.appendleft() # 가장 왼쪽에 원소 삽입dq.pop() # 가장 오른쪽 원소 반환dq.clear() # 모든 원소 제거dq.copy() # 덱 복사dq.count(x) # x와 같은 원소의 개수 반환dq.reverse() # 원소를 역순으로dq.rotate(n) # n 만큼 우측으로 회전시킨다. 음수일경우 왼쪽으로 회전.리스트 자료형으로 변경하고자 한다면 list() 사용.재귀함수재귀함수 Recursive Functino은 자기 자신을 다시 호출하는 함수이다.보통 파이썬 인프리터는 호출 횟수 제한이 있어 재귀의 최대 깊이를 초과하면 오류가 발생한다.RecursionError: maximum recursion depth exceeded while pickling an object재귀 함수를 사용할 때는 종료 조건을 꼭 명시해야한다. if문을 활용.컴퓨터의 구조 측면에서 재귀 함수는 스택 자료구조와 같다.따라서 스택을 사용하는 알고리즘 상당수는 재귀함수로 간편하게 구현될 수 있다.재귀 함수는 재귀식을 소스코드로 옮기며 간결함의 이점이 있고, 다이나믹 프로그래밍으로도 연결된다.3. DFSDFS는 Depth-First Search, 깊이 우선 탐색이라 하며 그래프에서 깊은 부분을 우선 탐색하는 알고리즘이다.스택 자료구조에 기초한다. 탐색 시작 노드를 스택에 삽입하고 방문 처리. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리.없으면 스택에서 최상단 노드를 꺼낸다. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복.그래프노드(Node), 간선(Edge)으로 표현되고 노드를 정점(Vertex)이라고도 한다.그래프 탐색은 하나의 노드를 시작으로 다수의 노드를 방문하는 것이다.두 노드가 간선으로 연결되어 있으면 ‘두 노드는 인접(Adjacent)한다’라고 표현한다.코딩 테스트에서는 크게 다음의 두가지 방식으로 표현한다. 인접 행렬 : 2차원 배열로 그래프 연결 관계를 표현하는 방식 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식 메모리 측면에서 인접 행렬은 메모리가 불필요하게 낭비 인접 리스트는 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림DFS 구현 예제# DFS 메서드 정의def dfs(graph, v, visited): # 현재 노드를 방문 처리 visited[v] = True print(v, end=' ') # 현재 노드와 연결된 다른 노드를 재귀적으로 방문 for i in graph[v]: if not visited[i]: dfs(graph, i, visited)# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)graph =[[],[2,3,8],[1,7],[1,4,5],[3,5],[3,4],[7],[2,6,8],[1,7]]# 각 노드가 방문된 정보를 리스트 자료형으로 표현 (1차원 리스트)visited = [False] * 9# 정의된 DFS 함수 호출dfs(graph, 1, visited)4. BFSBFS는 Breath First Search, 너비 우선 탐색이라 하며, 가까운 노드부터 탐색하는 알고리즘이다.선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.시간 복잡도는 O(N), 일반적으로 실제 수행시간이 DFS보다 좋은 편이다. 재귀 함수로 DFS를 구현하면 시스템 동작 특성상 실제 프로그램 수행 시간이 느려질 수 있다고 한다. 스택 라이브러리를 활용해 시간 복잡도를 완화하는 테크닉 필요. 코테에서는 BS로 하자.BFS 구현 예제from collections import deque# BFS 메서드 정의def bfs(graph, start, visited): # 큐(Queue) 구현을 위해 deque 라이브러리 사용 queue = deque([start]) # 현재 노드를 방문 처리 visited[start] = True # 큐가 빌 때까지 반복 while queue: # 큐에서 하나의 원소를 뽑아 출력 v = queue.popleft() print(v, end = ' ') # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입 for i in graph[v]: if not visited[i]: queue.append(i) visited[i] = True# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)graph = [[],[2,3,8],[1,7],[1,4,5],[3,5],[3,4],[7],[2,6,8],[1,7]]# 각 노드가 방문된 정보를 리스트 자료형으로 표현 (1차원 리스트)visited = [False] * 9# 정의된 BFS 함수 호출bfs(graph, 1, visited)5. 실전 문제 1음료수 얼려 먹기N x M 크기의 얼음틀에 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시.구멍이 뚫려 있는 부분끼리 상하좌우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다.얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 첫째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. (1 &lt;= N, M &lt;= 1000) 둘째 줄부터 N+1 줄까지 얼음 틀의 형태가 주어진다. 뚫려있는 부분은 0, 막힌 부분은 1이다. 한번에 만들 수 있는 아이스크림의 개수를 출력한다. 0으로 연결된 그룹 수를 세라는 것 같다.DFS로 해결한다. 특정한 지점의 주변 상하좌우를 살펴본 뒤에 주변 지점 중에서 값이 0이면서 아직 방문하지 않은 지점이 있다면 해당 지점 방문. 방문 지점에서 다시 상하좌우를 살펴보며 반복하면 연결된 모든 지점을 방문할 수 있다. 위의 두 과정을 모든 노드에 반복하며 방문하지 않은 지점의 수를 센다.# N, M을 공백으로 구분하여 입력받기n, m = map(int, input().split())# 2차원 리스트의 맵 정보 입력받기graph = []for i in range(n): graph.append(list(map(int, input())))# DFS로 특정한 노드를 방문한 뒤에 연결된 모든 노드들도 방문def dfs(x,y): # 주어진 범위를 벗어나는 경우에는 즉시 종료 if x &lt;= -1 or x &gt;= n or y &lt;= -1 or y &gt;= m: return False # 현재 노드를 아직 방문하지 않았다면 if graph[x][y] == 0: # 해당 노드 방문 처리 graph[x][y] = 1 # 상하좌우의 위치도 모두 재귀적으로 호출 dfs(x-1, y) dfs(x, y-1) dfs(x+1, y) dfx(x, y+1) return True return False# 모든 노드(위치)에 대하여 음료수 채우기result = 0for i in ragne(n): for j in range(m): # 현재 위치에서 DFS 수행 if dfs(i, j) == True: result += 1print(result) # 정답 출력 너무 어렵다….6. 실전 문제 2미로 탈출N x M 크기의 직사각형 형태의 미로에 갇혀 있다.(1,1)에서 출구 (N,M) 까지 한번에 한칸씩 이동할 수 있다.괴물이 있는 곳은 0, 없는 곳은 1로 표시 되어있다. 움직여야 하는 최소 칸의 개수를 구하시오.칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산합니다. 첫째 줄에 두 정수 N, M (4 &lt;= n, M &lt;= 200). 다음 N 개 줄에는 각각 M개의 정수로 미로의 정보.BFS를 이용해서 해결한다.시작 지점부터 가까운 노드를 차례대로 탐색하기에 BFS 수행한 모든 노드의 값을 거리 정보로 넣는다.특정 노드 방문 하면 그 이전 노드의 거리에 1을 더한 값을 리스트에 넣는다.단순히 우측하단으로 이동하는 것만을 요구하기 때문에 시작 위치의 재방문을 고려하지 않아도 된다.from collections import deque# N, M을 공백으로 구분하여 입력받기n, m = map(int, input().split())# 2차원 리스트의 맵 정보 입력받기graph = []for i in range(n): graph.append(list(map(int, input())))# 이동할 방향 정의 (상하좌우)dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]# BFS 소스코드 구현def bfs(x,y): # 큐(Queue) 구현을 위해 deque 라이브러리 사용 queue = deque() queue.append((x,y)) # 큐가 빌 때까지 반복 while queue: x, y = queue.popleft() # 현재 위치에서 네 방향으로의 위치 확인 for i in range(4): nx = x + dx[i] ny = y + dy[i] # 미로 찾기 공간을 벗어난 경우 무시 if nx &lt; 0 or ny &lt; 0 or nx &gt;= n or ny &gt;= m: continue # 벽인 경우 무시 if graph[nx][ny] == 0: continue # 해당 노드를 처음 방문하는 경우에만 최단 거리 기록 if graph[nx][ny] == 1: graph[nx][ny] = graph[x][y] + 1 queue.append((nx,ny)) # 가장 오른쪽 아래까지의 최단 거리 반환 return graph[n-1][m-1]# BFS를 수행한 결과 출력print(bfs(0,0))참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Algorithm] 코딩테스트 알고리즘 06 - 구현", "url": "/posts/06-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-03-20 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 구현 유형 예제 1 예제 2 실전 문제 1 왕실의 나이트 실전 문제 2 게임 개발 1. 구현 유형코딩 테스트에서 구현 (Implementation)은 머릿 속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.보통 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 의미한다.현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다. 표준 라이브러리를 활용해 쉽게 짜는 방법도 있지만, 프로그래밍 언어의 문법을 정확히 알고 있어야 하며 문제의 요구사항에 어긋나지 않는 답안 코드를 실수 없이 작성해야 한다. 보통 구현 유형의 문제는 사소한 입력 조건 등을 문제에서 명시해주며 문제의 길이가 꽤 긴 편이다. 시뮬레이션 유형, 구현 유형, 완전 탐색 유형은 서로 유사한 점이 많다.2. 예제 1시뮬레이션 유형여행가 A는 N x N 크기의 정사각형 공간 위에 서 있다.이 공간은 1 X 1 크기의 정사각형으로 나누어져 있다.가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N,N)에 해당한다.여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1,1)이다. L : 왼쪽으로 한 칸 이동 R : 오른쪽으로 한 칸 이동 U : 위로 한 칸 이동 D : 아래로 한 칸 이동A가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다.계획서가 주어졌을 때 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하시오. 첫째 줄에 공간의 크기를 나타내는 N이 주어진다. (1 &lt;= N &lt;= 100) 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다. (1 &lt;= 이동 횟수 &lt;= 100) 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백으로 구분하여 출력한다.n = int(input()) # 5 입력x, y = 1, 1plans = input().split() # R R R U D D 입력# L, R, U, D에 따른 이동 방향dx = [0, 0, -1, 1]dy = [-1, 1, 0, 0]move_types = ['L', 'R', 'U', 'D']# 이동 계획을 하나씩 확인for plan in plans:\t# 이동 후 좌표 구하기\tfor i in range(len(move_types)):\t\tif plan == move_types[i]:\t\t\tnx = x + dx[i]\t\t\tny = y + dy[i]\t# 공간을 벗어나는 경우 무시\tif nx &lt; 1 or ny &lt; 1 or nx &gt; n or ny &gt; n:\t\tcontinue\t# 이동 수행\tx, y = nx, nyprint(x, y)3. 예제 2완전 탐색 유형정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오. 첫째 줄에 정수 N이 입력된다. (0 &lt;= N &lt;= 23) 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다.h = int(input())count = 0for i in range(h+1):\tfor j in range(60):\t\tfor k in range(60):\t\t\t# 매 시각 안에 '3'이 포함되어 있다면 카운트 증가\t\t\tif '3' in str(i) + str(j) + str(k):\t\t\t\tcount += 1print(count)4. 실전 문제 1왕실의 나이트행복 왕국의 왕실 정원은 체스판과 같은 8 x 8 좌표 평면이다.왕실 정원의 특정한 한 칸에 나이트가 서 있다. 나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며, 정원 밖으로는 나갈 수 없다. 나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기 행 위치를 표현할 때는 1부터 8, 열은 a부터 h로 표현한다. 첫째 줄에 8 x 8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. 입력 문자는 a1처럼 열과 행으로 이뤄진다. 나이트가 이동할 수 있는 경우의 수를 출력하시오.# 현재 나이트의 위치 입력받기input_data = input()row = int(input_data[1])column = int(ord(input_data[0])) - int(ord('a')) + 1# 나이트가 이동할 수 있는 8가지 방향 정의steps = [\t(-2,-1), (-1,-2), (1,-2), (2,-1),\t(2,1), (1,2), (-1,2), (-2,1)]# 8가지 방향에 대하여 각 위치로 이동이 가능한지 확인result = 0for step in steps:\t# 이동하고자 하는 위치 확인\tnext_row = row + step[0]\tnext_column = column + step[1]\t# 해당 위치로 이동이 가능하다면 카운트 증가\tif next_row &gt;= 1 and next_row &lt;= 8 and next_column &gt;=1 and next_column &lt;= 8:\t\tresult += 1print(result)예제 1에서는 리스트를 선언하여 이동할 방향을 기록할 수 있도록 했다.실전 문제 1에서는 steps 변수가 동일 기능을 대신하여 수행한다. 두가지 모두 자주 사용된다.5. 실전 문제 2시뮬레이션 유형일반적으로 방향을 설정해서 이동하는 문제 유형에서는 dx, dy 라는 별도의 리스트를 만들어 방향을 정하는 것이 효과적이다.게임 개발게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다.캐릭터가 있는 장소는 1 x 1 크기의 정사각형으로 이뤄진 N x M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다. 캐릭터는 동서남북 중 한곳을 바라본다.맵의 각 칸은 (A,B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 캐릭터는 상하좌우로 움직일 수 있고, 바다는 못 간다. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향 (반시계 90도 회전 방향)부터 차례대로 갈 곳을 정한다. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다. 없다면 회전만 수행하고 1단계로 돌아간다. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 뒤가 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다. 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오. 첫째 줄에 맵의 세로 크기 N과 가로 크기 M을 공백으로 구분하여 입력한다. (N &gt;= 3, M &lt;= 50) 둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (A,B)와 바라보는 방향 d가 각각 서로 공백으로 구분 입력.0 북쪽 / 1 동쪽 / 2 남쪽 / 3 서쪽 셋째 줄부터 맵이 육지인지 바다인지 입력한다. N개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로, 각 줄의 데이터는 서쪽부터 동쪽 순서대로 주어진다. 맵의 외곽은 항상 바다로 되어있다. 0 육지 / 1 바다 처음에 게임 캐릭터가 위치한 칸의 상태는 항상 육지이다.# N, M을 공백으로 구분하여 입력받기n, m = map(int, input().split())# 방문한 위치를 저장하기 위한 맵을 생성하여 0으로 초기화d = [[0] * m for _ in range(n)]# 현재 캐릭터의 X 좌표, Y 좌표, 방향을 입력받기x, y, direction = map(int,input().split())d[x][y] = 1 # 현재 좌표 방문 처리# 전체 맵 정보를 입력받기array = []for i in range(n):\tarray.append(list(map(int, input().split())))# 북, 동, 남, 서 방향 정의dx = [-1, 0, 1, 0]dy = [0, 1, 0, -1]# 왼쪽으로 회전def turn_left():\tglobal direction\tdirection -= 1\tif direction == -1:\t\tdirection = 3# 시뮬레이션 시작count = 1turn_time = 0while True:\t# 왼쪽으로 회전\tturn_left()\tnx = x + dx[direction]\tny = y + dy[direction]\t# 회전한 이후 정면에 가보지 않은 칸이 존재하는 경우 이동\tif d[nx][ny] == 0 and array[nx][ny] == 0:\t\td[nx][ny] = 1\t\tx = nx\t\ty = ny\t\tcount += 1\t\tturn_time = 0\t\tcontinue\t# 회전한 이후 정면에 가보지 않은 칸이 없거나 바다인 경우\telse:\t\tturn_time += 1\t# 네 방향 모두 갈 수 없는 경우\tif turn_time += 1:\t\tnx = x - dx[direction]\t\tny = y - dy[direction]\t\t# 뒤로 갈 수 있다면 이동하기\t\tif array[nx][ny] == 0:\t\t\tx = nx\t\t\ty = ny\t\t# 뒤가 바다로 막혀있는 경우\t\telse:\t\t\tbreak\t\tturn_time = 0print(count)참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Algorithm] 코딩테스트 알고리즘 05 - 그리디", "url": "/posts/05-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 그리디 알고리즘 그리디 알고리즘의 정당성 예제 실전 문제 1 큰 수의 법칙 개선된 답안 예시 실전 문제 2 숫자 카드 게임 실전 문제 3 1이 될 때까지 1. 그리디 알고리즘그리디 알고리즘은 이름 그대로 탐욕적으로 문제를 푸는 알고리즘이다.현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다. 코딩 테스트에서 그리디 유형 문제는 사전 지식 없이도 풀 수 있지만, 그만큼 많은 유형을 접해봐야한다. 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다. 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 ‘가장 큰 순서대로’, ‘가장 작은 순서대로’와 같은 기준을 제시한다. 그래서 정렬 알고리즘과 짝을 이뤄 출제된다.2. 그리디 알고리즘의 정당성대부분의 문제는 그리디 알고리즘을 이용했을 때 ‘최적의 해’를 찾을 수 없을 가능성이 다분하다.하지만 탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.그리디 알고리즘으로 문제의 해법을 찾을 때는 해법이 정당한지 검토해야 한다.대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고, 정당한지 검토할 수 있어야한다. 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심해본다. 그리디 알고리즘으로 해결 방법을 찾을 수 없다면, 다이나믹 프로그래밍이나 그래프 알고리즘을 고민해본다.3. 예제거스름돈 문제는 그리디 알고리즘을 설명할 때 자주 소개되는 문제이다.음식점에서 계산을 할 때, 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원 동전이 무한히 존재한다고 가정한다.손님에게 거슬러 줘야할 돈이 N원일 때, 거슬러줘야 할 동전의 최소 개수를 구하라.단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.# n 입력n = 1260# 큰 단위의 화폐부터 차례대로 확인list = [500, 100, 50, 10]for coin in list:\tcount += n // coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기\tn %= coinprint(count)4. 실전 문제 1큰 수의 법칙 2019 국가 교육기관 코딩 테스트 기출문제‘큰 수의 법칙’은 일반적으로 통계 분야에서 다루어지는 내용이지만 이 문제에서는 다르게 사용한다.다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 특징이다. 첫째 줄에 N(2 &lt;= N &lt;= 1000), M(1 &lt;= M &lt;= 10000), K(1 &lt;= K &lt;= 10000)의 자연수가 주어지며 각 자연수는 공백으로 구분. 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분. 각각의 자연수는 1 이상 10000 이하의 수. 입력으로 주어지는 K는 항상 M보다 작거나 같다.# N, M, K를 공백으로 구분하여 입력받기n, m, k = map(int(input().split()))# N개의 수를 공백으로 구분하여 입력받기data = list(map(int,input().split()))data.sort() # 입력받은 수들 정렬하기first = data[n-1] # 가장 큰 수second = data[n-2] # 두 번째로 큰 수result = 0while True:\tfor i in range(k): # 가장 큰 수를 K번 더하기\t\tif m == 0: break # m이 0이라면 반복문 탈출\t\tresult += first\t\tm -= 1 # 더할 때마다 1씩 빼기\tif m == 0: break # m이 0이라면 반복문 탈출\tresult += second # 두 번째로 큰 수를 한 번 더하기\tm -= 1 # 더할 때마다 1씩 빼기print(result) #최종 답안 출력연속으로 더할 수 있는 횟수는 최대 K번이므로 다음과 같이 표현하면 된다.가장 큰 수를 K번 더하고, 두 번째로 큰 수를 한 번 더하는 연산을 반복.개선된 답안 예시# N, M, K를 공백으로 구분하여 입력받기n, m, k = map(int(input().split()))# N개의 수를 공백으로 구분하여 입력받기data = list(map(int,input().split()))data.sort() # 입력받은 수들 정렬하기first = data[n-1] # 가장 큰 수second = data[n-2] # 두 번째로 큰 수# 가장 큰 수가 더해지는 횟수 계산count = int(m / (k+1)) * kcount += m % (k + 1)result = 0result += (count) * first # 가장 큰 수 더하기result += (m - count) * second # 두 번째로 큰 수 더하기print(result)수열을 활용하여 가장 큰 수가 더해지는 횟수를 이용한 풀이이다.[가장 큰 수 * k 번, 두 번째로 큰 수 한번]이라는 수열이 반복되는 구조이기에 이 반복 되는 수를 계산한다.(가장 큰 수 * k * count)와 (두 번째로 큰 수 * count)를 더하면 정답이된다.5. 실전 문제 2숫자 카드 게임 2019 국가 교육기관 코딩 테스트 기출문제숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 숫자 카드들이 N x M 형태로 놓여있다. N은 행, M은 열의 개수다. 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑는다. 각 행에 대하여, 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세운다. 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 각각 자연수로 주어진다. (1 &lt;= N,M &lt;= 100) 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10000 이하의 자연수이다.다음은 min() 함수를 이용하여 풀이한 소스이다.# N, M을 공백으로 구분하여 입력받기n, m = map(int, input().split())result = 0# 한 줄씩 입력받아 확인for i in range(n):\tdata = list(map(int, input().split()))\t# 현재 줄에서 가장 작은 수 찾기\tmin_value = min(data)\t# 가장 작은 수들 중에서 가장 큰 수 찾기\tresult = max(result, min_value)print(result)다음은 2중 반복문을 이용한 풀이다.# N, M을 공백으로 구분하여 입력받기n, m = map(int, input().split())result = 0# 한 줄씩 입력받아 확인for i in range(n):\tdata = list(map(int, input().split()))\t# 현재 줄에서 가장 작은 수 찾기\tmin_value = 10001\tfor a in data:\t\tmin_value = min(min_value, a)\t# 가장 작은 수들 중에서 가장 큰 수 찾기\tresult = max(result, min_value)print(result)data에 입력받는 수는 최대 10000이기에 min_value를 10001로 초기화했다.6. 실전 문제 31이 될 때까지 2018 E 기업 알고리즘 대회어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복 수행한다.단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다. N에서 1을 뺀다. N을 K로 나눈다.N과 K가 주어질 때 1이 될 때까지 과정을 수행하는 최소 횟수를 구하는 프로그램을 작성하시오. 첫째 줄에 N(2 &lt;= N &lt;= 100000)과 K(2 &lt;= K &lt;= 100000)가 공백으로 구분, 자연수로 주어진다. N은 항상 K 이상이다.n, k = map(int,input().split())result = 0# N이 K 이상이라면 K로 계속 나누기while n &gt;= k:\t# N이 K로 나누어 떨어지지 않는다면 N에서 1씩 빼기\twhile n % k != 0:\t\tn -= 1\t\tresult += 1\t# K로 나누기\tn //= k\tresult += 1# 마지막으로 남은 수에 대하여 1씩 빼기while n &gt; 1:\tn -= 1\tresult += 1print(result)위의 소스는 N의 범위가 10만 이하이므로 일일이 1씩 빼가며 문제를 해결했다.다음은 N이 K의 배수가 되도록 효율적으로 한 번에 빼는 방식으로 빠르게 동작하게 한 소스이다.# N, K를 공백으로 구분하여 입력받기n, k = map(int,input().split())result = 0while True:\t# (N == K로 나누어떨어지는 수)가 될 때까지 1씩 빼기\ttarget = (n //k) * k\tresult += (n - target)\tn = target\t# N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출\tif n &lt; k: break\t# K로 나누기\tresult += 1\tn //= k# 마지막으로 남은 수에 대하여 1씩 빼기result += (n - 1)print(result)참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Algorithm] 코딩테스트 알고리즘 04 - 소수의 판별", "url": "/posts/04-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-02-01 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 소수의 판별 에라토스테네스의 체 예제1. 소수의 판별소수는 2보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어떨어지지 않는 자연수.기본적으로 2부터 (x - 1)까지 모든 수를 확인해가며, x가 해당 수로 나누어 떨어진다면 소수가 아니다.여기에 자연수의 약수가 가지는 특징을 활용한다.해당 수의 제곱근 (가운데)를 기준으로 약수들이 대칭적인 구조를 가지기 때문에 가운데까지만 확인하면 된다.import math# 소수 판별함수def is_prime_number(x):\t# 2부터 x의 제곱근까지 모든 수를 확인하며\tfor i in range(2, int(mat.sqrt(x)) +1):\t\t# x가 해당 수로 나누어떨어진다면\t\tif x % i == 0: \t\t\treturn False # 소수가 아님\treturn True # 소수임해당 알고리즘은 하나의 수를 판별하는데에는 적합하지만, 범위 내의 모든 소수를 찾기에는 비효율적이다.2. 에라토스테네스의 체여러 개의 수가 소수인지 아닌지를 판별할 때 사용하는 대표 알고리즘이다.N 이하의 모든 소수를 찾을 때 사용할 수 있다. 다음과 같은 순서로 진행된다. 2부터 N까지의 모든 자연수를 나열한다. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다. 남은 수 중에서 i의 배수를 모두 제거한다. (i는 제거하지 않는다.) 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.import math# 2부터 1000까지의 모든 수에 대하여 소수 판별n = 1000# 처음엔 모든 수가 소수(True)인 것으로 초기화 (0과 1 제외)array = [True for i in range(n+1)] # 에라토스테네스의 체 알고리즘for i in range(2, int(math.sqrt(n)) +1): # 2부터 n의 제곱근까지 모든 수를 확인하며\tif array[i] == True: # i가 소수인 경우 (남은 수인 경우)\t\t# i를 제외한 i의 모든 배수를 지우기\t\tj = 2\t\twhile i * j &lt;= n:\t\t\tarray[i * j] = False\t\t\tj += 1# 모든 소수 출력for i in range(2, n+1):\tif array[i]:\t\tprint(i, end=' ')메모리가 많이 필요하다는 단점이 있어서 N의 크기가 커지면 비효율적이다.3. 예제M 이상 N 이하의 소수를 모두 출력하는 프로그램을 작성하시오. 첫째 줄에 자연수 M과 N이 빈칸을 사이에 두고 주어진다. (1 &lt;= M &lt;= N &lt;= 1000000) 단, M 이상 N 이하의 소수가 하나 이상 있는 입력만 주어진다. 하 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.import math# M과 N을 입력받기m,n = map(int, input().split())array = [True for i in range(1000000 +1)] # 모든 수가 소수인것으로 초기화array[1] = 0 # 1은 소수가 아님# 에라토스테네스의 체 알고리즘for i in range(2, int(math.sqrt(n)) +1): # 2부터 n 제곱근까지 모든 수 확인\tif array[i] == True: # i가 소수인 경우 (남은 수인 경우)\t\t# i를 제외한 i의 모든 배수를 제거하기\t\tj = 2\t\twhile i * j &lt;= n:\t\t\tarray[i * j] = False\t\t\tj += 1# M부터 N까지의 모든 소수 출력for i in range(m, n+1):\tif array[i]:\t\tprint(i)참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Python] 코딩테스트를 위한 파이썬 문법 03 - 주요 라이브러리의 문법과 유의점", "url": "/posts/03-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-02-01 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 내장 함수 itertools permutations combinations product combinations_with_replacement heapq bisect collections deque Counter math표준 라이브러리란 특정한 프로그래밍 언어에서 자주 사용되는 표준 소스코드를 미리 구현해 놓은 라이브러리를 의미한다.https://docs.python.org/ko/3/library/index.html코딩테스트에서 보통 6가지정도를 사용한다고 한다. 해당 포스팅은 이 중 핵심내용으로 책과 유튜브 강의 등에서 언급된 내용들이다.1. 내장 함수기본 입출력 기능부터 정렬 기능까지 포함한 내장 라이브러리. 별도의 import 명령어 없이 사용 가능하다. sum() 모든 원소 합. iterable 객체를 입력 sum([1,2,3,4,5]) min() 최소 값 min(7,3,5,2) max() 최대 값 max(7,3,5,2) eval() 문자열 형식의 수식 계산 eval(\"(3+5) * 7\") sorted() 정렬. iterable 객체를 입력. key 속성으로 정렬 기준 명시 sorted([9,1,8,5,4]) sorted(,reverse = True) reverse 속성으로 정렬 결과를 내림차순으로 변경 sorted([9,1,8,5,4],reverse=True) sorted()를 사용할 때, 리스트의 원소로 리스트나 튜플이 존재할 때 특정 기준에 따라 정렬 수행 가능하다.기준은 key 속성으로 명시 가능하다. 다음은 예시이다.# 튜플의 두번째 원소를 기준으로 내림차순 정렬하기result = sorted([('홍길동',35), ('이순신',75), ('아무개',50)], key = lambda x : x[1], reverse = True)print(result)# [('이순신',75),('아무개',50),('홍길동',35)]리스트와 같은 iterable 객체는 기본으로 sort() 메서드를 내장하고 있다.data = [9,1,8,5,4]data.sort()print(data)# [1,4,5,8,9]2. itertools파이썬에서 반복되는 데이터를 처리하는 기능을 포함한 라이브러리이다.permutations순열 계산이다.iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우.data = ['A','B','C']from itertools import permutationslist(permutations(data,3))# data에서 3개를 뽑는 모든 순열 구하기combinations조합 계산이다.iterable 객체에서 r개의 데이터를 뽑아 순서 고려하지 않고 나열하는 모든 경우.data = ['A','B','C']from itertools import combinationslist(combinations(data,2))# 2개를 뽑는 모든 조합 구하기product중복 순열 계산이다.iterable 객체에서 r개의 데이터를 중복가능하게 뽑아 일렬로 나열하는 모든 경우.data = ['A','B','C']from itertools import productlist(product(data,repeat=2))# data에서 2개를 뽑는 모든 중복 순열 구하기combinations_with_replacement중복 조합 계산이다.iterable 객체에서 r개의 데이터를 중복가능하게 뽑아 순서 고려하지 않고 나열하는 모든 경우.data = ['A','B','C']from itertools import combinations_with_replacementlist(combinations_with_replacement(data,2))# 2개를 뽑는 모든 중복 조합 구하기3. heapq힙 기능을 위해 제공하는 라이브러리다. 다익스트라 최단 경로 알고리즘을 포함해 우선순위 큐 기능 구현에 사용된다.PriorityQueue 라이브러리도 사용할 수 있지만 코딩 테스트 환경에서는 heapq가 더 빠르다고 한다.import heapqheapq.heappush() # 힙에 원소 삽입heapq.heappop() # 힙에서 원소 꺼냄파이썬의 힙은 최소 힙으로 구성되어 있다.힙 정렬다음은 힙 정렬을 heapq로 구현하는 예제이다.# 힙정렬 구현import heapqdef heapsort(iterable):\th = []\tresult = [] # 모든 원소를 차례대로 힙에 삽입\tfor value in iterable:\t\theapq.heappush(h,value) # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기\tfor i in range(len(h)):\t\tresult.append(heapq.heappop(h))\treturn resultresult = heapsort([1,3,5,7,9,2,4,6,8,0])print(result)# [0,1,2,3,4,5,6,7,8,9]파이썬에서는 최대 힙을 제공하지 않기에 원소 부호를 임시로 변경하는 방식을 사용한다.다음은 최대 힙을 구현하여 오름차순 힙 정렬을 구현하는 예제이다.def heapsort(iterable):\th = []\tresult = [] # 모든 원소를 차례대로 힙에 삽입\tfor value in iterable:\t\theapq.heappush(h,-value) # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기\tfor i in range(len(h)):\t\tresult.append(-heapq.heappop(h))\treturn resultresult = heapsort([1,3,5,7,9,2,4,6,8,0])print(result)# [9,8,7,6,5,4,3,2,1,0]4. bisect이진 탐색을 쉽게 구현할 수 있도록 제공하는 라이브러리다.정렬된 배열에서 특정한 원소를 찾아야 할 때 매우 효과적이다. bisect_left(a,x) 정렬된 순서 유지하며 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드 bisect_right(a,x) 정렬된 순서를 유지하도록 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드 # 예시a = [1,2,4,4,8]x = 4from bisect import bisect_left, bisect_rightbisect_left(a,x) # 2bisect_right(a,x) # 4활용값이 특정 범위에 속하는 원소의 개수를 구할 때from bisect import bisect_left, bisect_right# 값이 [left_value, right_value]인 데이터 개수 반환def count_by_range(a, left_value, right_value):\tright_index = bisect_right(a,right_value)\tleft_index = bisect_left(a,left_value)\treturn right_index - left_indexa = [1,2,3,3,3,3,4,4,8,9]# 값이 4인 데이터 개수 출력print(count_by_range(a,4,4)) # 2# 값이 [-1,3] 범위에 있는 데이터 개수 출력print(count_by_range(a,-1,3)) # 65. collectionsdeque큐를 구현할때 사용한다. Queue 라이브러리가 따로 있지만 일반적인 큐 자료구조를 구현하는 라이브러리가 아니라고한다. deque는 리스트와 다르게 인덱싱, 슬라이싱 등 사용불가 대신 연속적 나열 데이터의 시작/끝에 유리 스택/큐의 대용으로 사용 가능from collections dequedeque.popleft() # 첫번째 원소 제거deque.pop() #마지막 제거deque.appendleft(x) # 첫번째에 삽입deque.append(x) # 마지막에 삽입Counter등장 횟수를 세는 기능을 제공한다.iterable 객체가 주어졌을 때, 해당 객체 내부의 원소가 몇 번씩 등장했는지를 알려준다.# 예시from collections import Countercounter = Counter(['red','blue','red',\t\t\t\t'green','blue','blue'])# {'red':2, 'blue':3, 'green':1}6. math자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리이다. math.factorial() 팩토리얼 math.sqrt() 제곱근 math.gcd(a,b) 최대공약수 math.pi 파이(pi, 3.14…) math.e 자연상수 e 참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Python] 코딩테스트를 위한 파이썬 문법 02 - 조건문, 반복문, 함수, 입출력", "url": "/posts/02-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-01-31 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 조건문 비교 연산자 논리 연산자 기타 연산자 반복문 while 문 for 문 함수 입출력1. 조건문조건문은 프로그램을 작성할 때 프로그램의 흐름을 제어하는 문법이다.조건문을 이용하면 조건에 따라서 프로그램의 로직을 설정할 수 있다.파이썬에서 조건문을 작성할 때는 if - elif - else를 이용한다.if 조건문 1: 조건문 1이 True 일 때 실행되는 코드elif 조건문 2: 조건문 1이 False 이고, 조건문 2가 True 일 때 실행되는 코드else: 위의 모든 조건문이 모두 False 일 때 실행되는 코드 들여쓰기의 경우 스페이스바 4번과 탭을 사용한다.비교 연산자조건문에는 비교 연산자를 자주 사용한다. X == Y X와 Y가 서로 같을 때 X != Y X와 Y가 서로 다를 때 X &gt; Y X가 Y보다 클 때 X &lt; Y X가 Y보다 작을 때 X &gt;= Y X가 Y 이상일 때 X &lt;= Y X가 Y 이하일 때 논리 연산자 X and Y X와 Y가 모두 True일 때 X or Y X와 Y 중 하나라도 True일 때 not X X가 False일 때 기타 연산자 X in 리스트 리스트 안에 X가 들어가 있을 때 X not in 문자열 문자열 안에 X가 들어가 있지 않을 때 조건문이 참이어도 아무것도 처리하고 싶지 않을 때 pass# 예시 1score = 85if score &gt;= 80: passelse: print('프로그램을 종료합니다')# 프로그램을 종료합니다 줄바꿈 없이 간략하게 표현 가능# 예시 2score =85if score &gt;= 80: result = \"Success\"else: result = \"Fail\"# Success 조건부 표현식으로 if-else문을 한 줄에 작성 가능# 예시 3score = 85result = \"Success\" if score &gt;= 80 else \"Fail\"print(result)# Success특히 조건부 표현식은 리스트 원소 값 변경하여 또 다른 리스트 만들 때 매우 간결하게 사용 가능하다.리스트에서 특정 원소 값만 없애는 예시이다.# 예시 4a = [1,2,3,4,5,5,5]remove_set = {3,5}result = [i for i in a if i not in remove_set]print(result)# [1,2,4] 실제 수학 부등식을 그대로 사용 가능다른 언어와 달리 파이썬은 조건문에서 수학의 부등식을 그대로 사용 가능하다.# 예시 5x = 15if 0 &lt; x &lt; 20: print(\"x는 0 이상 20 미만의 수입니다.\")# x는 0 이상 20 미만의 수입니다.다른 언어처럼 표현해도 상관없다.2. 반복문반복문은 특정한 소스코드를 반복 실행할 때 사용할 수 있다.코딩 테스트에서는 보통 for문을 더 자주 사용하는 듯 하다.while 문조건문이 참일 때 반복 수행된다.다음은 1부터 9까지의 홀수의 합을 구하는 예시이다.# 예시 1i = 1result = 0# i가 9 이하일 때 아래 코드 반복 실행while i &lt;= 9: if i % 2 == 1: result += i i += 1print(result)# 25for 문다음과 같은 형태로 리스트에서 반복문을 표현 할 수 있다.in 뒤의 데이터로는 리스트, 튜플, 문자열 등이 사용될 수 있다.리스트의 첫번째 인덱스부터 차례대로 하나씩 방문한다.for 변수 in 리스트:\t실행할 소스코드range()를 활용해도 된다. range(시작값, 끝값+1) 형태이다.continue반복문 안에서 continue를 만나면 프로그램의 흐름은 반복문의 처음으로 돌아간다.다음은 점수로 학생의 합격 여부를 판별할 때, 블랙리스트에 있는 학생은 무시하는 예시이다.scores = [90,85,77,65,97]black_list = {2,4}for i in range(5): if i + 1 in black_list: continue if scores[i] &gt;= 80: print(i+1, \"번 학생은 합격입니다.\")# 1번 학생은 합격입니다.# 2번 학생은 합격입니다.3. 함수다음과 같은 형태로 함수를 선언하여 사용하면 효율적으로 작성할 수 있다.def 함수명(매개변수): 실행할 소스코드 return 반환 값global 키워드함수 안에서 함수 밖의 변수 데이터를 변경해야 하는 경우가 있다.global 키워드로 변수를 지정하면, 해당 함수에서 지역변수 만들지 않고 전역변수를 바로 참조한다.# 예시a = 0def func(): global a a += 1for i in range(10): func()print(a)# 10람다 표현식파이썬은 또한 람다 표현식을 사용할 수 있다. 다음은 덧셈을 표현한 예시이다.# 일반적인 add() 메서드 사용def add(a,b): return a + bprint(add(3,7)) # 10# 람다 표현식으로 구현한 add() 메서드print((lambda a, b: a + b)(3,7)) # 104. 입출력입력파이썬에서는 구분자가 줄 바꿈인지 공백인지에 따라서 다른 처리를 요구한다.줄 바꿈이라면 int(input())을 여러 번 사용하면 되는데, 공백이라면 다음과 같이 하면된다.# 데이터의 개수 입력n = int(input())# 각 데이터를 공백으로 구분하여 입력data = list(map(int, input().split()))data.sort(reverse = True)공백으로 구분된 데이터의 개수가 많지 않다면 단순하게 map() 함수를 활용해도 된다.# n,m,k를 공백으로 구분하여 입력n, m, k = map(int,input().split())단순하게 input() 함수를 그대로 사용하는 것보다 더 빠르게 입력 받는 방법이 있다.sys.stdin.readlin() 함수를 활용하는 것이다. 기본적으로 엔터가 줄 바꿈 기호로 입력된다.rstrip()을 사용하면 공백 문자를 제거한다.import sys# 문자열 입력받기data = sys.stdin.readline().rstrip()출력변수와 문자를 섞어서 출력해야할 때 str() 함수를 이용하거나 자료형을 콤마(,)를 기준으로 구분하여 출력한다.answer =7# 변수를 문자열로 바꾸어 출력print(\"정답은 \" + str(answer) + \"입니다.\")# 정답은 7입니다.# 각 변수를 콤마(,)로 구분하여 출력print(\"정답은\",str(answer),\"입니다.\")# 정답은 7입니다.f-stringf-string 문법은 문자열 앞에 접두사 ‘f’를 붙임으로써 사용할 수 있다.단순히 중괄호({}) 안에 변수를 넣음으로써, 자료형의 변환 없이도 바꾸지 않고도 간단히 문자열과 정수를 함께 넣을 수 있다.answer = 7print(f\"정답은 {answer}입니다.\")# 정답은 7입니다.참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[Python] 코딩테스트를 위한 파이썬 문법 01 - 자료형", "url": "/posts/01-algorithm/", "categories": "Study, Algorithm", "tags": "Python, Algorithm", "date": "2022-01-31 00:00:00 +0900", "snippet": "본 포스팅은 “이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 수 자료형 정수형 실수형 수 자료형의 연산 리스트 자료형 리스트 만들기 인덱싱, 슬라이싱 리스트 컴프리헨션 기타 메서드 문자열 자료형 문자열 초기화 문자열 연산 튜플 자료형 사전 자료형 사전 자료형 관련 함수 집합 자료형 집합 자료형 연산, 함수 \"알고리즘 문제 풀이를 포함하여 모든 프로그래밍은 결국 데이터를 다루는 행위인 만큼, 자료형에 대한 이해는 프로그래밍의 길에 있어서의 첫걸음이라고 할 수 있다.\"1. 수 자료형정수형정수를 다루는 자료형이며 양의 정수, 음의 정수, 0이 있다.코딩테스트에서 출제되는 알고리즘 문제는 대부분 입출력이 정수형이다.실수형지수 표현 방식은 코딩 테스트에서 많이 사용되는데, 최단 경로 문제에서는 도달할 수 없는 노드에 대하여 최단 거리를 ‘무한(INF)’으로 설정하곤 한다.보통 컴퓨터 시스템은 수 데이터를 처리할 때 2진수를 이용하며, 실수를 처리할 때 부동소수점 방식을 이용한다.오늘날 가장 널리 쓰이는 IEEE754 표준에서는 실수형을 저장하기 위해 4바이트, 혹은 8바이트라는 고정된 크기의 메모리를 할당하며, 이러한 이유로 인해 현대 컴퓨터 시스템은 대체로 실수 정보를 표현하는 정확도에 한계를 가진다.따라서 소수점 값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지 못해서 원하는 결과를 얻지 못할 수 있다. 이럴 때는 round() 함수를 이용할 수 있다.예를 들어, 0.3과 0.6을 더한 값이 0.899999로 나올 수도 있다.수 자료형의 연산프로그래밍에서는 사칙연산 (+,-,x,/)을 이용해 계산한다. / 실수형으로 나눗셈을 처리 % 나머지 연산자 // 몫 연산자 ** 거듭제곱 2. 리스트 자료형리스트는 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용할 수 있다.파이썬의 리스트 자료형은 C나 자바와 같은 프로그래밍 언어의 배열 기능을 포함하고 있다.내부적으로 연결 리스트 자료구조를 채택하고 있어서 append(), remove() 등의 메서드를 지원한다.파이썬의 리스트는 C++의 STL vector와 유사하며, 리스트 대신에 배열 혹은 테이블이라고 부르기도 한다.리스트 만들기# 빈 리스트 선언 방법 1)a = list()# 빈 리스트 선언 방법 2)a = []크기가 N이고 모든 값이 0인 1차원 리스트를 초기화하는 방법n = 10a = [0] * nprint(a) # 결과 [0,0,0,0,0,0,0,0,0,0]인덱싱, 슬라이싱인덱스값을 입력하여 리스트의 특정한 원소에 접근하는 것을 인덱싱이라 한다.파이썬의 인덱스값은 양의 정수와 음의 정수를 모두 사용할 수 있으며, 음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다.리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용할 수 있다.대괄호 안에 콜론(:)을 넣어서 시작 인덱스와 (끝 인덱스 -1)을 설정할 수 있다.리스트 컴프리헨션리스트 컴프리헨션은 리스트를 초기화하는 방법 중 하나이다.([]) 안에 조건문과 반복문을 넣는 방식이다.0부터 19까지 홀수만 포함하는 리스트 만들기array = [i for i in range(20) if i % 2 == 1]# [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]0부터 19까지 홀수만 포함하는 리스트 만들기더 일반적인 소스array = []for i in range(20):\tif i % 2 == 1:\t\tarray.append(i)# [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]1부터 9까지 제곱 값 포함하는 리스트 만들기array = [i * i for i in range(1,10)]# [1, 4, 9, 16, 25, 36, 49, 64, 81]N * M 크기 2차원 리스트 초기화n = 3m = 3array = [[0]*m for _ in range(n)]# [[0,0,0], [0,0,0], [0,0,0], [0,0,0]]## 기타 메서드기타 메서드 append() 리스트에 원소를 하나 삽입할 때 sort() 오름차순 정렬 sort(reverse = True) 내림차순 정렬 reverse() 원소 순서 뒤집기 insert(삽입 위치 인덱스, 삽입할 값) 원소 삽입 count() 데이터 개수 셀 때 remove() 원소 제거, 여러개면 하나만 제거 insert()와 remove()의 시간 복잡도를 줄이며, 특정 값의 원소를 모두 제거할 때 다음과 같은 방법 활용.특정 값 모두 제거하는법a = [1,2,3,4,5,5,5]remove_set = {3,5}result = [i for i in a if i not in remove_set]# [1, 2, 4]3. 문자열 자료형문자열 초기화 문자열을 큰따옴표로 구성하는 경우, 내부적으로 작은따옴표 포함가능 문자열을 작은따옴표로 구성하는 경우, 내부적으로 큰따옴표 포함가능 백슬래시()를 사용하면, 큰따옴표나 작은따옴표를 원하는 만큼 포함가능문자열 연산리스트와 같이 처리된다.4. 튜플 자료형튜플 자료형은 리스트와 거의 비슷한데 다음과 같은 차이가 있다. 튜플은 한 번 선언된 값을 변경할 수 없다. 리스트는 대괄호([])를, 튜플은 소괄호(())를 이용한다.그래프 알고리즘을 구현할 때 자주 사용된다.예로, 다익스트라 최단 경로 알고리즘처럼 최단 경로 찾는 알고리즘의 내부에서 우선순위 큐를 이용하는데, 우선순위 큐에 한 번 들어간 값은 변경되지 않는다.때문에 튜플로 구성하여 소스코드를 작성한다.또한, 튜플은 리스트에 비해 상대적으로 공간 효율적이고, 원소의 성질이 서로 다를 때 주로 사용한다.‘비용’과 ‘노드 번호’라는 서로 다른 성질 데이터를 (비용, 노드번호)의 형태로 튜플로 묶어 관리하는 것이 관례이다.5. 사전 자료형사전 자료형키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형이다.리스트나 튜플은 값을 순차적으로 저장한다는 특징이 있다. 키-값 쌍으로 구성된 데이터를 처리함에 있어서 리스트보다 훨씬 빠르게 동작한다는 점을 기억.특정 원소 있는지 검사‘원소 in 사전’의 형태를 사용할 수 있다.리스트나 튜플에 대해서도 사용할 수 있는 문법이다.# 예시data = dict()data['사과'] = 'Apple'data['바나나'] = 'Banana'if '사과' in data:\tprint(\"'사과'를 키로 가지는 데이터가 존재합니다.\")관련 함수대표적으로 키와 값을 별도로 뽑아내기 위한 함수 keys() 키 데이터만 뽑아서 리스트로 이용 values() 값 데이터만 뽑아서 리스트로 이용 6. 집합 자료형집합 자료형집합은 기본적으로 리스트 혹은 문자열을 이용해서 만듬. 중복 허용하지 않는다. 순서가 없다.리스트나 튜플은 순서가 있기에 인덱싱으로 값을 얻을 수 있지만, 사전자료형과 집합자료형은 순서가 없어서 불가능하다.이와 더불어 집합 자료형에는 키가 존재하지 않고 값 데이터만 담는다.# 집합 자료형 초기화 방법 1data = set([1,1,2,3,4,4,5])# {1,2,3,4,5}# 집합 자료형 초기화 방법 2data = {1,1,2,3,4,4,5}# {1,2,3,4,5}연산, 함수연산 | 합집합 print(a | b) &amp; 교집합 print(a &amp; b) - 차집합 print(a - b) 함수 add() 원소추가 data.add(4) update() 여러 원소추가 data.update([5,6]) remove() 특정값 원소 삭제 data.remove(3) 참고“이것이 취업을 위한 코딩테스트다 with 파이썬” - (한빛미디어, 나동빈 지음) 자료 주소: http://www.hanbit.co.kr/src/10307/ 저자 깃허브 주소: http://github.com/ndb796 동영상 주소: http://youtube.com/user/HanbitMedia93" }, { "title": "[ROS] ros2djs 활용 예제", "url": "/posts/06-ros/", "categories": "Study, ROS", "tags": "ROS, roslibjs, ubuntu, Robot", "date": "2021-12-02 00:00:00 +0900", "snippet": " ros2djs 프로젝트에서의 사용 예시 JavaScript Html 코드 리뷰 JavaScript Html 1. ros2djsroslibjs, rosbridge 등을 제작한 robot webtools에서 제공하는 slam &amp; navigation 관련 라이브러리이다.rviz로 쉽게 표현되던 자율주행 관련 명령, 시각화를 roslibjs를 활용하여 웹으로 제공한다.roslibjs의 위에 EaselJS를 사용하여 표현한만큼, 플래쉬 개발에 익숙할 경우 더 이쁜 디자인으로 뽑아낼 수 있을 것 같다. EaselJS는 HTML Canvas를 쉽게 활용하기 위해 개발된 오픈소스 라이브러리라고 한다.2. 프로젝트에서의 사용 예시KFQ 최종 프로젝트에서 사용한 코드의 일부분을 발췌하였다.gazebo를 활용한 환경의 최종 코드에서 다음과 같이 웹 페이지가 출력된다.JavaScriptfunction init() { // Connecting to ROS // ----------------- var ros = new ROSLIB.Ros(); // Create a connection to the rosbridge WebSocket server. ros.connect('ws://localhost:9090'); // Create the main viewer. var viewer = new ROS2D.Viewer({ divID : 'map', width : 516, height : 516 }); var nav = NAV2D.OccupancyGridClientNav({ ros : ros, rootObject : viewer.scene, viewer : viewer }); var nav_status = new ROSLIB.Topic({ ros : ros, name : '/move_base/status', messageType : 'actionlib_msgs/GoalStatusArray' }); // Then we add a callback to be called every time a message is published on this topic. nav_status.subscribe(function(status) { var length = status.status_list.length; if (length == 1) { // var nav_status = document.getElementById('nav_status'); if (status.status_list[0].text == \"Goal reached.\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 도착 완료'; } else if (status.status_list[0].text == \"This goal has been accepted by the simple action server\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 전달 중'; } else { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '명령 전달 진행 중'; } } else { if (status.status_list[1].text == \"Goal reached.\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 도착 완료'; } else if (status.status_list[1].text == \"This goal has been accepted by the simple action server\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 전달 중'; } else { nav_status.innerText = '명령 전달 진행 중'; } } });}Html&lt;head&gt; &lt;!-- roslibjs &amp; css --&gt; &lt;script type=\"text/javascript\" src=\"http://static.robotwebtools.org/roslibjs/current/roslib.min.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script type=\"text/javascript\" src=\"https://static.robotwebtools.org/ros2djs/current/ros2d.min.js\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"https://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://static.robotwebtools.org/EaselJS/current/easeljs.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css\" /&gt; &lt;script type=\"text/javascript\" src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.23/jquery-ui.min.js\"&gt;&lt;/script&gt; &lt;script src=\"static/js/ros/ros2d.js\"&gt;&lt;/script&gt; &lt;script src=\"static/js/ros/example.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body onload=\"init()\"&gt; &lt;!-- 자율주행 관련 메세지 --&gt; &lt;div class=\"col-xl-4 mb-3 col-lg-6 col-xxl-6 col-md-6 container-box\"&gt; &lt;div class=\"card h-100\"&gt; &lt;div class=\"card-title text-center\"&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;div id=\"nav_status\"&gt;자율 주행 메세지&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 지도 --&gt; &lt;div class=\"col-xl-4 mb-3 col-lg-6 col-xxl-6 col-md-6 container-box\"&gt; &lt;div class=\"card text-center\"&gt; &lt;div class=\"card-body\"&gt; &lt;div id=\"map\" style='height: 100%; width: 100%;'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;3. 코드 리뷰JavaScript// Create the main viewer.var viewer = new ROS2D.Viewer({ divID : 'map', width : 516, height : 516});var nav = NAV2D.OccupancyGridClientNav({ ros : ros, rootObject : viewer.scene, viewer : viewer});var nav_status = new ROSLIB.Topic({ ros : ros, name : '/move_base/status', messageType : 'actionlib_msgs/GoalStatusArray'});생성해준 map을 nav2djs의 OccupancyGridClientNav를 활용해서 여러 토픽들과 연결해 주었고,nav_status를 통해서는 자율주행의 결과와 관련된 토픽에 연결해 주었다. nav2djs 원본에서는 OccupancyGridClientNav를 통해서 slam &amp; navigation 명령을 내리는 부분을 확인하면 Topic이 아닌 Action으로 연결 되어있다. 내가 아직 액션에 대해서 익숙하지 않은 이유인지, 작동이 잘 되지않아서 코드를 수정하여 토픽으로 연결해주었다.nav_status.subscribe(function(status) { var length = status.status_list.length; if (length == 1) { // var nav_status = document.getElementById('nav_status'); if (status.status_list[0].text == \"Goal reached.\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 도착 완료'; } else if (status.status_list[0].text == \"This goal has been accepted by the simple action server\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 전달 중'; } else { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '명령 전달 진행 중'; } } else { if (status.status_list[1].text == \"Goal reached.\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 도착 완료'; } else if (status.status_list[1].text == \"This goal has been accepted by the simple action server\") { var nav_status = document.getElementById('nav_status'); nav_status.innerText = '목표 지점 전달 중'; } else { nav_status.innerText = '명령 전달 진행 중'; } }});/move_base/status topic의 subscriber로 사용할 때, 메세지의 형태를 먼저 확인하고, 필요에 맞게 nav_status라는 DOM에 내용을 배치하였다.Html&lt;div id=\"map\" style='height: 100%; width: 100%;'&gt;&lt;/div&gt;canvas로 map을 띄우고, 해당 캔버스 위에서 nav = NAV2D.OccupancyGridClientNav와 맞는 명령들을 가능케 한다. 나는 일단 구현을 목표로 하여 캔버스의 크기를 조정한다거나, 내부의 이미지를 조정하는 기능은 사용하지 못했지만, 다 마련이 되어있다.&lt;div id=\"nav_status\"&gt;자율 주행 메세지&lt;/div&gt;상황에 맞는 메세지가 출력된다.nav2djs의 경우, 캔버스 안에 map 위의 마우스 좌표를 다시 변환하고, 변환된 좌표를 활용하여 주행과 관련된 토픽/액션 메세지를 전달하는 식으로 코드가 작성이 되어있다. 확대/축소 기능을 사용하기 위해서는 확대/축소 될 때마다 새로 좌표를 변환해주어야 하는데, 아직까지 나의 실력으로는 ajax를 활용하지 않으면 구현이 힘들어보였다. 원래는 단순히 마우스 휠을 통해 조정을 하려했지만 제대로 코드가 작동하지 않아서 일단 구현을 목표로 했었다. 아쉬움이 많은 만큼 다시 도전해보고싶다.참고ros 공식 wiki 주소: http://wiki.ros.org/ROSRobotwebtools (roslibjs 등 제공) 주소: http://robotwebtools.org/roslibjs 공식 wiki 주소: http://wiki.ros.org/roslibjs 깃허브: https://github.com/RobotWebTools/roslibjsros2djs 공식 wiki 주소: http://wiki.ros.org/ros2djsEaselJS API Documents 주소: https://createjs.com/docs/easeljs/modules/EaselJS.html" }, { "title": "[ROS] keyboardteleopjs", "url": "/posts/05-ros/", "categories": "Study, ROS", "tags": "ROS, keyboardteleop.js, keyboardteleop, ubuntu, Robot", "date": "2021-12-02 00:00:00 +0900", "snippet": " 프로젝트에서의 사용 예시 JavaScript Html 코드 리뷰 JavaScript Html 1. keyboardteleop.jsteleoperation원격 조작을 의미한다. 멀리 떨어진 시스템이나 기계의 작동2. keyboard teleoperationROS를 처음 설치하고 접하는 turtlesim.우리는 이미 turtlesim의 거북이를 조종하기 위해 사용해본적이 있다.키보드로 원격 조작을 하는 라이브러리였다.이와 비슷하게, 키보드로 원격 조작을 하는 라이브러리의 종류는 무수히 많다.나는 그 중 roslibjs, rosbridge 등을 제작한 robot webtools의 keyboardteleop.js를 사용해보았다.코드keyboardteleop.js 최근 버전전체 코드var KEYBOARDTELEOP = KEYBOARDTELEOP || { REVISION: \"0.3.0\" };(KEYBOARDTELEOP.Teleop = function (a) { var b = this; a = a || {}; var c = a.ros, d = a.topic || \"/cmd_vel\", e = a.throttle || 1; this.scale = 1; var f = 0, g = 0, h = 0, i = new ROSLIB.Topic({ ros: c, name: d, messageType: \"geometry_msgs/Twist\", }), j = function (a, c) { var d = f, j = g, k = h, l = !0, m = 0; switch ((c === !0 &amp;&amp; (m = e * b.scale), a)) { case 65: h = 1 * m; break; case 87: f = 0.5 * m; break; case 68: h = -1 * m; break; case 83: f = -0.5 * m; break; case 69: g = -0.5 * m; break; case 81: g = 0.5 * m; break; default: l = !1; } if (l === !0) { var n = new ROSLIB.Message({ angular: { x: 0, y: 0, z: h }, linear: { x: f, y: g, z: h }, }); i.publish(n), (d !== f || j !== g || k !== h) &amp;&amp; b.emit(\"change\", n); } }, k = document.getElementsByTagName(\"body\")[0]; k.addEventListener( \"keydown\", function (a) { j(a.keyCode, !0); }, !1 ), k.addEventListener( \"keyup\", function (a) { j(a.keyCode, !1); }, !1 );}), (KEYBOARDTELEOP.Teleop.prototype.__proto__ = EventEmitter2.prototype);코드 리뷰참고ros 공식 wiki 주소: http://wiki.ros.org/ROSRobotwebtools (roslibjs 등 제공) 주소: http://robotwebtools.org/roslibjs 공식 wiki 주소: http://wiki.ros.org/roslibjs 깃허브: https://github.com/RobotWebTools/roslibjskeyboardteleopjs 공식 wiki 주소: http://wiki.ros.org/keyboardteleopjs/Tutorials/CreatingABasicTeleopWidgetWithSpeedControl" }, { "title": "[Tips] Python system path", "url": "/posts/python/", "categories": "Etc, Tips", "tags": "ubuntu, Python", "date": "2021-12-01 00:00:00 +0900", "snippet": "KFQ 최종 프로젝트에서 파이썬 언어로 개발을 진행하던 중 오류가 발생하였다.JetPack에는 기본적으로 opencv가 설치되어있었지만, 파이썬 3.6에 설치되어있었고ROS melodic은 파이썬 2.7을 사용하면서 이 문제를 해결하고자 하였다.직접 파이썬 2.7에 맞는 opencv를 설치하기위해 catkin build 과정을 따라갔지만 다른 문제가 생기는 등..최종적으로 선택한 방법은 다음과 같다.오류 메세지 &amp; 원인여러 버젼의 파이썬이 설치되어 있어서 원하는 모듈을 불러오지 못하는 등파이썬 시스템 경로가 다른 상황에서 발생한 문제를 해결할 때 사용한다.해결 방법다음은 내가 직접 사용한 코드의 일부이다.이처럼 sys.path를 확인하고 직접 수정해주는 과정을 가졌다.import syssys.path.remove('/home/bot/catkin_ws/devel/lib/python2.7/dist-packages')sys.path.append('/usr/local/lib/python3.6/dist-packages')sys.path.append('/usr/lib/python3/dist-packages')sys.path.append('/usr/lib/python3.6/dist-packages')sys.path.append('/usr/lib/python3.6/dist-packages/cv2/python-3.6')" }, { "title": "[Tips] JetPack에서 opencv 사용하기 ", "url": "/posts/jetpack_cv2/", "categories": "Etc, Errors", "tags": "ubuntu, error, opencv, jetpack, jetson, Python", "date": "2021-12-01 00:00:00 +0900", "snippet": "아키텍처가 다르기 때문인지, pc 개발환경에서 잘 작동하던 코드들이 JetPack에서는 작동하지 않았다.KFQ 최종 프로젝트에서 사용한 카메라 영상 송수신 모듈을 개발하는 중 발생하였다.opencv를 사용할 때, 특히 VideoCapture를 사용함에 있어서 참고하면 될 것 같다.오류 메세지import cv2capture = cv2.VideoCapture(0)후략..$ python cam_server.py[ WARN:0] global /home/nvidia/host/build_opencv/nv_opencv/modules/videoio/src/cap_gstreamer.cpp (1757) handleMessage OpenCV \\ | GStreamer warning: Embedded video playback halted; module v4l2src0 reported: Internal data stream error.[ WARN:0] global /home/nvidia/host/build_opencv/nv_opencv/modules/videoio/src/cap_gstreamer.cpp (886) open OpenCV \\ | GStreamer warning: unable to start pipeline[ WARN:0] global /home/nvidia/host/build_opencv/nv_opencv/modules/videoio/src/cap_gstreamer.cpp (480) isPipelinePlaying OpenCV \\ | GStreamer warning: GStreamer: pipeline have not been createdselect timeoutVIDIOC_DQBUF: Resource temporarily unavailableOpenCV(4.1.1) /home/nvidia/host/build_opencv/nv_opencv/modules/imgcodecs/src/grfmt_base.capp:145: error: (-10:Unknown error code -10) \\Raw image encoder error: Empty JPEG image (DNL not supported) in function 'throwOnEror'원인파악중arm64, x86_64, i386 등.. 아키텍처의 차이로 인한 것일까..? 잘 모르겠다..해결 방법import cv2capture = cv2.VideoCapture(\"nvarguscamerasrc sensor-id=0 ! video/x-raw(memory:NVMM), width=640, height=480, format=(string)NV12, framerate=(fraction)20/1 ! nvvidconv flip-method=0 ! video/x-raw, width=640, height=480, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\", cv2.CAP_GSTREAMER)후략..VideoCapture 내부에 위와 같은 코드로 수정을 해주어 해결하였다.정상적으로 작동하는 모습을 확인하였다.참고" }, { "title": "[ROS] roslibjs 활용 예제", "url": "/posts/04-ros/", "categories": "Study, ROS", "tags": "ROS, roslibjs, ubuntu, Robot", "date": "2021-12-01 00:00:00 +0900", "snippet": " 프로젝트에서의 사용 예시 JavaScript Html 코드 리뷰 JavaScript Html 1. 프로젝트에서의 사용 예시KFQ 최종 프로젝트에서 사용한 코드의 일부분을 발췌하였다.gazebo를 활용한 환경의 최종 코드에서 다음과 같이 웹 페이지가 출력된다.JavaScriptfunction init() { // Connecting to ROS // ----------------- var ros = new ROSLIB.Ros(); // If there is an error on the backend, an 'error' emit will be emitted. ros.on('error', function(error) { document.getElementById('connecting').style.display = 'none'; document.getElementById('connected').style.display = 'none'; document.getElementById('closed').style.display = 'none'; document.getElementById('error').style.display = 'inline'; console.log(error); }); // Find out exactly when we made a connection. ros.on('connection', function() { console.log('Connection made!'); document.getElementById('connecting').style.display = 'none'; document.getElementById('error').style.display = 'none'; document.getElementById('closed').style.display = 'none'; document.getElementById('connected').style.display = 'inline'; }); ros.on('close', function() { console.log('Connection closed.'); document.getElementById('connecting').style.display = 'none'; document.getElementById('connected').style.display = 'none'; document.getElementById('closed').style.display = 'inline'; }); // Create a connection to the rosbridge WebSocket server. ros.connect('ws://localhost:9090'); cmd_vel_listener = new ROSLIB.Topic({ ros : ros, name : \"/cmd_vel\", messageType : 'geometry_msgs/Twist' }); var twist = new ROSLIB.Message({ linear: { x: 0, y: 0, z: 0 }, angular: { x: 0, y: 0, z: 0 } }); cmd_vel_listener.publish(twist); // Initialize the teleop. var teleop = new KEYBOARDTELEOP.Teleop({ ros : ros, topic : '/cmd_vel' }); teleop.scale = (1); // Then we add a callback to be called every time a message is published on this topic. cmd_vel_listener.subscribe(function(cmd_vel) { var vel_x = document.getElementById('vel_linear_x'); vel_x.innerText = '전/후 속도 \\u00A0'+cmd_vel.linear.x.toPrecision(10); });}Html&lt;head&gt; &lt;!-- roslibjs &amp; css --&gt; &lt;script type=\"text/javascript\" src=\"http://static.robotwebtools.org/roslibjs/current/roslib.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://static.robotwebtools.org/EaselJS/current/easeljs.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css\" /&gt; &lt;script type=\"text/javascript\" src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.23/jquery-ui.min.js\"&gt;&lt;/script&gt; &lt;script src=\"static/js/ros/example.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body onload=\"init()\"&gt; &lt;!-- Title --&gt; &lt;div class=\"row page-titles mx-0\"&gt; &lt;div class=\"col-sm-6 p-md-0\"&gt; &lt;div class=\"navbar\"&gt; &lt;h4&gt; Security Robot&lt;/h4&gt; &lt;div id=\"statusIndicator\"&gt; &lt;p id=\"connecting\"&gt; Connecting to rosbridge... &lt;/p&gt; &lt;p id=\"connected\" style=\"color:#00D600; display:none\"&gt; Connected &lt;/p&gt; &lt;p id=\"error\" style=\"color:#FF0000; display:none\"&gt; Error in the backend! &lt;/p&gt; &lt;p id=\"closed\" style=\"display:none\"&gt; Connection closed. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"card\"&gt; &lt;div class=\"card-body\"&gt; &lt;div id=\"vel_linear_x\"&gt;전/후 속도&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;2. 코드 리뷰JavaScriptvar ros = new ROSLIB.Ros();roslibjs 라이브러리를 사용할 준비를 한다. ROS와의 연결을 담당.ros.on('error', function(error) { document.getElementById('connecting').style.display = 'none'; document.getElementById('connected').style.display = 'none'; document.getElementById('closed').style.display = 'none'; document.getElementById('error').style.display = 'inline'; console.log(error);});// Find out exactly when we made a connection.ros.on('connection', function() { console.log('Connection made!'); document.getElementById('connecting').style.display = 'none'; document.getElementById('error').style.display = 'none'; document.getElementById('closed').style.display = 'none'; document.getElementById('connected').style.display = 'inline';});ros.on('close', function() { console.log('Connection closed.'); document.getElementById('connecting').style.display = 'none'; document.getElementById('connected').style.display = 'none'; document.getElementById('closed').style.display = 'inline';});ROS 통신 상태가 ‘error’인지, ‘connection’인지, ‘close’인지를 구분지어 표기해주기 위함이다.Html에서 id를 통해 display style을 선택해주기 때문에, if 문으로 작성된 것과 같은 기능을 할 수 있다.ros.connect('ws://localhost:9090');rosbridge의 websocket server와 연결한다. localhost 부분의 ip 설정을 통해 다른 기기와도 연동이 가능하다.cmd_vel_listener = new ROSLIB.Topic({ ros : ros, name : \"/cmd_vel\", messageType : 'geometry_msgs/Twist'});var twist = new ROSLIB.Message({ linear: { x: 0, y: 0, z: 0 }, angular: { x: 0, y: 0, z: 0 }});cmd_vel_listener.publish(twist);cmd_vel_listener를 새로운 topic으로 지정한다. topic의 이름과 message type을 설정할 수 있다.이를 활용하여, 이미 발행되고 있는 topic으로의 publisher 역할을 수행 할 수있다.var twist = new ROSLIB.Message({~}) 내부의 메세지를 cmd_vel_listener topic으로 publish 하겠다는 뜻이다.즉, /cmd_vel, 속도의 값을 전부 0으로 초기화 시키는 publisher라고 볼 수 있다. var teleop = new KEYBOARDTELEOP.Teleop({ ros : ros, topic : '/cmd_vel' }); teleop.scale = (1);keyboardteleop.js 라이브러리를 활용./cmd_vel 토픽에 keyboard teleoperation 기능을 수행할 수 있다.keyboardteleop.js에 대해서는 추후 포스팅 예정이다.cmd_vel_listener.subscribe(function(cmd_vel) { var vel_x = document.getElementById('vel_linear_x'); vel_x.innerText = '전/후 속도 \\u00A0'+cmd_vel.linear.x.toPrecision(10);});앞서 설정해준 cmd_vel_listener의 subscriber로 Html document에 ‘vel_linear_x’라는 id로 제공한다.Html&lt;div id=\"statusIndicator\"&gt; &lt;p id=\"connecting\"&gt; Connecting to rosbridge... &lt;/p&gt; &lt;p id=\"connected\" style=\"color:#00D600; display:none\"&gt; Connected &lt;/p&gt; &lt;p id=\"error\" style=\"color:#FF0000; display:none\"&gt; Error in the backend! &lt;/p&gt; &lt;p id=\"closed\" style=\"display:none\"&gt; Connection closed. &lt;/p&gt;&lt;/div&gt;앞선 javascript를 활용하여 rosbridge web socket server와의 연결을 표시한다.&lt;div class=\"card\"&gt; &lt;div class=\"card-body\"&gt; &lt;div id=\"vel_linear_x\"&gt;전/후 속도&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;다음과 같이 정상적으로 속도가 표기된다.공식 wiki를 참고하면, 토픽 외에도 서비스와 액션도 가능하고, 활용도가 매우 무궁무진하다.나는 roslibjs 공식 wiki를 보면서도, 처음에는 와닿지 않아서 헤매었다. 도움이 되면 좋을 것 같다.참고ros 공식 wiki 주소: http://wiki.ros.org/ROSRobotwebtools (roslibjs 등 제공) 주소: http://robotwebtools.org/roslibjs 공식 wiki 주소: http://wiki.ros.org/roslibjs 깃허브: https://github.com/RobotWebTools/roslibjskeyboardteleopjs 공식 wiki 주소: http://wiki.ros.org/keyboardteleopjs/Tutorials/CreatingABasicTeleopWidgetWithSpeedControl" }, { "title": "[KFQ] KFQ 최종 프로젝트 자율순찰로봇 / Architecture", "url": "/posts/02-prj3/", "categories": "Project, KFQ", "tags": "AI, DeepLearning, ROS, YOLO, Robot", "date": "2021-12-01 00:00:00 +0900", "snippet": "본 포스팅은 KFQ 한국품질재단 인공지능 개발자 교육과정 최종 프로젝트의 구조도입니다.https://github.com/IIBlackCode/KFQ_FinalProject.git 로봇 하드웨어 Turtlebot - Proxy Server의 ROS 통신 센서 데이터 등의 각종 토픽 메세지 전송 Proxy Server - Web Application Server의 Web Socket 통신 Turtlebot 카메라 모듈 - WAS의 Web Socket 통신 opencv 활용 Web Application Server - Client 학습한 AI 모델 Inference를 포함한 웹 서비스 제공 Client는 웹 서비스에서 로봇의 제어권과 모니터링을 포함한 관제권 획득 Client의 로봇에 대한 제어는 다시 WAS - Proxy - Turtlebot으로 전달ROS를 활용한 이기종 디바이스간의 통신도 처음으로 도전해보는 것이었기 때문에, 두려움이 있었습니다.다행스럽게도 팀원들과 멘토님의 도움으로 통신구조에 대해 더욱 이해하고, 구현할 수 있었습니다.프로젝트 진행 기간 2021년 7월 31일 토요일 ~ 11월 5일 금요일" }, { "title": "[Tips] Git - 오류 / unable to auto-detect email address", "url": "/posts/01_git_error/", "categories": "Etc, Errors", "tags": "git, error", "date": "2021-12-01 00:00:00 +0900", "snippet": "오류 메세지정상적으로 작동하던 git, github desktop에서 오류가 발생하였다.***Please tell me who you are.Run git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\"to set your account's default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address &lt;got '어쩌고@저쩌고.&lt;none&gt;'&gt;원인환경 변수 경로, 또는 repository 내의 git author 정보의 충돌로 보인다.해결 방법1. 방법친절하게 console 메세지에서 안내받은대로 따라해보자git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\"2. 방법1번 방법이 실패할 경우 진행해준다.git config --replace-all user.email \"you@example.com\"git config --replace-all user.name \"\"Your Name\"참고 https://stackoverflow.com/questions/25671785/git-fatal-unable-to-auto-detect-email-address 제부도소년 님의 포스팅 [git] fatal : unable to auto-detect email 관련 오류 해결방법 " }, { "title": "[ETC] KFQ, 한국품질재단 AI 개발자 교육과정 후기", "url": "/posts/kfq/", "categories": "Blog, Posts", "tags": "AI, KFQ, 한국품질재단, 품질재단", "date": "2021-11-26 00:00:00 +0900", "snippet": "본 포스팅은 KFQ 한국품질재단 인공지능 개발자 교육과정 후기입니다.인공지능은 사실 우리 주변에 있었다.인공지능이라는 분야는 사실 이미 우리 주변에 널리 퍼져있었다.인터넷 검색할 때 오타난 것을 바로 잡아주거나,넷플릭스 / 디즈니플러스 등에서의 영화 추천, 추천 검색어를 뽑아주는 것까지.인공지능이라는 생소했던 학문이 사실은 우리 일상에 이미 널리 존재한다는 것.교육을 듣기 전의 나였다면 쉽게 믿지 못했을 것이다.이 교육과정은 이러한 사실을 나에게 알려준 것 만으로도 많은 것을 알려주었다.AI 개발자 교육과정을 듣기까지내가 졸업한 학부 기계로봇에너지공학과는 크게 세 가지 트랙의 수업이 있었다.재료역학관련 / 열역학관련 / 로보틱스관련 트랙의 크게 세 가지였다.나는 고등학교 진학 이전부터 로봇에 관한 꿈을 꾸며 자라왔고,재수 이후에도 이러한 이유 때문에 학과를 보고 대학을 결정했다.중간에 방황하느라 학점이 좋지는 못하지만, 로봇관련 수업은 꾸준히 열심히 들어왔다.크게 하드웨어와 소프트웨어로 나누었을 때, 학부에서 듣는 로봇 소프트웨어 분야는 단순한 제어 수준이였다.직접 모터의 회전을 결정하고, 그를 바탕으로한 로봇 제어가 대부분이였기에,더 넓은 세계의 로봇 소프트웨어를 접하고 싶었다. 예를 들자면 인공지능.AI의 결합이 로봇 소프트웨어 개발에 큰 역할을 할 것이라는 판단에 교육과정을 이수하게 되었다. 최종 프로젝트때 우리팀이 만든 ‘자율순찰로봇’의 웹 서비스 페이지. 자율주행을 위한 UI와 마스크 미착용자와 화재 감지를 위해 사용되는 카메라 송출화면을 만나볼 수 있다.내가 접한 AI처음 머신러닝이 무엇인지, 딥러닝과의 차이가 무엇인지,인공지능이라는 분야를 통해 얻을 수 있는 이점이 무엇인지 배워갈 때부터 여러 분야의 인공지능을 접하였다.통계적 기술을 바탕으로한 머신러닝 분석. 챗봇. 이미지 분류 등.그 안에서도 많은 세계가 존재했다.그들을 표현하기 위해 배운 웹 개발 기술 또한 더 넓은 세계를 알려주었다.아직 내가 공부한 내용들의 정리를 끝내지는 못했지만, 블로그에도 적용시키려고 노력하고 있다.지금의 나는 알고있다.로봇같은 하드웨어로 표현하기에는 아쉬울 정도로 넓은 분야이다.인공지능은 아직도 블루오션이다.연구 분야에서뿐만 아니라, 상품으로서도 아직도 등장할 것들이 많이 남았다.앞으로나는 이미 발을 담궈버린 ‘인공지능’이라는 분야에서 계속 살아가게 될 것 같다.너무나 넓고 아름다운 세상이다.내가 그려나갈 도화지가 아직도 넓다.나에게 이런 좋은 도화지를 알려준 교육과정은 내 삶을 크게 바꾼 추억이 될 것이다.6개월이라는 짧다면 짧고 길다면 긴 시간.이 분야로 전향하지 않더라도 충분히 투자해볼만한 시간이라고 생각된다.나중에 나의 포스팅을 보는 분들이 교육을 들어보는 것에 고민이 된다면,나는 기꺼이 한국품질재단의 교육과정을 추천할 것이다.한국품질재단 취업지원센터교육과정 진행 기간 2021년 5월 3일 월요일 ~ 11월 5일 금요일 (추가모집)관련 포스트KFQ, 1차 프로젝트 발표 pptKFQ, 2차 프로젝트 발표 ppt 및 웹 사이트KFQ, 2차 프로젝트 - LeafletKFQ, 최종 프로젝트 발표 ppt" }, { "title": "[KFQ] KFQ 최종 프로젝트 / 자율순찰로봇", "url": "/posts/01-prj3/", "categories": "Project, KFQ", "tags": "AI, DeepLearning, ROS, YOLO, Robot", "date": "2021-11-15 00:00:00 +0900", "snippet": "본 포스팅은 KFQ 한국품질재단 인공지능 개발자 교육과정 최종 프로젝트의 발표 ppt 입니다.저희 조의 주제는 자율 순찰 로봇과 웹 서비스 개발이었습니다.https://github.com/IIBlackCode/KFQ_FinalProject.git포함된 Microsoft Office 프레젠테이션, 제공: Office느낀점학부시절 ROS를 사용한 간단한 터틀봇의 제어는 해본적이 있습니다.단순히 라이다에 읽히는 거리 값으로 모터의 제어만을 진행했었는데,이번에는 좀 더 좋은 성능을 보이는 SLAM 패키지를 활용하여 자율주행을 구현해보며 욕심이 생겼습니다.추가로 구매한 카메라를 활용하여 카메라 송출화면을 통신을 통해 전달하고,그 위에 우리가 학습한 인공지능을 직접 입히면서 통신구조에 대해서도 공부가 되었습니다.단순해보이는 통신구조여도 생각보다 구현하기가 어려웠습니다.영상을 디코딩하고 인코딩하는 과정에서 직접 뜯어보며 컴퓨터비젼 분야에 대한 흥미도 생겼습니다.Git, Docker도 좀 더 활용할 수 있게 되었고Ubuntu에서 개발을 진행하며 좀 더 리눅스에 친숙해졌습니다.이번 교육과정에서 배워온 기술들, 지식들에 더욱 나아가서 팀원들과 구현한 이번 프로젝트는 의미가 컸습니다.6개월의 교육과정을 끝내며 아쉬운 점도 많고, 추억도 많이 생겼습니다.제가 부족한 부분도 많이 느꼈기 때문에, 앞으로 더욱 성장할 수 있는 계기가 되어 기쁩니다.프로젝트 진행 기간 2021년 7월 31일 토요일 ~ 11월 5일 금요일" }, { "title": "[Tips] Ubuntu, Python 버전 변경", "url": "/posts/python_ver_change/", "categories": "Etc, Tips", "tags": "Python, ubuntu", "date": "2021-10-19 00:00:00 +0900", "snippet": "파이썬 실행 파일 확인$ ls /usr/bin/ | grep pythonpythonpython2python2.7python3python3.6.....다양한 버전의 파이썬 실행 파일을 확인 할 수 있다.Update-alternatives로 파이썬 버전 등록 및 변경$ sudo update-alternatives --config pythonupdate-alternatives: error: no alternatives for python초기에는 설정된 것이 없기 때문에 아무것도 뜨지 않는다.$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2원하는 버전의 파이썬을 다음과 같이 등록해주면$ sudo update-alternatives --config pythonThere are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status------------------------------------------------------------* 0 /usr/bin/python3.6 2 auto mode 1 /usr/bin/python2.7 1 manual mode 2 /usr/bin/python3.6 2 manual modePress &lt;enter&gt; to keep the current choice[*], or type selection number: 2sudo update-alternatives --config python 명령어로 파이썬의 버전을 변경해 줄 수 있다.Alternatives기본 커맨드의 심볼릭 링크를 관리해주는 리눅스 프로그램데비안 계열 리눅스 (ubuntu)에서는 update-alternatives가 제공참고 JS 님의 포스팅Ubuntu에서 Python 버전을 변경하는 방법 Ubuntu Manpage: update-alternatives " }, { "title": "[Tips] ubuntu 20.04 / 18.04, Github Desktop 설치 ", "url": "/posts/github_desktop/", "categories": "Etc, Tips", "tags": "ubuntu, github desktop", "date": "2021-10-19 00:00:00 +0900", "snippet": "1. Github Desktop.deb 다운로드$ sudo wget https://github.com/shiftkey/desktop/releases/download/release-2.9.0-linux2/GitHubDesktop-linux-2.9.0-linux2.deb2. gdebi-core 설치$ sudo apt-get install gdebi-core3. gdebi로 Github Desktop 설치$ sudo gdebi GitHubDesktop-linux-2.9.0-linux2.debgdebi데비안 계열의 패키지 설치 파일인 .deb 파일을 GUI로 손쉽게 설치할 수 있도록 해주는 패키지저장소 외 인터넷에서 내려받은 .deb 파일을 이용해 패키지를 설치하는 프로그램deb 파일에 저장된 정보를 통해 패키지 의존성을 확인하고 설치할 수 있다예제$ gdebi foo_1.0_all.deb$ gdebi foo-1.0/debian/control참고 기계지니 님의 포스팅깃허브-데스크탑-Github-desktop-리눅스에서-사용하기 Danyson 님의 포스팅How to install Github Desktop for Ubuntu &amp; Debian? Ubuntu Manpage: gdebi - Simple tool to install deb files gdebi in Launchpad " }, { "title": "[Tips] html에 css와 js로 linux terminal 표현하기", "url": "/posts/cssterm/", "categories": "Etc, Tips", "tags": "Javascript, ubuntu, css, jquery, cssterm", "date": "2021-10-19 00:00:00 +0900", "snippet": "&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/cssterm.css\"&gt;&lt;script src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt;&lt;script src=\"https://github.com/nstephens/cssterm/blob/master/scripts/cssterm.js\"&gt;&lt;/script&gt;&lt;script src=\"https://github.com/nstephens/cssterm/blob/master/css/cssterm.css\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;div class=\"cssterm\"&gt; $ sudo reboot -h 0Shutdown scheduled for ~~&lt;/div&gt;이런식으로 javascript와 css를 추가해주고 &lt;div&gt; 태그에 class=\"cssterm\" 하면짜잔~ 나는 chirpy jekyll theme에서 github 블로그로 빌드해줄때 충돌이 일어나서 쓰지 않는다 ㅠ참고 오늘도야근 님의 포스팅티스토리 블로그에서 리눅스터미널 창 형식으로 표현하기 cssterm github " }, { "title": "[Tips] ubuntu 20.04 / 18.04, Google Chrome 설치 ", "url": "/posts/chrome/", "categories": "Etc, Tips", "tags": "ubuntu, chrome", "date": "2021-10-19 00:00:00 +0900", "snippet": "1. 인증키 등록$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -2. PPA를 sources.list.d에 추가$ sudo sh -c 'echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" &gt;&gt; /etc/apt/sources.list.d/google.list'3. 패키지 리스트 업데이트$ sudo sh -c 'echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" &gt;&gt; /etc/apt/sources.list.d/google.list'4. 크롬 웹 브라우저 설치$ sudo apt-get install google-chrome-stable더 간단한 방법1. 최신 Chrome.deb 다운로드wget으로 최신 Google Chrome.deb 패키지를 다운로드$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb2. 설치$ sudo apt install ./google-chrome-stable_current_amd64.deb참고 쵸코쿠키 님의 포스팅Ubuntu 18.04 : 구글 크롬 웹 브라우저를 설치하는 방법, 예제, 명령어 webnautes 님의 포스팅Ubuntu 20.04 / 18.04에 Chrome 웹 브라우저 64bit 설치하기 " }, { "title": "[Error] Python - 오류 / SyntaxError: Non-ASCII character 'ì' in file ~", "url": "/posts/syntaxerror/", "categories": "Etc, Errors", "tags": "Python, error", "date": "2021-10-18 00:00:00 +0900", "snippet": "오류 메세지File \"~.py\", line 11SyntaxError: Non-ASCII character '\\xec\\ in file ~.py on line 11, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details원인Python이 주석에 사용된 한글 문자의 인코딩을 이해할 수 없어서 발생한 것으로 판단 중.해결 방법1. 스크립트에 한글 지원 인코딩 선언해준다.# -*- coding: utf-8 -*-또는# -*- coding: euc-kr -*-두 가지 중에 하나를 스크립트의 맨 위에 선언 해주면 된다고 한다.2. 한글 문자를 영어로 다 바꿔준다.이건 필살기. ㅋ.ㅋ" }, { "title": "[ROS] rosbridge, roslibjs 활용한 ROS 웹 연동", "url": "/posts/03-ros/", "categories": "Study, ROS", "tags": "ROS, roslibjs, ubuntu, Robot", "date": "2021-10-18 00:00:00 +0900", "snippet": " rosbridge 설치와 local에서의 실행 실제 환경 실행 roslibjs1. rosbridge설치와 local에서의 실행rosbridge는 ROS와 JSON 형식으로 통신을 하는 패키지다.rosbridge를 통해 우리는 java, javascript, python을 사용하는 클라이언트와 통신이 가능하게 된다.javascript와 같이 사용하여 AI 교육과정 최종 프로젝트의 웹 서비스 구현에 사용하려 한다.$ sudo apt-get install ros-melodic-rosbridge-suite설치가 완료되면 다음 명령으로 웹소켓 서버가 돌아가는지 확인한다. roscore 실행은 필수다.$ roslaunch rosbridge_server rosbridge_websocket.launch콘솔로그의 마지막 라인의 Rosbridge WebSocket server started at ws://0.0.0.0:9090을 통해 웹소켓 서버가 시작되었음을 알 수 있다.0.0.0.0:9090 으로 접속하여 다음과 같은 화면이 나오면 성공적으로 웹소켓 서버가 시작된 것이다.실제 환경 실행앞선 상황은 웹소켓 서버가 localhost:9090 포트로 제공되기 때문에, 실제 환경에서는 roscore를 실행하는 환경의 ip로 맞춰 주어야한다.$ roslaunch rosbridge_server rosbridge_websocket.launch address:={프록시의 ip}2. roslibjsROS 웹 통신을 위한 자바스크립트 라이브러리.$ git clone https://github.com/RobotWebTools/roslibjs이를 바탕으로한 ros2djs, nav2djs 등의 패키지가 존재한다.참고ros 공식 wiki 주소: http://wiki.ros.org/ROSRobotwebtools (roslibjs 등 제공) 주소: http://robotwebtools.org/roslibjs 공식 wiki 주소: http://wiki.ros.org/roslibjs 깃허브: https://github.com/RobotWebTools/roslibjs" }, { "title": "[ROS] 이기종 디바이스 통신 설정 (PC - turtlebot3)", "url": "/posts/02-ros/", "categories": "Study, ROS", "tags": "ROS, ubuntu, Robot", "date": "2021-10-17 00:00:00 +0900", "snippet": " JetPack ROS Melodic 설치 PC 세팅 PC에 터틀봇 패키지 설치 터틀봇 세팅 OpenCR SETUP OpenCR 터틀봇 펌웨어 세팅 환경변수 세팅 PC bashrc Turtlebot bashrc 이기종 통신이 아닐 때 편의를 위한 alias 등록 전체 코드 PC에 ROS Melodic 설치부터 터틀봇에 ROS Melodic 설치부터 PC &gt; Ubuntu 18.04 설치 / ROS Melodic 설치Turtlebot3 &gt; Ubuntu 18.04 설치 / ROS Melodic 설치 / PC와 동일 네트워크 / ssh 원격접속 가능여부 / PC와 Time 동기화 / 인터넷 가능1. JetPackNvidia JetPack SDK는 End-to-End AI Application 빌드를 위해 제공되고,Ubuntu OS, CUDA, cuDNN, OpenCV 등이 Jetson 모듈에 맞게 최적화 되어있다.우리 프로젝트에서는 Jetson Nano를 사용하였기 때문에 JetPack을 설치하고,그 위에 ROS를 설치하였다. Nvidia JetPack SDK 주소: https://developer.nvidia.com/embedded/jetpack2. ROS Melodic 설치Ubuntu 18.04 LTS 버전에 호환되는 ROS는 Melodic Morenia 버전이다.$ sudo apt-get install -y chrony ntpdate$ sudo ntpdate -q ntp.ubuntu.com$ sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list'$ sudo apt install curl$ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -$ sudo apt update$ sudo apt install ros-melodic-desktop-full$ sudo apt-get install python-pip$ echo \"source /opt/ros/melodic/setup.bash\" &gt;&gt; ~/.bashrc$ source ~/.bashrc$ sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential$ sudo rosdep init$ rosdep update3. PC 세팅$ sudo apt-get install ros-melodic-joy ros-melodic-teleop-twist-joy ros-melodic-teleop-twist-keyboard ros-melodic-laser-proc ros-melodic-rgbd-launch ros-melodic-depthimage-to-laserscan ros-melodic-rosserial-arduino ros-melodic-rosserial-python ros-melodic-rosserial-server ros-melodic-rosserial-client ros-melodic-rosserial-msgs ros-melodic-amcl ros-melodic-map-server ros-melodic-move-base ros-melodic-urdf ros-melodic-xacro ros-melodic-compressed-image-transport ros-melodic-rqt-image-view ros-melodic-gmapping ros-melodic-navigation ros-melodic-interactive-markersPC에 터틀봇 패키지 설치$ mkdir -p ~/turtlebot3/src &amp;&amp; cd ~/turtlebot3/src$ git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3.git$ git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git$ catkin_init_workspace &amp;&amp; cd .. &amp;&amp; catkin_make Python 3 users in ROS Melodic and earlier: note, if you are building ROS from source to achieve Python 3 compatibility, and have setup your system appropriately (ie: have the Python 3 versions of all the required ROS Python packages installed, such as catkin) the first catkin_make command in a clean catkin workspace must be:catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 This will configure catkin_make with Python 3. You may then proceed to use just catkin_make for subsequent builds.4. 터틀봇 세팅$ mkdir -p ~/catkin_ws/src &amp;&amp; cd ~/catkin_ws/src$ git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3.git$ git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git$ git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/hls_lfcd_lds_driver.git$ sudo apt-get install ros-melodic-rosserial-python ros-melodic-tf$ catkin_init_workspace &amp;&amp; cd .. &amp;&amp; catkin_makeOpenCR SETUProscore 실행 후 다른 터미널에서 다음 실행 후 roscore 종료$ source ~/catkin_ws/devel/setup.bash$ rosrun turtlebot3_bringup create_udev_rules 루트 권한 없이 OpenCR 용 USB 포트를 사용할 수 있도록 설정OpenCR 터틀봇 펌웨어 세팅$ export OPENCR_PORT=/dev/ttyACM0$ export OPENCR_MODEL=burger$ rm -rf ./opencr_update.tar.bz2$ wget https://github.com/ROBOTIS-GIT/OpenCR-Binaries/raw/master/turtlebot3/ROS1/latest/opencr_update.tar.bz2 &amp;&amp; tar -xvf opencr_update.tar.bz2 &amp;&amp; cd ./opencr_update./update.sh $OPENCR_PORT $OPENCR_MODEL.opencr 오류가 발생한다면 터틀봇은 amr 아키텍처이고 스크립트에서 x86 아키텍처의 스크립트를 실행하려 하므로 강제로 스크립트를 수정해주는 방법을 사용할 수 있겠다. nano, vim, gedit 등을 활용하자. shell_cmd=\"\" 밑에 라인의 else 부분을 수정하면 된다. \"./opencr_ld_shell_x86\"을 \"./opencr_ld_shell_arm\"으로 수정하자.이후에도 에러가 발생하면 OpenCR 보드를 recovery mode로 진입하자. (사진추가예정) 5. 환경변수 세팅gedit .bashrc 등의 명령어를 통해 .bashrc를 수정하자.MASTER PC의 IP는 양쪽에 ROS_MASTER_URI에 언급된다.PC bashrc# Set ROS Melodicsource /opt/ros/melodic/setup.bash# Set Ros Networkexport ROS_MASTER_URI=http://{PC_IP}:11311export ROS_HOSTNAME={PC_IP}# Set TURTLEBOT3 MODELexport TURTLEBOT3_MODEL=burgerTurtlebot bashrc# Set ROS Melodicsource /opt/ros/melodic/setup.bashsource ~/catkin_ws/devel/setup.bash# Set Ros Networkexport ROS_MASTER_URI=http://{PC_IP}:11311export ROS_HOSTNAME={Turtlebot_IP}# Set TURTLEBOT3 MODELexport TURTLEBOT3_MODEL=burger이기종 통신이 아닐 때# Set Ros Networkexport ROS_HOSTNAME=localhostexport ROS_MASTER_URI=http://localhost:11311# Set TURTLEBOT3 MODELexport TURTLEBOT3_MODEL=burger편의를 위한 alias 등록# Set ROS alias commandalias cw='cd ~/catkin_ws'alias cs='cd ~/catkin_ws/src'alias cm='cd ~/catkin_ws &amp;&amp; catkin_make'IP 확인ifconfig 명령어로 확인 가능설치 명령어 sudo apt-get install net-tools6. 전체 코드 (복붙 비추천)PC에 ROS Melodic 설치부터$ sudo apt-get install -y chrony ntpdate &amp;&amp; sudo ntpdate -q ntp.ubuntu.com &amp;&amp; sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list' &amp;&amp; sudo apt install -y curl &amp;&amp; curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - &amp;&amp; sudo apt update &amp;&amp; sudo apt install -y ros-melodic-desktop-full &amp;&amp; sudo apt-get install -y python-pip &amp;&amp; echo \"source /opt/ros/melodic/setup.bash\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc &amp;&amp; sudo apt install -y python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential &amp;&amp; sudo rosdep init &amp;&amp; rosdep update &amp;&amp; sudo apt-get install -y ros-melodic-joy ros-melodic-teleop-twist-joy ros-melodic-teleop-twist-keyboard ros-melodic-laser-proc ros-melodic-rgbd-launch ros-melodic-depthimage-to-laserscan ros-melodic-rosserial-arduino ros-melodic-rosserial-python ros-melodic-rosserial-server ros-melodic-rosserial-client ros-melodic-rosserial-msgs ros-melodic-amcl ros-melodic-map-server ros-melodic-move-base ros-melodic-urdf ros-melodic-xacro ros-melodic-compressed-image-transport ros-melodic-rqt-image-view ros-melodic-gmapping ros-melodic-navigation ros-melodic-interactive-markers &amp;&amp; mkdir -p ~/turtlebot3/src &amp;&amp; cd ~/turtlebot3/src &amp;&amp; git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3.git &amp;&amp; git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git &amp;&amp; catkin_init_workspace &amp;&amp; cd .. &amp;&amp; catkin_make터틀봇에 ROS Melodic 설치부터$ sudo apt-get install -y chrony ntpdate &amp;&amp; sudo ntpdate -q ntp.ubuntu.com &amp;&amp; sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list' &amp;&amp; sudo apt install -y curl &amp;&amp; curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - &amp;&amp; sudo apt update &amp;&amp; sudo apt install -y ros-melodic-desktop-full &amp;&amp; sudo apt-get install -y python-pip &amp;&amp; echo \"source /opt/ros/melodic/setup.bash\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc &amp;&amp; sudo apt install -y python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential &amp;&amp; sudo rosdep init &amp;&amp; rosdep update &amp;&amp; mkdir -p ~/catkin_ws/src &amp;&amp; cd ~/catkin_ws/src &amp;&amp; git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3.git &amp;&amp; git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git &amp;&amp; git clone -b melodic-devel --single-branch https://github.com/ROBOTIS-GIT/hls_lfcd_lds_driver.git &amp;&amp; sudo apt-get install -y ros-melodic-rosserial-python ros-melodic-tf net-tools terminator &amp;&amp; catkin_init_workspace &amp;&amp; cd .. &amp;&amp; catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3이후 OpenCR SETUP 진행roscore 실행 후 다른 터미널에서 다음 실행 후 roscore 종료$ source ~/catkin_ws/devel/setup.bash$ rosrun turtlebot3_bringup create_udev_rules 루트 권한 없이 OpenCR 용 USB 포트를 사용할 수 있도록 설정환경 변수 세팅참고ros 공식 wiki 주소: http://wiki.ros.org/ROS“ROS 로봇 프로그래밍” - (루비페이퍼, 표윤석.조한철.정려운.임태훈 지음) 깃허브: http://github.com/ROBOTIS-GIT/ros_tutorials구선생 로보틱스 - 터틀봇 Ubuntu18.04에서 구동될까?Nvidia JetPack SDK 주소: https://developer.nvidia.com/embedded/jetpack" }, { "title": "[DL] 옵티마이저", "url": "/posts/04-dl/", "categories": "Study, AI", "tags": "AI, DeepLearning, TensorFlow, Keras, Python, Jupyter Notebook", "date": "2021-09-23 00:00:00 +0900", "snippet": "본 포스팅은 “케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김)을 바탕으로 공부한 내용을 정리한 것입니다. 텐서와 층 예시 배치 데이터 텐서 계산 브로드캐스팅 브로드캐스팅 예시 그래디언트 기반 최적화이전 포스팅 1, 이전 포스팅 2과 함께 보자.MNIST 손글씨 예제에서 데이터셋 적재, 신경망 생성을 거치고 컴파일, 모델 학습의 차례이다.신경망 생성 시 층의 선택 방법에 대해, 배치가 무엇인지 간략하게 서술하고, 옵티마이저 정리들어가고 다음 포스팅.1. 텐서와 층 예시텐서플로우는 channel-last 방식, 씨아노는 channel-first 방식 벡터 데이터: (samples, features) 크기의 2D 텐서 나이, 우편번호, 소득으로 구성된 10만명의 인구 통계 데이터셋은 (100000, 3) 크기의 텐서에 저장 (단어 2만개로 만든 사전에서) 각 단어가 등장한 횟수로 표현된 500개 문서의 데이터셋은 (500, 20000) 완전 연결 층 (fully connected layer), 밀집 층 (dense layer), 밀집 연결 층 (densley connected layer) 시계열, 시퀀스 (sequence) 데이터: (samples, timesteps, features) 크기의 3D 텐서 1분마다 현재 주식 가격, 최고와 최소 가격을 저장한 250일 치의 데이터는 (250, 390, 3) 미국 증권 거래소 개장시간 09:30 ~ 16:00로 390분 128개의 알파벳으로 구성된 280개의 문자 시퀀스인 100만개의 트윗 데이터셋은 (1000000, 280, 128) LSTM 같은 순환 층 (recurrent layer) 이미지: (samples, height, width, channels) 또는 (samples, channels, height, width) 4D 텐서 256x256 크기 흑백 이미지에 대한 128개의 배치는 (128, 256, 256, 1) 256x256 크기 컬러 이미지에 대한 128개의 배치는 (128, 256, 256, 3) 2D 합성곱 층 (convolution layer) 동영상: (samples, frames, height, width, channels) 또는 (samples, frames, channels, height, width) 5D 텐서 60초 144x256 비디오를 초당 4프레임 샘플링 (총 240 프레임), 비디오 4개 가진 배치는 (4, 240, 144, 256, 3) 배치 데이터일반적으로 딥러닝에서 사용하는 모든 데이터 텐서의 0번째 축은 샘플 축, 샘플 차원 (sample axis, dimension)이라 부른다.딥러닝 모델은 한번엔 전체 데이터셋을 처리하지 않고, 작은 배치 (batch)로 나눈다.배치 데이터를 다룰 때는 0번 축을 배치 축, 배치 차원 (batch axis, dimension)이라 부른다.2. 텐서 계산브로드캐스팅크기가 다른 두 텐서가 더해질 때, 작은 텐서가 큰 텐서의 크기에 맞추어 브로드캐스팅 (broadcasting)이 된다. 큰 텐서의 ndim에 맞게 작은 텐서에 브로드캐스팅 축이 추가된다. 작은 텐서가 새 축을 따라서 큰 텐서의 크기에 맞도록 반복된다.브로드캐스팅 예시X의 크기는 (32,10)이고 y는 (10,)이라 할때 y에 비어 있는 첫 번째 축을 추가하여 크기를 (1,10)으로 만든다.이 y를 이 축에 32번 반복하면 Y의 크기는 (32,10)구현 입장에서는 새로운 텐서가 만들어지면 비효율적이므로반복되는 연산은 가상으로, 알고리즘 수준으로 일어난다. 새로운 축을 따라 반복된다고 생각하는 것이 이해하기 쉽다고 한다.3. 그래디언트 기반 최적화그래디언트는 텐서 연산의 변화율이다.확률적 경사 하강법 (SGD, Stochastic Gradient Descent)미분 가능한 함수가 주어지면, 최솟값을 변화율이 0인 지점이라고 해석적으로 구할 수 있다.변화율이 0이 되는 지점을 모두 찾고 어떤 함수 값이 가장 작은지 확인할 때, 실제 신경망에서는 파라미터 개수가 매우 많기에 이 과정이 어렵다.미니 배치 확률적 경사 하강법 (mini-batch SGD)로 파라미터를 수정하며 손실을 감소시켜 나간다. 훈련 샘플 배치 x와 이에 상응하는 타깃 y를 추출 x로 네트워크를 실행하고 예측 y_pred를 구함 이 배치에서 y_pred와 y 사이의 오차를 측정, 네트워크 손실 계산 네트워크 파라미터에 대한 손실 함수의 그래디언트 계산 (역방향 패스 (backward pass)) 그래디언트 반대 방향으로 파라미터 조금 이동step 값이 너무 작으면 지역 최솟값에 갇힐 수도, 너무 많은 반복이 필요할 수도 있다.너무 크면 손실 함수 곡선에서 완전히 임의의 위치로 이동할 수 있다.업데이트된 사중치를 고려하는 Adagrad, RMSProp 등의 SGD 변종들이 있다.이런 변종들을 최적화 방법 (optimization method) 또는 옵티마이저라 부른다.모멘텀 (momentum) 개념을 통해 수렴 속도와 지역 최솟값 문제를 해결한다. 요약을 하자면 학습은 손실 함수 최소화하는 모델 파라미터 조합을 찾는 것. 전체 학습 과정은 신경망이 미분 가능한 텐서 연산으로 연결되어서 가능하다. 현재 파라미터와 배치 데이터를 그래디언트 값에 매핑 해주는 그래디언트 함수를 구성하기 위해 미분의 연쇄 법칙 사용. 손실과 옵티마이저는 네트워크에 데이터 주입전에 정의되야함. 옵티마이저는 손실에 대한 그래디언트가 파라미터를 업데이트하는 방식. 손실은 훈련하는 동안 최소화해야할 양, 문제 해결의 성공을 측정.4. 손실 함수 (loss function)목적 함수 (objective function)으로도 불린다. 훈련동안 최소화될 값이며 성공 지표다.여러 출력을 내는 신경망은 출력당 하나씩, 여러 손실 함수를 가질 수 있다.경사 하강법 과정은 하나의 스칼라 손실 값을 기준으로 하기 때문에, 모든 손실의 평균을 내서 하나의 스칼라 양으로 합쳐서 진행하게 된다.손실 함수 선택 지침분류, 회귀, 시퀀스 예측 같은 일반적인 문제에서는 올바른 손실 함수를 선택하는 지침이 있다고 한다. 2개의 클래스가 있는 분류 문제: 이진 크로스엔트로피 (binary crossentropy) 여러개의 클래스가 있는 분류 문제: 범주형 크로스엔트로피 (categorical crossentropy) 회귀 문제: 평균 제곱 오차 (MSE) 시퀀스 학습 문제: CTC (Connection Temporal Classification)일반적인 간단화한 지침이라 하여, 공부를 진행하며 업데이트 해가거나, 따로 게시글을 작성할 예정이다.참고“케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김) 깃허브: http://github.com/gilbutITbook/006975 길벗출판사 홈페이지: http://www.gilbut.co.kr tensorflow 2.4 버전 코드 https://github.com/rickiepark/deep-learning-with-python-notebooks/tree/tf2" }, { "title": "[DL] 활성화 함수", "url": "/posts/03-dl/", "categories": "Study, AI", "tags": "AI, DeepLearning, TensorFlow, Keras, Python, Jupyter Notebook", "date": "2021-09-21 00:00:00 +0900", "snippet": "본 포스팅은 “케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김)을 바탕으로 공부한 내용을 정리한 것입니다. 신경망 구조 활성화 함수 Sigmoid 함수 Tanh 함수 ReLU (Rectified Linear Unit) 함수 Leaky ReLU PReLU ELU (Exponential Linear Unit) Maxout 이전 포스팅과 함께 보자.1. 신경망 구조from tensorflow.keras import modelsfrom tensorflow.keras import layersnetwork = models.Sequential()network.add(layers.Dense(512, activation='relu', input_shape=(28 * 28,)))network.add(layers.Dense(10, activation='softmax'))신경망의 핵심 구성 요소는 층 (layer)다. 여과기 같은 일종의 데이터 처리 필터라고도 생각 할 수 있다.완전 연결 (fully connected)된 신경망 층인 Dense 층 2개가 연속되어 있다.마지막 층은 소프트맥스 (softmax) 층이다.2. 활성화 함수첫 번째 층의 활성화 함수로 relu 함수가 사용되었다.비선형 함수를 사용하여 딥러닝 모델의 레이어를 깊게 가져갈 수 있다고 한다.대표적으로 사용되는 활성화 함수는 다음과 같다. (미분 결과는 생략한다)Sigmoid 함수\\[sigmoid(x) = \\frac{1}{1+e^{-x}}\\]Logistic 함수라고 불리기도 한다. $x$의 값에 따라 0 ~ 1의 값을 출력한다.Gradient Vanishing 현상, 함수값 중심이 0 이 아닌 $1 \\over 2$, $\\exp$ 함수 사용 등의 단점Tanh 함수\\[tanh(x) = \\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}\\]\\[tanh(x) = 2 \\sigma (2x) - 1\\]$\\sigma$는 sigmoid 함수이다.중심값이 0이 되어 sigmoid의 최적화 과정이 느려지는 문제는 해결.여전히 남아있는 Gradient Vanishing의 단점ReLU (Rectified Linear Unit) 함수\\[f(x) = max(0,x)\\]sigmoid, tanh 보다 빠른학습, $x &lt; 0$에서 뉴런이 죽을 수 있는 단점Leaky ReLU\\[f(x) = max(0.01x,x)\\]ReLU 함수의 뉴런이 죽는 현상 (Dying ReLU)을 해결하기 위해 등장. 0.01 대신 다른 매우 작은 값을 사용 가능PReLU\\[f(x) = max(\\alpha x,x)\\]Leaky ReLU와 유사하지만 $\\alpha$로 $x &lt; 0$에서 기울기를 학습 가능ELU (Exponential Linear Unit)\\[f(x) = \\begin{cases} x \\;\\qquad\\qquad\\; x&gt;0\\\\ \\alpha (e^{x}-1) \\quad\\; x \\leq 0\\end{cases}\\]ReLU의 모든 장점을 포함, Dying ReLU 해결, 출력값의 중앙값이 0에 근사$x \\leq 0$에서 $\\exp$ 함수 계산하는 비용이 발생Maxout\\[f(x) = max(\\omega_{1}^{T} x + b_{1}, \\omega_{2}^{T} x + b+{2})\\]여러개의 선형 함수 중 최댓값을 출력하는 함수ReLU의 장점들과 Dying ReLU 해결. 계산량이 복잡하다는 단점 간단하고 빠른 편인 ReLU를 먼저 사용하고 Leakly ReLU, PReLU, ELU 등도 사용해본다. simoid와 tanh는 지양 deeesp 님의 포스팅에 총 22개의 다른 활성화 함수들에 대해서도 자세히 설명이 나와있다.참고 HDLY 님의 포스팅딥러닝 - 활성화 함수(Activation) 종류 및 비교 reniew 님의 포스팅딥러닝에서 사용하는 활성화함수 deeesp 님의 포스팅[DL] Activation Functions (활성화 함수) “케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김) 깃허브: http://github.com/gilbutITbook/006975 길벗출판사 홈페이지: http://www.gilbut.co.kr tensorflow 2.4 버전 코드 https://github.com/rickiepark/deep-learning-with-python-notebooks/tree/tf2" }, { "title": "[DL]] MNIST 손글씨 숫자 분류 문제", "url": "/posts/02-dl/", "categories": "Study, AI", "tags": "AI, DeepLearning, TensorFlow, Keras, Python, Jupyter Notebook", "date": "2021-09-20 00:00:00 +0900", "snippet": "본 포스팅은 “케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김)을 바탕으로 공부한 내용을 정리한 것입니다. MNIST 손글씨 데이터 손글씨 분류 문제 케라스에 데이터셋 적재 신경망 구조 컴파일 이미지 데이터 준비 레이블 준비 모델 학습 테스트 세트에서 모델 적용 1. MNIST 손글씨 데이터흑백 손글씨 숫자 이미지 (28 X 28 픽셀)을 10개의 범주 (0~9)로 분류하는 문제.6만 개의 훈련 이미지와 1만 개의 테스트 이미지로 구성 되어 있다. train과 test 비율은 보통 6:1, 6:2, 7:1 등으로 사용한다. 여기서는 6:1이 되겠다. MNIST 문제는 딥러닝계의 “hello world”라고 한다.2. 손글씨 분류 문제케라스에 데이터셋 적재from tensorflow.keras.datasets import mnist(train_images, train_labels), (test_images, test_labels) = mnist.load_data()MNIST 데이터셋은 Numpy 배열 형태로 케라스에 이미 포함되어 있어서 import 해준다.train_images와 train_labels가 모델이 학습해야 할 훈련 세트 (training set)를 구성한다.모델은 test_images와 test_labels로 구성된 테스트 세트 (test set)에서 테스트 된다.이미지는 Numpy 배열로 인코딩되어 있고, 레이블은 0 ~ 9의 숫자 배열이다.이미지와 레이블은 일대일 관계이다.다음은 훈련 데이터를 살펴보는 과정이다. 정돈된 데이터의 실제 학습에는 필요없지만, 공부를 위해 구조를 확인하는 과정이다.train_images.shapelen(train_labels)train_labels[결과](60000, 28, 28)60000array([5, 0, 4, ..., 5, 6, 8], dtype=uint8)unit 8 타입의 (60000, 28, 28) 크기의 [0, 255] 사이의 값을 가지는 배열임을 확인할 수 있다.다음은 테스트 데이터이다.test_images.shapelen(test_labels)test_labels[결과](10000, 28, 28)10000array([7, 2, 1, ..., 4, 5, 6], dtype=uint8)테스트 데이터는 unit 8 타입의 (10000, 28, 28) 크기의 [0, 255] 사이의 값을 가지는 배열이다.다섯 번째 train_images를 matplotlib 라이브러리로 확인해보자.import matplotlib.pyplot as pltdigit = train_images[4]plt.imshow(digit, cmap=plt.cm.binary)plt.show()작업 순서는 다음과 같다.훈련 데이터 train_images와 train_labels를 네트워크에 주입시켜서 이미지와 레이블을 연관시킬 수 있도록 학습된다.test_images에 대한 예측을 네트워크에 요청하면 이 예측이 test_labels와 맞는지 확인을 할 것이다.다음으로는 신경망을 생성한다.신경망 구조from tensorflow.keras import modelsfrom tensorflow.keras import layersnetwork = models.Sequential()network.add(layers.Dense(512, activation='relu', input_shape=(28 * 28,)))network.add(layers.Dense(10, activation='softmax'))신경망의 핵심 구성 요소는 층 (layer)다. 여과기 같은 일종의 데이터 처리 필터라고도 생각 할 수 있다.완전 연결 (fully connected)된 신경망 층인 Dense 층 2개가 연속되어 있다.마지막 층은 소프트맥스 (softmax) 층이다.10개의 확률 점수가 들어 있는 배열로, 모두 더하면 1이다.즉, 각 점수는 현재 숫자 이미지가 0 ~ 9의 숫자 중 하나에 속할 확률이다.첫 번째 층의 활성화 함수로 relu 함수가 사용되었다.비선형 함수를 사용하여 딥러닝 모델의 레이어를 깊게 가져갈 수 있다고 한다.대표적으로 사용되는 활성화 함수는 다음과 같다. Sigmoid 함수 Tanh 함수 ReLU (Rectified Linear Unit) 함수 Leaky ReLU PReLU ELU (Exponential Linear Unit) Maxout 간단하고 빠른 편인 ReLU를 먼저 사용하고 Leakly ReLU, PReLU, ELU 등도 사용해본다. simoid와 tanh는 지양신경망이 훈련 준비를 마치기 위한 컴파일 단계에 포함되기 위해 세가지가 더 필요하다. 손실함수 (loss function) 옵티마이저 (optimizer) 훈련과 테스트 과정을 모니터링 할 지표 (해당 예제에서는 정확도만)컴파일network.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])손실함수와 옵티마이저에 대해서는 다다음 포스팅에서 자세하게 작성 예정이다.이미지 데이터 준비train_images = train_images.reshape((60000, 28 * 28))train_images = train_images.astype('float32') / 255test_images = test_images.reshape((10000, 28 * 28))test_images = test_images.astype('float32') / 255훈련에 앞서, 데이터를 네트워크에 맞는 크기로 reshape하고 모든 값을 0 ~ 1로 스케일링 한다.이미지의 경우 일반적으로 픽셀의 최댓값인 255로 나눈다고 한다.레이블 준비from tensorflow.keras.utils import to_categoricaltrain_labels = to_categorical(train_labels)test_labels = to_categorical(test_labels)레이블을 범주형으로 인코딩 해주었다.모델 학습network.fit(train_images, train_labels, epochs=5, batch_size=128)훈련 과정동안 손실 (loss)와 정확도 (accuracy)가 출력되었다.훈련 데이터에 대해 0.989(98.9%)의 정확도를 금방 달성했다.epochs, batch_size는 다다음 포스팅에 작성 예정 중이다.테스트 세트에서 모델 적용test_loss, test_acc = network.evaluate(test_images, test_labels)print('test_acc:', test_acc)훈련 세트의 정확도보다 낮은 테스트 세트의 97.8%는 과대적합 (overfitting)의 이유이다.머신 러닝 모델이 훈련 데이터보다 새로운 데이터에서 성능이 낮아지는 경향을 뜻한다.참고“케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김) 깃허브: http://github.com/gilbutITbook/006975 길벗출판사 홈페이지: http://www.gilbut.co.kr tensorflow 2.4 버전 코드 https://github.com/rickiepark/deep-learning-with-python-notebooks/tree/tf2" }, { "title": "[ML] Numpy 인덱싱 (수정중)", "url": "/posts/05-ml/", "categories": "Study, AI", "tags": "AI, MachineLearning, Anaconda, Jupyter Notebook", "date": "2021-09-15 00:00:00 +0900", "snippet": "본 포스팅은 “파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 단일 값 추출 슬라이싱 팬시 인덱싱 불린 인덱싱 1. 단일 값 추출원하는 위치의 인덱스 값을 지정하면 해당 위치의 데이터가 반환.ndarray[n]이면 n+1번째 array의 index 위치의 데이터값을2차원에서는 ndarray[n,m]이면 n+1번째 row, m+1번째 column 이런식으루2. 슬라이싱ndarray[0:n]이면 0번째 인덱스부터 n-1번째 인덱스까지 추출2차원에서는 단일값추출과 유사하게 row, col 각각의 인덱스에 슬라이싱 적용ndarray[1:n, :] 이런식으루3. 팬시 인덱싱 (Fancy Indexing)참고“파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음) 깃허브: https://github.com/wikibook/pymldg-rev" }, { "title": "[ML] Numpy 기본적인 메서드", "url": "/posts/04-ml/", "categories": "Study, AI", "tags": "AI, MachineLearning, Anaconda, Jupyter Notebook", "date": "2021-09-15 00:00:00 +0900", "snippet": "본 포스팅은 “파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음)을 바탕으로 공부한 내용을 정리한 것입니다. ndarray의 데이터 타입 arange, zeros, ones reshape1. ndarray의 데이터 타입ndarray 내의 데이터 타입은 연산의 특성상 같은 데이터 타입만 가능하다.dtype 속성으로 확인이 가능하다.list1 = [1, 2, 3]print(tpye(list1))array1 = np.array(list1)print(type(array1))print(array1, array1.dtype)[결과]&lt;class 'list&gt;&lt;class 'numpy.ndarray'&gt;[1 2 3] int32다른 데이터 유형이 섞여있는 리스트를 ndarray로 변경하면 데이터 크기가 더 큰 데이터 타입으로 형 변환을 일괄 적용한다.list2 = [1, 2, 'test']array2 = np.array(list2)print(array, array2.dtype)list3 = [1, 2, 3.0]array3 = np.array(list3)print(array3, array3.dtype)[결과]&lt;class 'numpy.ndarray'&gt;['1' '2' 'test'] &lt;U11[1. 2. 3.] float64ndarray 내 데이터 타입 변경은 astype() 메서드를 이용 메모리로 데이터를 전체 로딩한 다음 알고리즘을 적용하는 파이썬 기반 머신러닝 알고리즘 특성상메모리 절약을 위해 사용되곤 한다.array_int = np.array([1, 2, 3])array_float = array_int.astype('float63)prin(array_float, array_float.dtype)[결과][1. 2. 3.] float642. arange, zeros, ones테스트용 데이터, 연속값, 0과 1로 초기화 등의 상황에서 사용하는arrange(), zeros(), ones()sequence_array = np.arnage(10)print(sequence_array, sequence_array.dtype, sequence_array.shape)zero_array = np.zeros((3,2), dtype='int32)print(zero_array, zero_array.dtype, zero_array.shape)one_array = np.ones((3,2))print(one_array, one_array.dtype, one_array.shape)[결과][0 1 2 3 4 5 6 7 8 9]int32 (10,)[[0 0] [0 0] [0 0]]int32 (3,2)[[1. 1.] [1. 1.] [1. 1.]]float64 (3,2)3. reshapendarray를 특정 차원 및 크기로 변환하는 reshape()-1을 인자로 사용하면 호환되는 새로운 shape로 변환해준다.array1 = np.arange(10)array2 = array1.reshape(-1,5)array3 = array1.reshape(5,-1)print(array1, 'array2 shape:', array2.shape, 'array3 shape:', array3.shape)[결과][0 1 2 3 4 5 6 7 8 9]array2 shape: (2,5)array3 shape: (5,2)보통 reshape(-1,1)의 형태로 자주 사용한다. 어떤 형태라도 2차원으로 변환한다.참고“파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음) 깃허브: https://github.com/wikibook/pymldg-rev" }, { "title": "[ME] 트랙별 설계 프로젝트, 독서대 내장 책상", "url": "/posts/01-track/", "categories": "Project, Mechanical Engineering", "tags": "Mechanical Engineering, project", "date": "2021-09-02 00:00:00 +0900", "snippet": "본 포스팅은 2020년 진행한 동국대학교 기계로봇에너지 공학과 트랙별 설계 프로젝트 5조 자료입니다.저희 조의 주제는 수험생을 위한 독서대 내장 책상 설계입니다.PPT 및 프로젝트 설명 포함된 Microsoft Office 프레젠테이션, 제공: Office 프로젝트 요약 느낀점주제 선정부터 구동 방식 및 재료의 선정까지 전체적인 과정을 직접 진행하며 많은 것을 느꼈다.고체역학, 재료역학 , 기구학 , 동역학 등 학부 때 배운 기계공학 지식들과Working Model 2D, Creo Parametric, Ansys Workbench, Arduino, Matlab 등의 다양한 프로그램의 사용으로기능의 구현과 해석을 진행하며 역량을 끌어올릴 수 있어서 좋은 기회였다.프로젝트 진행 기간 2020년 9월 2일 요일 ~ 12월 4일 요일" }, { "title": "[ME] 소프트로보틱스, 인공근육로봇 설계 프로젝트", "url": "/posts/01-softrobotics/", "categories": "Project, Mechanical Engineering", "tags": "Mechanical Engineering, project", "date": "2021-09-02 00:00:00 +0900", "snippet": "본 포스팅은 2020년 진행한 동국대학교 기계로봇에너지 공학과 소프트로보틱스 4조 자료입니다.저희 조의 주제는 VAMPs 디자인을 차용한 인공근육로봇 설계입니다.PPT 및 프로젝트 설명 포함된 Microsoft Office 프레젠테이션, 제공: Office 소프트 로보틱스(Soft robotics)는 생물에서 발견되는 것과 비슷한, 강성이 높은 물질로 로봇을 구성하는 것과 관련한 로봇공학의 하위 분야이다. 소프트 로보틱스는 생물이 주변 환경에 움직여 순응하는 방법에 착안한다. 고체 물질로 만들어진 로봇과 달리 소프트 로봇은 태스크 달성을 위해 상당한 유연성과 순응성을 가능케 하며 인간 주변에서 작업을 할 때 개선된 안전성을 보여준다. 이러한 특징들로 말미암아 의학, 제조 분야에서 잠재적인 이용을 가능케 한다. 출처: 위키백과 프로젝트 요약 실습을 통해 직접 제작해본 소프트 로봇을 활용하여, 원하는 태스크를 달성할 수 있도록, 또는 방향성을 제시한다. 우리 팀은 다양한 소프트 로봇의 작동 원리를 참고하여 인공 근육으로서 동작할 수 있는 로봇을 제작하고자 하였다. 초기 구상단계에서는 유전탄성체 액츄에이터를 적층시켜 동작하는 형태를 생각했지만, 전력 공급의 문제로 변경하였다. 최종적으로 선택한 방안은, 공기의 이동을 통해 수축과 인장을 하는 구조체이다. 느낀점태어나서 처음으로 외국인 동료들과 진행한 프로젝트였고, 매우 생소한 학문이었다.물론 내 영어나 그 친구들의 영어나 비슷한 수준이었지만, 소통에 있어서 어려운 점도 있어서 아쉬웠다.이때 접한 소프트로봇의 주조 과정에서, 최근 유행하는 메타버스나 디지털트윈에 대해 많은 생각이 들었다.AI를 배워보고 싶다는 생각도 이쯤에 한 것 같다. 건조 시간마다 다른 저항능력을 데이터화 시키면 가장 최적의 형태와 방법을 알 수 있지 않을까.분명한 것은 매우 흥미로운 학문이라는 것과, 이를 같이 진행했던 내 친구들이 보고 싶다 ㅋㅋ. 코로나 끝나라. 레오랑 루카스가 나에게 군대에서 뭐하냐 했을 때, 탱크 옆에서 총쏘고 그랬다하면서 놀린게 제일 재밌었다.프로젝트 진행 기간 2020년 9월 9일 수요일 ~ 12월 11일 금요일" }, { "title": "[ME] 로봇동역학, Inverse-Pose Kinematics Matlab 프로그래밍 개발 프로젝트", "url": "/posts/01-robot_dynamics/", "categories": "Project, Mechanical Engineering", "tags": "Mechanical Engineering, project", "date": "2021-09-02 00:00:00 +0900", "snippet": "본 포스팅은 2020년 진행한 동국대학교 기계로봇에너지 공학과 로봇동역학 설계 자료입니다.주제는 Inverse-Pose Kinematics Matlab 프로그램 설계입니다.프로젝트 설명 프로젝트 요약 Matlab을 사용해서 주어진 상황에 대한 Inverse-Pose Kinematics 계산을 진행하도록 프로그래밍하는 과제였다. 진행한 결과를 Corke MATLAB Robotics Toolbox와의 비교도 진행했다. 느낀점생각해보면, 내가 지금 프로그래밍 관련하여 언어를 다룰 때 가지는 태도를 이때쯤부터 가진 것 같다.언어는 그저 표현하는 도구고, 뭐를 하고 싶은 건지를 먼저 머리로 알아야한다는 태도.당시에도 매트랩으로 내가 원하는 것을 표현하는 것 자체는 어렵지 않았다.무엇을 원하는 지를 머릿속에 정리하는데 시간이 가장 오래걸렸고 어려웠다.동역학적인 해석과 자코비안 변환 등의 과정.내가 앞으로 어느 방향으로 진로를 가질지, 일을 하면서도 모를텐데, 이때 얻은 태도는 분명히 도움이 될 것이다.프로젝트 진행 기간 2020년 5월 13일 수요일 ~ 6월 3일 수요일" }, { "title": "[ME] 에너지 응용 공학, 엔진 설계 프로젝트", "url": "/posts/01-energy/", "categories": "Project, Mechanical Engineering", "tags": "Mechanical Engineering, project", "date": "2021-09-02 00:00:00 +0900", "snippet": "본 포스팅은 2019년 진행한 동국대학교 기계로봇에너지 공학과 에너지 응용 공학 엔진 설계 프로젝트 자료입니다.주제는 4행정 배기량 5200cc 자동차 엔진 개략 설계입니다.프로젝트 설명 프로젝트 요약 엔진의 특성을 이해하여 엔진을 설계하고 실제 상용 화 된 차의 엔진들 중 하나와 비교하여 효율을 올릴 수 있는 방안을 토의한다. 또한 실린더 수, 보어와 행정, 압축비, 흡입 공기밀도, 공연비, 마찰계수의 인자들을 변화시켜 최고출력을 낼 수 있는 엔진을 설계한다. 느낀점가장 이상적인 상황으로 설계한 경우와 실제 상용 엔진을 비교해가며, 왜 회사는 이러한 선택을 했을까 고민했었다.그 선택의 과정이 회사에 들어가서 내가 배워가야할 점이겠지싶다. 실력을 길러서 나도 선택할 수 있는 위치에 있고 싶다.프로젝트 진행 기간 2019년 5월 15일 수요일 ~ 5월 29일 수요일" }, { "title": "[ME] 특화 설계, 낙상 방지 의자 설계 프로젝트", "url": "/posts/01-design/", "categories": "Project, Mechanical Engineering", "tags": "Mechanical Engineering, project", "date": "2021-09-02 00:00:00 +0900", "snippet": "본 포스팅은 2019년 진행한 동국대학교 기계로봇에너지 공학과 특화 설계 5조 자료입니다.저희 조의 주제는 낙상 방지 의자 설계입니다.PPT 및 프로젝트 설명 포함된 Microsoft Office 프레젠테이션, 제공: Office 프로젝트 요약 우리는 수업에서 배운 내용들을 통해 조원들이 주변에서 겪어온 문제점들을 보완 할 수 있도록 제품을 설계하고자 하였다. 브레인스토밍에서부터 많은 아이디어들이 쏟아져 나왔고, 이들 중 더욱 더 사회적으로 의의가 있는 아이템을 선정하도록 진행 하였다. 프로젝트 전체 주제는 요양병원 등에 노인분들의 낙상사고를 방지하기 위한 의자로 하였다. 주제가 정해지고는 단점 보완을 위해 디자인을 계속 수정했다. 디자인 과정의 응력 분석을 통해 경제적이면서 안정적인 설계를 하기 위해 노력했다. 브레인스토밍부터 시작해서, 시장조사, 2D, 3D 모델링, 각종 부품의 가격과 단가 측정을 통해 시장성 평가까지 진행했다. 느낀점태어나서 처음으로 논문을 찾아본게 이 때로 기억한다. 적절한 의자 안장의 각도를 정하기 위해 인체공학적 설계라는 단어에 꽂혔었다.참고할만한 문헌과 자료들이 매우 많아도, 우리에게 가장 맞는 적당한 자료를 선택하는 과정이 매우 즐겁고 어려웠다.공학도로서 모든 선택에 근거가 있어야한다는 마음가짐을 항상 가지고 있다.단순한 재료의 선택이라도, 어떤 분야의 일을 하더라도 남들을 설득할 수 있는 근거를 보여줄 수 있도록 실력을 기르고 싶다.아 그리고 진짜 옛날엔 보고서랑 피피티를 못 만들었구나 싶다 ㅋㅋ프로젝트 진행 기간 2019년 10월 27일 요일 ~ 12월 20일 요일" }, { "title": "[ME] CADCAM, 축구 로봇 역설계", "url": "/posts/01-cadcam/", "categories": "Project, Mechanical Engineering", "tags": "Mechanical Engineering, project", "date": "2021-09-02 00:00:00 +0900", "snippet": "본 포스팅은 2019년 진행한 동국대학교 기계로봇에너지 공학과 CAD/CAM 1,2조 자료입니다.주제는 유선 축구로봇을 3D 역설계 및 모델링입니다.PPT 및 프로젝트 설명 포함된 Microsoft Office 프레젠테이션, 제공: Office 프로젝트 요약 시중에 판매하는 축구 로봇을 치수 측정부터 시작하여 역설계의 과정, 각 부품의 3D 모델링, 어셈블리, 메커니즘과 도면 작업을 진행하고 우리 조의 상징물을 직접 3D 프린팅하여 마무리하는, Creo Parametric 사용 역량을 향상시킬 수 있는 팀 프로젝트였다. 느낀점각 부품의 치수를 팀원들이 나눠서 버니어캘리퍼스로 직접 측정하다보니, 후에 어셈블리 과정에서 간섭이 매우 많이 발견되었다.우리는 따로 방안을 찾지 못해서, 직접 모든 간섭을 잡아내는 과정을 가졌는데, 더 좋은 방법이 있을지 고민이 되었다. 지금에서야 드는 생각이지만, 단순히 직접 측정한 수치를 사용하지 않고, 역학적인 계산을 추가하여 임의로 수정하는 과정을 가졌으면 더 좋지 않았을까.. 우리 팀 모두 지금은 Ansys라던가 다른 프로그램들도 더 잘 다루고, git을 내가 이제는 사용할 수 있으니, 같이 버전 관리나 공유도 더 잘 될 것 같다..프로젝트 진행 기간 2019년 10월 22일 화요일 ~ 11월 25일 월요일" }, { "title": "[Tips] Ubuntu 20.04, Zoom 설치 ", "url": "/posts/zoom/", "categories": "Etc, Tips", "tags": "ubuntu, zoom", "date": "2021-08-28 00:00:00 +0900", "snippet": "1. 설치 파일 다운$ sudo wget https://zoom.us/client/latest/zoom_amd64.deb2. 설치 파일 실행$ sudo apt install ./zoom_amd64.deb참고 lunaticholic 님의 포스팅Ubuntu Zoom 설치" }, { "title": "[Tips] Ubuntu 20.04 / 18.04, VSCode 설치 ", "url": "/posts/vsc/", "categories": "Etc, Tips", "tags": "ubuntu, vsc, vscode, visual studio code", "date": "2021-08-28 00:00:00 +0900", "snippet": "1. curl 설치$ sudo apt-get install curl2. 마이크로소프트 GPG 키 다운, 경로 복사$ sudo sh -c 'curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; /etc/apt/trusted.gpg.d/microsoft.gpg'3. Visual Studio Code 다운 저장소 추가$ sudo sh -c 'echo \"deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\" &gt; /etc/apt/sources.list.d/vscode.list'4. 패키지 목록 가져오기$ sudo apt update5. Visual Studio Code 설치$ sudo apt install code6. 실행$ code참고 멈춤보단 천천히라도 님의 포스팅Visual Studio Code 설치하는 방법( Windows / Ubuntu )" }, { "title": "[Tips] Ubuntu terminator에서 ctrl + shift + e 가 안될 때 ", "url": "/posts/terminator/", "categories": "Etc, Tips", "tags": "ubuntu, terminator, ibus", "date": "2021-08-28 00:00:00 +0900", "snippet": "Terminatorros 구동은 기본적으로 터미널 창에서 이루어진다. 따라서 여러개의 터미널 창의 사용은 필수적.이에 나는 다중 터미널 창을 추천한다. 내가 사용하는 것은 terminator$ sudo apt-get install terminatorTerminator 주요 단축키 단축키 설명 사용법 터미네이터 실행 ctrl + alt + t 터미네이터 종료 ctrl + shift + q 수평 분할 ctrl + shift + o 수직 분할 ctrl + shift + e 분할 창 이동 ctrl + shift + p 분할 창 이동 (반대 방향) ctrl + shift + m 분할 창 종료 ctrl + shift + w 분할 창 확대 ctrl + shift + x 문제점Ctrl + Shift + E 가 작동을 안 할 때가 있다.원인키보드 세팅에 이미 Ctrl + Shift + E 가 있어서 생긴다.나의 경우엔 키보드 입력기가 ibus일 때, 이모지 단축키로 되어있었다.해결 방법ibus 세팅에 들어간다.$ ibus-setup에모지 주석을 삭제, 또는 변경 해주자.참고 snowdeer 님의 포스팅Ctrl + Shift + E 명령어가 안 먹히는 경우(Terminator)" }, { "title": "[Tips] Ubuntu 20.04 LTS에서 카카오톡 사용하기 ", "url": "/posts/kakao/", "categories": "Etc, Tips", "tags": "ubuntu, kakaotalk, wine", "date": "2021-08-28 00:00:00 +0900", "snippet": "카카오톡은 한국인의 필수템이다… 너무 편하다…우분투를 설치해도 나의 카톡은 막을 수 없다… Wine Wine 설치 Wine 설정 KakaoTalk 카카오톡 설치 카카오톡 언어 설정 키보드 세팅 트레이 추가 오류1. Wine카톡은 윈도우와 맥만 지원하기에 리눅스에서 사용할 수 없지만, 윈도우에서 WSL 사용하듯,리눅스에는 Wine이 있다.Wine 사용에 32bit 지원이 필수지만, 대부분이 64bit를 설치하므로, 32bit 활성화를 시켜준다.$ sudo dpkg --add-architecture i386Wine 설치$ sudo apt-get update$ wget -nc https://dl.winehq.org/wine-builds/winehq.key$ sudo apt-key add winehq.key$ sudo add-apt-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ focal main'$ sudo apt-get update$ sudo apt-get install --install-recommends winehq-stableWine 설정$ winecfg설치 관리자 창이 뜨면, Mono와 Gecko를 설치해주자.미설치시, 드롭다운을 포함한 어플들 창의 크기 등등… 오류가 많이 생긴다.설정창에서 다음과 같이 Windows 10으로 설정해준다.라이브러리는 d3dx11_43으로 설정하고 확인2. KakaoTalkhttps://www.kakaocorp.com/page/service/service/KakaoTalk 카카오톡 홈페이지에서 윈도우용 설치파일을 다운 받자.카카오톡 설치다음 명령어로 Wine에서 카카오톡 설치 파일을 실행하자.$ cd ~/Download$ LANG=\"ko_KR.UTF-8\" wine KakaoTalk_Setup.exe Ubuntu 설치 시 한글로 설치가 되었다면, 경로가 Download가 아닌 다운로드일수도 있다. 확인 잘할것~ 시작메뉴 바로가기와 Daum을 시작페이지로는 체크를 해제, 이유는 잘 모르겠다. 카카오톡 실행을 체크 해제하고 마침카카오톡 언어 설정바탕화면에 생긴 카카오톡.desktop을 우클릭하고 열어준다.다음과 같이 3번째 줄에 LANG=\"ko_KR.UTF-8\"를 추가하고 수정해준다.$ vi ~/.local/share/applications/wine/Programs/카카오톡/카카오톡.desktop 키보드 방향키를 움직여서 추가할 위치에서 i를 누르면 삽입이 되고, 다 작성하면 :wq로 저장하고 나갈 수 있다. 귀찮으면 vsc에 vim 편집 모듈 설치하는게완료하면 카카오톡.desktop을 우클릭하고 Allow Launching 클릭키보드 세팅Wine을 통해 카톡에서 한글을 입력할 때, ibus, uim 등등은 오류가 발생한다고 한다.fcitx를 설치하고 바꿔주자.$ sudo apt install fcitx-hangul설치 이후 설정 - 지역 및 언어에서 영어(미국)을 추가하고 다 지워주자.설치된 언어 관리 클릭, 키보드 입력기를 fcitx로 변경 후 닫기.[재부팅]재부팅 이후 우측 상단 키보드 모양 우클릭 - 설정입력기 설정 - 입력 방법 에서 + 버튼 누르고 Hangul 추가전역 설정에서 입력기 변환 설정, 한/영 키로 해주면 된다.전역 설정 하단의 추가 설정 보기 체크 - 모양새 에서 입력기 변경후 입력기 힌트 표시 옵션 해제부가기능 - Quickphrase - QuickPhrase에 대한 트리거 키 없음트레이 추가지금까지 작업으로는 카톡 실행마다 Wine System Tray가 실행되고 지저분, 귀찮,,$ sudo apt install gnome-tweak-tool$ sudo apt install gnome-shell-extension-top-icons-plus설치 후, tweaks 실행 - 확장 - Topicons plus 활성화오류오류 메세지RECV_SOCKET_ERROR(err_code=336130329) (오류코드:50114, FriendList)원인서버 장애, 불안정한 네트워크 환경, 방화벽에 의한 차단, 네트워크 관리자에 의한 강제 차단 등해결 방법나는 카톡 키고 끄고 반복하다 보니 됨..해결 방안들? $ sudo ufw enable$ sudo ufw allow 22/tcp$ sudo apt-get install ssh 라던가.. 뭐 많아보이긴하는데 걍 카톡 다시 키는걸… 반복..해보자…. 참고 딩온 님의 포스팅우분투 20.04/20.10 카카오톡 설치하기 딩온 님의 포스팅우분투 fcitx 입력기 설정하기 김두규 님의 포스팅【Ubuntu 20.04 LTS】Wine 설치 및 구성 김두규 님의 포스팅【Ubuntu 20.04 LTS】카카오톡 설치 by the bell 님의 포스팅 우분투 카카오톡 설치 (실시간) (설치성공) (2%부족) 리틀피그 님의 포스팅 Ubuntu 18.04 LTS 카카오톡 설치하기 해리팍 님의 포스팅 “[Ubuntu] Vi / Vim 에디터 명령어” 그루터기 님의 포스팅 vi편집기 사용법 " }, { "title": "[Ruby] Jekyll을 사용하여 블로그 만들기 03 (ubuntu)", "url": "/posts/03-jekyll-blog/", "categories": "Etc, Tips", "tags": "blog, portfolio, jekyll, chirpy, jekyll-chirpy, jekyll theme, 19tak", "date": "2021-08-27 00:00:00 +0900", "snippet": " [01] Jekyll을 사용하여 블로그 만들기 [02] Jekyll을 사용하여 블로그 만들기 (Chirpy 테마)터미널에서 아래의 과정을 따라오자.$ sudo apt-get update$ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt1-dev libcurl4-openssl-dev libffi-dev software-properties-common$ sudo apt install ruby-fullruby 설치까지 완료되었으면 ruby -v로 버전 확인겸, 설치 확인을 해주자.$ gem install jekyll$ gem install bundlerjekyll과 bundler가 설치되었으면, bundle exec jekyll serve를 한번 해보자.그러면 아래처럼, 부족한, 필요한 ruby 패키지들을 확인 할 수 있다.Could not find minima-2.5.1, minima-2.5.1, jekyll-feed-0.15.1, jekyll-feed-0.15.1, html-proofer-3.19.2, html-proofer-3.19.2, jekyll-theme-chirpy-4.0.1, jekyll-theme-chirpy-4.0.1, jekyll-seo-tag-2.7.1, jekyll-seo-tag-2.7.1, nokogumbo-2.0.5, nokogumbo-2.0.5, typhoeus-1.4.0, typhoeus-1.4.0, jekyll-archives-2.2.1, jekyll-archives-2.2.1, jekyll-redirect-from-0.16.0, jekyll-redirect-from-0.16.0, jekyll-sitemap-1.4.0, jekyll-sitemap-1.4.0, listen-3.6.0, listen-3.6.0, nokogiri-1.11.7-x86_64-linux, ethon-0.14.0, ethon-0.14.0, racc-1.5.2, racc-1.5.2 in any of the sources다음과 같이 해당 친구들을 설치해주자.$ gem install minima jekyll-feed html-proofer jekyll-theme-chirpy jekyll-seo-tag nokogumbo typhoeus jekyll-archives jekyll-redirect-from jekyll-sitemap listen nokogiri ethon raccruby 패키지 설치가 완료되었으면 이제 마지막 단계다.$ bundle install성공했으면 띄우자~$ bundle exec jekyll serve오류bundle install 등의 과정에서 다음과 같은 오류가 발생한다면!Ruby: You don’t have write permissions for the /var/lib/gems/2.7.0 directory.~/.bashrc 파일에 다음을 추가해주자.# Install Ruby Gems to ~/gemsexport GEM_HOME=\"$HOME/gems\"export PATH=\"$HOME/gems/bin:$PATH\"sudo gem update 도 한번해주면 엥간하면 해결되는 거 같다.참고 박승재 님의 포스팅 Ruby: You don’t have write permissions for the /var/lib/gems/2.7.0 directory." }, { "title": "[JavaScript] 깃허브 블로그에 수식 넣기, MathJax 사용 ", "url": "/posts/mathjax/", "categories": "Etc, Tips", "tags": "github blog, mathjax, blog, jekyll, markdown", "date": "2021-08-24 00:00:00 +0900", "snippet": "MathJaxLaTeX 문법을 사용하여 수식입력을 할 수 있게 해주는 JavaScript 라이브러리이다.URL: https://www.mathjax.org/가장 도움이 된 포스팅: Seongsu 님의 포스팅Jekyll Github 블로그에 MathJax 적용하기_config.yml 수정# Conversionmarkdown: kramdownhighlighter: rougelsi: falseexcerpt_separator: \"\\n\\n\"incremental: falsemathjax_support.html 생성 _includes 디렉토리에 mathjax_support.html 파일 생성하자&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});&lt;/script&gt;&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt;_layouts/default.html 파일의 head 부분에 다음 내용 추가 나는 템플릿 모듈화가 되어있기에 head.html에 직접 추가한다.&lt;!-- mathjax 추가 --&gt; &lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});&lt;/script&gt;&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt;적용법 수학식을 사용할 _posts 하위의 ~.md 파일의 상단에 다음을 추가해준다.---use_math: true---예제 ---layout: posttitle: \"[Etc] 깃허브 블로그에 수식 넣기, MathJax 사용 \"categories: [Etc, Tips]tags: [github blog, mathjax, blog, jekyll, markdown]use_math: truefullview: falsecomments: false---$$G_{t}=\\sum \\limits_{k=0}^\\infty \\gamma ^k R_{t+k+1}$$ \\[G_{t}=\\sum \\limits_{k=0}^\\infty \\gamma ^k R_{t+k+1}\\] 적용이 잘 되는 것을 확인 할 수 있다. LaTeX 문법, 수식 사용법은 다른 글을 참조하자. 참고 https://wikidocs.net/1679 d2h10s 님의 포스팅 [LaTex] Markdown 수식 작성법 huni0318 님의 포스팅 Jekyll,Github 블로그에 LaTex, MathJax 적용, 오류해결 Minki Kim 님의 포스팅 Jekyll Github 블로그에 MathJax로 수학식 표시하기 Seongsu 님의 포스팅Jekyll Github 블로그에 MathJax 적용하기 " }, { "title": "[Tips] 깃허브 블로그에 이쁜 코드 블럭, Github Gist 사용 ", "url": "/posts/github_gist/", "categories": "Etc, Tips", "tags": "github blog, github, blog, jekyll, code block, github gist, gist", "date": "2021-08-24 00:00:00 +0900", "snippet": "Github Gist코드를 작성하고, HTML Embed 태그를 이용해서 코드 블럭을 이쁘게~ 나타낼 수 있다.URL: https://gist.github.com/비교// default zoomvar zoom = 17;// center of the mapvar center = [37.558240, 127.000258];// Create the mapvar map = L.map('map', { attributionControl: false }).setView(center, zoom);// Set up the OSM layerL.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 }).addTo(map);// add a marker in the given locationL.marker(center).bindPopup(\"내가 졸업한 동국대학교\").on(\"mouseover\",function(evt){this.openPopup();}).on(\"mouseout\",function(evt){this.closePopup();}).addTo(map);참고 eona1301 님의 포스팅[Github Blog] MarkDown 코드 작성" }, { "title": "[Html] HTML embed 태그, 깃허브 블로그에 ppt, youtube, soundcloud 넣기 ", "url": "/posts/embed_tag/", "categories": "Etc, Tips", "tags": "html embed tag, embed tag, github blog, ppt embed, youtube embed, soundcloud embed, jsfiddle embed", "date": "2021-08-24 00:00:00 +0900", "snippet": "HTML embed 태그embed 태그는 외부 애플리케이션이나 대화형 콘텐츠를 포함시킬 수 있는 컨테이너(container)를 정의할 때 사용한다.HTML4까지는 정식으로 명세에 포함되지 않고, HTML5에서 새롭게 추가되었다.이를 사용하면 html 내에 ppt 슬라이드를 넣거나 soundcloud 음원을 넣거나, jsfiddle 등..여러 외부 애플리케이션을 활용할 수 있다.PowerPoint Presentation여러가지 방법이 있다고 하지만, Microsoft OneDrive를 사용하는 방법을 소개한다.OneDrive 앱을 실행시키고 공유할 ppt를 업로드한다.OneDrive 웹 https://onedrive.live.com/에서 해당 파일을 열고, 파일 - 공유 - 포함Embed 태그를 얻을 수 있다..! Html 태그이기 때문에 .md 파일에 삽입해도 사용할 수 있다~Youtube공유 - 퍼가기그렇게 퍼온 동영상은 바로 sakeL의 노동요다. 근데 재생할 수 없다고 뜨는 이유는 무엇일까.. 저작권..? SoundCloudShare - EmbedJsFiddle웹의 프론트엔드 기술인 HTML, CSS, JavaScript를 웹에서 작성해서 바로 테스트 해볼 수 있고,그 소스를 저장 공유할 수 있는 서비스이다.URL: http://jsfiddle.net/jsfiddle에 접속하고, 저장한 뒤에, 상단 바의 Embed참고 http://tcpschool.com/html-tags/embed Haehwan Lee 님의 포스팅 Powerpoint presentations on Github pages Opentutorials.org 포스팅 JSFIDDLE이란? " }, { "title": "[JavaScript] KFQ 2차 프로젝트 / Leaflet", "url": "/posts/02-prj2/", "categories": "Study, JS", "tags": "Django, Python, Web, Leaflet, Javascript", "date": "2021-08-24 00:00:00 +0900", "snippet": "본 포스팅은 KFQ 한국품질재단 인공지능 개발자 교육과정 2차 프로젝트의 구현 기술 관련 포스팅입니다.2차 프로젝트 발표 ppt: https://19tak.github.io/posts/01-prj2/프로젝트 진행 기간 2021년 6월 15일 화요일 ~ 7월 7일 수요일Leaflet리플릿(Leaflet)은 웹 매핑 애플리케이션을 빌드하기 위해 사용되는 오픈 소스 자바스크립트 라이브러리이다.2011년 처음 출시되었으며, HTML5와 CSS3를 지원하고 대부분의 모바일 및 데스크톱 플랫폼을 지원한다.Leaflet은 GIS 배경지식이 없는 개발자들이 공용 서버에 호스팅되는 타이틀 웹 맵을 선택적 타일 오버레이와 함께 매우 쉽게 표출할 수 있게 한다.GeoJSON 파일로부터 피처 데이터(feature data)를 로드하고 스타일을 입히고 상호작용 레이어를 만들 수 있다. (예: 클릭할 때 팝업 포함 마커 등)이용법Leaflet의 일반적 용도에는 div 등의 HTML 요소에 리플릿 map 요소를 바인딩하는 일이 수반된다.그 뒤 map 요소에 레이어와 마커가 추가된다.exampleJavaScript Code // default zoomvar zoom = 17;// center of the mapvar center = [37.558240, 127.000258];// Create the mapvar map = L.map('map', { attributionControl: false }).setView(center, zoom);// Set up the OSM layerL.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 }).addTo(map);// add a marker in the given locationL.marker(center).bindPopup(\"내가 졸업한 동국대학교\").on(\"mouseover\",function(evt){this.openPopup();}).on(\"mouseout\",function(evt){this.closePopup();}).addTo(map); Leaflet의 고유한 기능은 구모양이 아닌 메르카토르 도법 (Mercator Projection)으로 지도를 표출하는 것이다.Leaflet 라이브러리 그 자체는 변수 L을 통해 접근이 가능하다. 나는 map layer에 image 파일과 함께 x,y 좌표 (위도와 경도)를 이용하는 기술이라 받아들였다.Leaflet RroseLeaflet Rrose는 현재 map을 동서를 제외한 6방위 (북서, 북, 북동, 남서, 남, 남동) 에 대한Popup 이벤트를 자동으로 처리해주는 목적으로 등장한 Leaflet 확장 라이브러리이다.자세한 내용은 Leaflet Rrose 공식 페이지를 읽어보면 이해가 더 잘 갈 것이다.나는 좌석배치도를 map layer에 추가하고, bindTooltip으로 이름표를, mouseover로 학생 상세 정보를 보였다.좌석 번호마다 좌표 값을 리스트에 저장하여 불러오기 때문에,반 구조도가 바뀔 때마다, 좌표와 map layer를 다시 설정해주어야한다는 단점이 있었다.Ajax (비동기식 js와 xml) 를 사용해 당일, 선택한 과정의 학생 정보를 로드하고 map 위에 나타내도록 작성하였다.sample of prj2JavaScript Code var map = L.map('map', {crs: L.CRS.Simple, zoomControl: false, maxZoom: 0, dragging: true});var imgurl = 'https://user-images.githubusercontent.com/84369912/130463456-9247b3bc-8daf-488e-b8c7-c7e9a17a7d22.png' // 이미지 경로var bounds = [[0,0], [680,1500]]; // 이미지의 해상도를 bounds로 설정한다. [y,x]L.imageOverlay( imgurl, bounds).addTo(map); // 배경 이미지를 설정한다.map.fitBounds(bounds); // 표현 영역을 설정한다const column = [143,373,603,833,1063,1293]; // 분단 x 좌표const row = [160,285,410,535,650]; // 몇번째 자리인지 y 좌표var set = []; // 좌석 번호가 담길 좌표 리스트for(var i=0; i&lt;column.length; i++) {\tfor(var j=0; j&lt;row.length; j++) {\t\t\t\t\t\tset[i*row.length+j]=[i*row.length+j+1,column[i],row[j]]; // set[e] = [좌석번호, x좌표, y좌표]\t\t// console.log(set[i*row.length+j]);\t}}const color = ['green','red','orange','gray'];function seat_on(seat_num, select_class, nameValue, majorValue, daily_info,state,emailValue) {\tvar name='\"'+nameValue+'\"';\tvar class_name='\"'+select_class+'\"';\tvar major='\"'+majorValue+'\"';\tvar temperature=daily_info[1];\tvar email=emailValue;\tvar url = \"'https://user-images.githubusercontent.com/84369912/127220954-701d3e97-6d9d-447a-b99f-1a31e4b7b03d.png'\";\tvar img_url = \"&lt;img src=\"+url+\"&gt;\";\tvar color_name = color[state];\t// jsfiddle에서 Rrose가 먹통임... 왜징.. /* var popup_content = new L.Rrose({ autoPan: false, offset: new L.Point(0,-10), closeButton: false })\t.setContent(\"&lt;center&gt;\"+name+\"&lt;/center&gt;&lt;br /&gt;\"+img_url+\"&lt;br /&gt;\\\t&lt;br /&gt;&lt;center&gt;반 : \"+class_name+\" 반&lt;/center&gt;&lt;br /&gt;\\\t&lt;center&gt;전공 : \"+major+\"&lt;/center&gt;&lt;br /&gt;\\\t&lt;center&gt;체온 : \"+temperature+\" 도&lt;/center&gt;\"); */\tL.circle([set[seat_num-1][2], set[seat_num-1][1]], {color: color_name, radius: 23, fillOpacity: 1}).addTo(map)\t/* .bindTooltip(name, {permanent: true, direction: 'center', opacity: 1}).openTooltip() */\t.bindPopup(\"&lt;center&gt;\"+name+\"&lt;/center&gt;&lt;br /&gt;\"+img_url+\"&lt;br /&gt;\\\t&lt;br /&gt;&lt;center&gt;반 : \"+class_name+\" 반&lt;/center&gt;&lt;br /&gt;\\\t&lt;center&gt;전공 : \"+major+\"&lt;/center&gt;&lt;br /&gt;\\\t&lt;center&gt;체온 : \"+temperature+\" 도&lt;/center&gt;\")\t.on(\"mouseover\", function(evt) { this.openPopup(); })\t.on(\"mouseout\", function(evt) { this.closePopup(); });}seat_on(17,\"ai\",\"한정탁\",\"기계로봇에너지공학과\",[0,36.5],0,\"wjdxkrdl123@naver.com\") 참고 Leaflet official: https://leafletjs.com/ 위키피디아: 리플렛 메르카토르 도법 Leaflet Rrose https://erictheise.com/rrose/ github https://github.com/erictheise/rrose Yasunori Iwatsuki 님의 포스팅엑셀로 관리하던 자리 배치도, Leaflet을 통해 웹 시스템으로 탈바꿈하다 brviolet 님의 포스팅지도용 라이브러리로 좌석배치도 만들기 Leaflet Rrose https://github.com/erictheise/rrose http://jsfiddle.net/5KmM6/ 공간정보시스템 / 딥러닝 기반 기술 연구소 의 포스팅Leaflet 강좌 ㅡ 1. 배경지도로 타일맵 활용하기" }, { "title": "[Rap] Fall In - Ajax 2020 Compliation Album B Side (박우, 준희, Ycityboy, 정탁) (Prod.Yusei)", "url": "/posts/fallin/", "categories": "Blog, Rap", "tags": "Rap, Ajax, Hiphop", "date": "2021-08-23 00:00:00 +0900", "snippet": "저의 2020년 AJAX 컴필 앨범 참여곡.Fall InAJAXDGU · Fall In가사 (hook) 생각이 깊어지는 밤 너 떠난후 온기를 잃어버린 방 혼자 남은 나는 falling 나는 falling 너 다시와도 나는 falling 공허한 내일이 올걸 알아 너 하날 못잊어 여잔 너 하나 girl i will sing it for you (verse1) 박우 i will sing it for you girl 내일이 되도 너가 그리운걸 너도 알지 없잖아 너보다 더 이쁜거 매일 밤이 뜨거 웠었던 우리 침대위에 boogie 시간없어 we aint got a time to go i was trying to be cool i miss you i do more than to be true nothing more than you 너가 있는 환상적인 view 사랑이 끝이 있었다면 너와 시작안했곘지 멀리서라도 너를 지켜나 봐야겠지 봐야겠지 when do i forget you 여자로 잊어야겠죠 뜬눈으로 밤새 너를 catch you 둘의 조합 완벽한 매치야 아침에 보이는 땅에 brassiere 향기좋아 fucking freesia 여자 만나는건 쉬워 매일 easier 되어줄래 나의 eupraxia want some fresh air 자유로운 삶에 나는 만끽하기 싫어 너의 집착 근원 삶의 이유 되고싶어 (verse2) 준희 두 눈 뜨고 지나간 밤 i don’t wanna waste time 너라면 괜찮을것만 같은데 yeah that’s ok 난 착한척이 벴으니 so please don’t leave me ay yeah 그래 원래 이랬지 나 yuh 이게 정말 진짜니 real life yuh i don’t wanna fallin the deep site so please don’t leave we aint got no time 우린 시간이 없잖아 넌 계속해서 더 빠르게 달려가지 내 one light 우리를 밝게 비추는 moonlight 달빛아래 하나되는 너와 나 all right all right 난 내 걸음 더 빠르게 너와 나의 마지막 밤이 되지는 않게 yuh im fallin to u r pool 난 계속 빠지겠지 deep deep deep deep in (hook) 생각이 깊어지는 밤 너 떠난후 온기를 잃어버린 방 혼자 남은 나는 falling 나는 falling 너 다시와도 나는 falling 공허한 내일이 올걸 알아 너 하날 못잊어 여잔 너 하나 girl i will sing it for you (verse3) Ycityboy I didn’t give a fuck about what u said But 널 더 원해 그 때 보다 So I sing it for u 다시 잡고 싶어 널 I’m so lonely that I’m fallin’ and fallin’ and fallin’ You don’t know how much I depressed I cut my wrist when u go away 차갑게 식었지 침대는 Girl, I want u back, want u back You don’t know how much I depressed I cut my wrist when u go away 차갑게 식었지 침대는 Girl, I want u back, want u baaaack (verse4) 정탁 mkit right with the rain dropped from 내 눈 근데 왜아직도난 벗어나질 못해 숨 막히던 하루는 끝났는데 비극이더라 when we seen in close-up with the zoom 아직도 느끼는중 너와의 호흡 맞춰가던 리듬, 환상의 듀오, dynamic what we move, just kiss like dat day before, 그리워 움직여줘 위아래 위아래, 난 만들어줘 너, 승마 느낌 갖게 물리학을 같이 공부해 with our body frame 에너지를 바꿔 열로, 너가 진리를 깨닫게 nothin but the bigger, 그 b.i.g what i have on ma pocket, 전화 피하지 말고 받아봐 우리가 원하는 그 sexy memories sex with bad hesitatate, make some love and habitat https://soundcloud.com/ajaxdgu/fall-in?in=ajaxdgu/sets/2020-ajax-compilation-b-side주제는 섹시한 사랑이었는데 ㅋㅋㅋ.. 섹시한가… ㅋㅋㅋㅋㅋ다른 곡들도 많이 들어주세용!비트: (FREE) Bryson Tiller Type Beat - Señorita - (Prod.Yusei)" }, { "title": "[KFQ] KFQ 2차 프로젝트 / 수강생 관리 웹 사이트", "url": "/posts/01-prj2/", "categories": "Project, KFQ", "tags": "Django, Python, Web", "date": "2021-08-23 00:00:00 +0900", "snippet": "본 포스팅은 KFQ 한국품질재단 인공지능 개발자 교육과정 2차 프로젝트의 발표 ppt와 제출 ppt 입니다.http://19tak.pythonanywhere.com/체험 ID &amp; PW ID: ai8@kfq.com PW: 1111 저희 조는 수강생 관리 웹 사이트 구현을 목표로 프로젝트를 진행했습니다.포함된 Microsoft Office 프레젠테이션, 제공: Office프로젝트 설명 1. 프로젝트 개요 교육과정을 들으며, I’m Here라는 어플로 출석체크를 진행했다. 비컨 방식으로 특허가 나와있다.. 뭐 그런 얘기를 들은 것 같은데 불편한 점이 좀 있었다. 그것은 수강생 입장에서뿐만 아니라 관리자분들이나 강사님들도 불편사항을 느꼈다고 했다. 우리 조는 프로젝트 기간을 감안하여, 우선적으로 관리자 입장에서 수강생 관리 웹 사이트를 제공하고자 했다. 2. 프로젝트 요약 핵심적인 기능으로 기본적인 수강생 정보 CRUD, 출석과 성적등의 수강생 통계자료 시각화, 공지사항을 포함한 각종 게시판, 좌석배치도, 그리고 출결 현황 조회 기능이 있다. 폭포수 모델의 개발 방법론을 따르며, 인터뷰를 통한 요구사항 정의서를 포함한 문서 작업부터 전체적인 개발 프로세스를 접할 수 있었다. 느낀점Git과 Github를 본격적으로 사용하기 시작하면서, 1차 프로젝트에 비해 협업 부분에서 성장함을 느꼈다.또한, 폭포수 모델로 프로젝트를 진행해나가며, Usecase Diagram, 요구사항정의서, 구조도와 UI/UX 설계,Class Diagram, Sequence Diagram, ERD 등 문서 작업을 직접 경험해 볼 수 있었고,개인적으로 Leaflet 공부가 재미있고 유익했다. (매우 어려웠다 ㅋㅋ)팀원들과 마지막 프로젝트가 끝나고 좀 더 손보기로 하여, 멋있게 만들어서 띄워보겠다.프로젝트 진행 기간 2021년 6월 15일 화요일 ~ 7월 7일 수요일" }, { "title": "[RL] 모델 프리 강화 학습", "url": "/posts/02-rl/", "categories": "Study, AI", "tags": "AI, ReinforcementLearning, Monte Carlo, Temporal Difference, Model Free Reinforcement Learning, Model Free", "date": "2021-08-20 00:00:00 +0900", "snippet": "본 포스팅은 “Do it! 강화 학습 입문” - (이지스퍼블리싱, 조규남, 맹윤호, 임지순 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 모델 기반 vs 모델 프리 몬테카를로 학습 (MC, Monte Carlo Learning) 몬테카를로 학습의 개념 몬테카를로 학습의 특징 시간차 학습 (TD, Temporal Difference Learning) Q 학습 (Q-Learning)1. 모델 기반 vs 모델 프리모델 기반 (Model-Based) 강화 학습은 에이전트가 환경 안에서 가질 수 있는모든 상태와 각 상태 간의 전이 확률을 미리 안다는 전제가 깔려 있다.MDP를 이루는 구성 요소 중 모델에 대한 모든 지식을 미리 알고 있다는 것이다.종단 상태로부터 역추적해 모든 상태와 행동의 가치를 계산하는 완전 탐색이라는 특징까지도,가치 반복법과 정책 반복법은 현실 세계에 적용하기 어렵다.그렇다면종단 상태로부터 역추적이 아닌, 초기 상태로부터 탐색을 진행하며 경험을 누적하는 정책은?완전 탐색이 필요하지 않으므로 계산양을 크게 줄일 수 있다.이렇게 모델에 대한 완전한 지식이 필요치 않은 모델 프리 (Model-Free) 강화 학습에는대표적으로 몬테카를로 (MC, Monte Carlo) 학습과 시간차 (Temporal Difference) 학습이 있다.2. 몬테카를로 학습 (MC, Monte Carlo Learning)몬테카를로 학습의 개념완전한 가치 함수를 구할 수 없으므로, 가치 함수의 추정치를 구하는 방식으로 문제 해결에 접근한다.정책을 초기에 무작위로 설정하고, 이를 이용해 가치 함수를 추정하고, 이로 정책을 개선한다.개선한 정책으로 가치 함수를 추정하고, 추정한 가치 함수로 다시 정책을 개선한다.가치 함수와 정책이 모두 수렴할 때까지 반복하는데 정책 반복법과는 큰 차이점이 있다. MC는 완전한 가치 함수가 아닌 가치 함수의 추정치만 얻을 수 있다. MC는 환경내 모든 상태의 가치 추정이 아닌, 에이전트가 거쳐간 상태의 가치 함수만 추정한다.이렇게 에이전트가 직접 에피소드를 겪어 나가며 모델을 추정하기 때문에,환경의 모든 상태를 거친다고 보장하지 못한다.몬테카를로 학습의 특징 알려진 모델이 없다고 가정. 즉, 에이전트는 주어진 상태에서 행동을 취했을 때, 어떤 상태로 전이할지, 보상이 주어질지 모른다. 에이전트는 경험의 표본으로부터 학습. 현재까지 겪은 모든 에피소드에 대해 상태의 이익 \\(G\\)를 평균하여 상태의 가치 함수를 구함. (경험적 평균) 에피소드 하나를 완전히 끝낸 다음 업데이트. 에피소드 단위 문제에 한하여 적용 가능.이렇듯 MC의 핵심은 에피소드이고, 기본 학습 단위가 에피소드 완주이므로 무한한 환경에서는 적용이 불가하다.또한, 모델을 모르기 때문에, 전이 확률을 모르고, 따라서 가치 함수의 의미가 없다.즉, 특정한 행동이 그 상태의 최선 행동이라 말할 수 없다. 그래서 나온 것이,상태 \\(s\\)에서 행동 \\(a\\)를 취했을 때의 장기적 보상에 대한 평균, 행동-가치 함수, Q 함수 \\(Q(s,a)\\)다. 상태 \\(s\\)만을 입력으로 하는 가치 함수 \\(V(s)\\)에 행동 \\(a\\)를 추가했다고 생각하자.3. 시간차 학습 (TD, Temporal Difference Learning)에피소드가 무한히 지속되거나 하나의 에피소드가 종료되기까지 시간이 오래 걸릴때,에피소드 자체가 길다면 시간차 (TD) 학습을 사용하자.MC는 하나의 에피소드가 끝날 때 마다 Q 함수를 업데이트 한다면,TD는 상태 변화가 있을 때마다 업데이트한다.하나의 에피소드가 끝나지 않아도, 단계마다 학습이 가능하다는 뜻이다.MC, TD와 분산, 편향분산 (Variance)은 학습 데이터가 얼마나 넓게 퍼져있는지를 나타내고,분산이 크면 잡음이나 오류가 많이 포함되고 과대 적합 (overfitting)이 발생한다.편향 (Bias)은 데이터의 일부만을 학습해 잘못된 가정이 만들어지는 것이고,과소 적합 (underfitting) 문제가 발생할 수 있다.MC는 에피소드가 끝나야만 Q 함수를 업데이트 가능하고,에피소드마다 서로 다른 상태를 갈 수 있으므로 분산이 크고 편향이 작다.TD는 다음 단계의 영향만 받아 가치 함수를 업데이트 하므로, 분산이 작고 편향이 크다.이러한 문제를 인지하고 넘어가자.수식MC에서 \\(N\\)회의 에피소드에 대한 \\(G_{t+1}\\)값에 할인율 \\(\\gamma\\)를 곱한 다음 평균하여 \\(Q(S,A)\\)를 구했다.\\[Q(S,A)=(1-1/N)Q(S,A)+\\gamma G_{t+1}/N\\]여기서 \\(1-1/N\\)을 \\(\\alpha\\)로 치환하면 다음과 같다.\\[Q(S,A)=Q(S,A)+\\alpha (\\gamma G_{t+1}-Q(S,A))\\]TD의 Q 함수 업데이트 공식도 이와 유사하다.TD는 에피소드 종료 이전에 업데이트가 가능하므로 \\(G_{t+1}\\)을 구할 수 없고, \\(\\alpha\\)도 \\(1-1/N\\)일 필요가 없다.다음 단계 보상 \\(R_{t+1}\\)과 \\(Q(S_{t+1},A_{t+1})\\)가 반환하는 값으로 현재의 \\(Q(S_{t},A_{t})\\)를 업데이트 한다.\\[Q(S_{t},A_{t})=Q(S_{t},A_{t})+\\alpha (R_{t+1}+\\gamma Q(S_{t+1},A_{t+1})-Q(S,A))\\]엡실론-탐욕 (Epsilon-Greedy) 알고리즘모델 프리 학습들은 에이전트가 거치는 상태와 행동에만 Q 함수를 갱신하므로, 샘플링으로 볼 수 있다.\\(A_{t+1}\\)을 선택하는 기준은 무엇이 있을까? 그냥 Q를 최대로 할까?가치 반복법과 같이 더 큰 Q 함수, 가치 함수를 얻기 위한 행동을 선택하는 것을탐욕 알고리즘 (Greedy Algorithm)이라 한다.상태, 행동 공간이 넓은 환경에서는 탐욕 알고리즘이 좋을 수 있다.하지만 MC, TD 모두 자신의 상태, 행동을 샘플링하여 학습에 반영하기 때문에샘플링 범위를 줄이는 탐욕 알고리즘이 최적의 정책을 찾을 가능성을 낮춘다.이 때, 에이전트가 가치 함수를 이용하며, 새로운 영역을 탐험할 수 있도록 여지를 주면최적의 행동과 정책을 찾아낼 가능성이 높아질 것으로 볼 수 있다.이를 엡실론-탐욕 (Epsilon-Greedy) 알고리즘이라 한다. 탐욕 알고리즘 가장 높은 가치 함수 또는 Q 함수를 추구하는 방향으로 행동을 결정. 탐험을 배제한 이용. 랜덤 노이즈 알고리즘 에이전트가 지나는 각 단계마다 가치 함수의 추정치에 무작위 값을 더함. 더한 노이즈로 탐험을 진행 엡실론-탐욕 알고리즘 엡실론 확률을 통해 가장 높은 가치 함수를 추구하지 않는 행동중에 하나를 무작위로 선택. TD에서는 엡실론-탐욕 알고리즘을 통해 탐색이 덜 진행된 상태에서 학습 결과가 수렴하는 것을 막을 수 있다.4. Q 학습 (Q-Learning)행동 정책과 학습 정책TD에서 임의의 정책인 \\(\\pi (s)\\)를 사용해서 행동 \\(A_{t}\\)를 취하고,다음 단계에서 \\(Q\\)를 추정할 때 같은 \\(\\pi (s)\\)를 사용하여 행동 \\(A_{t+1}\\)을 선택한다.움직이기 위한 정책 (행동정책)과 학습하기 위한 정책 (학습 정책)이 같다는 뜻이다.행동 정책에 탐험 요소를 어느 정도 넣는 것은 바람직하지만,학습 수렴 속도가 느려지기때문에 학습 정책에는 탐험 요소가 필요치 않다.둘 모두를 탐욕 알고리즘을 사용하면 학습은 빠르게 수렴하지만,탐험 요소가 없으므로 최적 정책 수렴은 힘들다. Q 학습은 여기서 고안 되었다.Q 학습은행동 정책과 학습 정책을 서로 다르게 하는 Q 학습의 Q 함수 업데이트 공식은앞선 TD 학습의 Q 함수 업데이트 수식과 거의 비슷하다.\\[Q(S_{t},A_{t})=(1-1/N)Q(S_{t},A_{t})+(R_{t+1}+\\gamma max_{a}Q(S_{t+1},a))/N\\]수식에서 우리는 행동 정책 (행동 \\(A_{t}\\)를 선택)과 학습 정책(\\(a\\)를 선택)이 다름을 볼 수 있다.행동 정책은 엡실론-탐욕, 학습 정책은 탐욕 알고리즘을 따른다.DQN (Deep Q-Networks)가 바로 이 Q 학습에 딥러닝을 접목한 것이다.참고“Do it! 강화 학습 입문” - (이지스퍼블리싱, 조규남, 맹윤호, 임지순 지음) 깃허브: https://github.com/yunho0130/start-RL" }, { "title": "[KFQ] KFQ 1차 프로젝트 / 국내 영화관람객수 예측", "url": "/posts/01-prj1/", "categories": "Project, KFQ", "tags": "R, MachineLearning", "date": "2021-08-20 00:00:00 +0900", "snippet": "본 포스팅은 KFQ 한국품질재단 인공지능 개발자 교육과정 1차 프로젝트의 발표 ppt 입니다.저희 조의 주제는 코로나19에 따른 국내 영화산업 동향 및 전망 분석이었습니다.포함된 Microsoft Office 프레젠테이션, 제공: OfficePPT 및 프로젝트 설명 1. 프로젝트 개요 코로나로 인해서 무너지고 있는 영화산업, 이에 대한 반등으로 증가하고 있는 국내 OTT 시장. 이러한 뉴스를 다들 접해 보셨을 거라 생각한다. 저희 조는 이러한 뉴스에서 아이디어를 얻어서 프로젝트 주제를 잡고, 다양한 분석 방법을 통해 국내 영화 산업이 나아가야할 방향성 등의 인사이트를 도출하고자 했다. 2. 프로젝트 요약 및 환경 저희는 간트차트에서 확인할 수 있듯이, 많은 데이터 테이블을 사용하여, 주제선정 이후 데이터 수집과 EDA, 전처리에서 많은 시간을 사용했다. 분석과 학습 등의 과정은 R에서 진행하였고, 국내통계 사이트 등의 OpenAPI를 Json 형식으로 크롤링, 핸들링할 때에는 파이썬을 같이 사용했다. 3. 진행과정 및 산출물 수집하고 실제 사용한 데이터는 총 6가지이다. 영화 관람객 수 데이터 일별 총 관객수 및 매출액 사용변수: 전체 상영 영화 수, 전국 스크린 수, 전체 관람객 수 등 변수 정제: 변수형 변경 (Char 변수 &gt; 수치형 변수) 시각화: 국내/해외/전체영화, 코로나 전/후 이상치: box-cox 변환 출처: KOFIC KOBIS 영화관 입장권 통합 전산망 코로나 이전과 이후 관람객 수 변화, 토-일-수의 순서로 관람객이 많은 것, 계절에 대한 패턴이 존재하는 것 등을 시각화 자료에서 확인 할 수 있다. 코로나 관련 데이터 결측치: 뉴스 기사와 비교 후 수기 작성 사용변수: 신규/누적 확진자 수, 신규/누적 사망자 수, 치료 중 환자 수 등 변수 정제: 신규 인원에 관한 파생 변수 생성, 치료 중 환자 수 &gt; 생존한 치료 중 환자 수 출처: 공공데이터포털 보건복지부 코로나19 감염현황 조회서비스 Open API 영화 검색량 사용변수: 수집기간 기준 top100 영화명을 바탕으로 ‘영화’ 키워드 검색량 출처: Naver DataLab 통합 검색어 트렌드 API 인기 상영작의 개봉, 수상 전후로 관람객 수가 급증하는 것을 시각화 자료에서 확인 할 수 있다. 날씨 결측치: 강수량/적설량은 0, 기온 및 습도 결측치는 제거 사용변수: 최고/최저/평균 기온, 평균 강수량, 평균/최고 풍속, 평균 습도, 평균 적설량 등 변수 정제: 일별 불쾌지수 파생변수 추가, 지역별로 구분된 데이터 group by로 일자별로 평균값 사용 출처: 기상청 지상 (종관, ASOS) 일자료 조회서비스 Open API 미세먼지 결측치: 평균값으로 대체 사용변수: 미세먼지농도 변수 정제: 지역별로 구분된 데이터 group by로 일자별로 평균값 사용 공휴일 사용변수: 공휴일 날짜 변수정제: 주말/공휴일을 묶어 휴일, 나머지 평일로 범주형 변수 추가 시간의 흐름에 따른 시각화 자료에서, 코로나 관련 변수들에 있어서는 확실하게 관람객수가 감소한 모습을 볼수 있다. 4. 모델 검증 및 분석 분석에 앞서 각 변수들의 상관관계 그래프에서 유의미한 변수들을 확인하고 산점도 그래프를 통해 선형회귀분석을 진행하기로 하였다. 모델링에 앞서, 전처리과정에서 정규성을 만족하지 못하는 전체 관람객 수에 대하여 box-cox 변환을 진행했다. 변환 이후 정규화가 된 것과 이상치가 제거된 모습을 확인 할 수 있다. 4가지 범주형 변수에 대하여 등분산성 검정을 진행하고, 등분산성을 만족치 못하는 변수에 대해 추가로 welch t 검정을 통해, 평균에는 차이가 존재하여 통계적으로 유의미한 변수라 판단했다. Anova 검정을 통해 유의미한 변수들의 판단과 함께 각 변수들의 교호관계도 확인했다. 해당 변수들로 선형 회귀를 진행하였을 때 81%의 설명력이 나왔지만, 변수가 너무 많아 발생하는 차원문제를 해결하기 위해서 best subset, 전진선택법, 후진소거법, 단계적 선택법의 4가지 변수 선택법을 모두 진행하였고 모두 동일한 8개의 변수를 선택하였다. 선택된 변수를 사용한 선형 회귀 모델에서 설명력 80%, 다중공선성에 문제 없음을 확인하였고 추가로 이상치를 제거하여 설명력을 83%까지 올렸다. x 변수들을 scaling 하였을 때, 변수를 많이 선택할 수록 오차율이 낮아지는 것을 볼 수 있었지만, 차원 문제로 8개의 변수를 선택하였고, 이 역시 동일한 결론을 얻었다. 하지만 해당 모델의 완성 후, durbin watson 검정을 통해 독립성이 만족하지 않는 것을 발견, 이를 보완하기 위한 비선형 모델과 시계열 모델을 추가로 고려했다. 비선형 모델 중, 비선형 데이터에 적합하며, 오버피팅과 다중공선성을 방지 할 수 있고, 변수 중요도를 파악할 수 있는 장점에서 랜덤포레스트 모델을 사용했다. 최적의 결과를 확인하였을 때, 치료 중 환자 수가 학습에 있어서 가장 중요한 변수로 파악되었고, 시각화 자료에서 확인 할 수 있듯이, 대유행 시기에 맞춰 급증하는 치료 중 환자 수와 함께 급감하는 관람객 수를 볼 수 있다. 시계열 분석을 통해 경향성, 계절성을 분리시킨 이동평균 모델, 자기상관함수 확인을 통한 자기회귀모델에서 유의 수준 이상의 p 값 확인을 통해 시계열 arima 모델을 생성했다. 3개월, 6개월, 12개월, 24개월에 대한 예측 그래프와 함께 예측된 2021년 5월의 평균 관객 92458명, 실제 평균관객 141230명에서 box-cox 정규화 이후 4.875%의 상대오차로 예측이 완료되었다. 해당 오차의 차이는, 분노의 질주, 크루엘라 등 인기 개봉작에 의한 관객수 영향과 코로나 백신의 접종이 진행되며 일어난 것으로 파악 중이다. 5. 결론 랜덤 포레스트 모델로부터 치료 중 환자 수가 영화 관객 수 예측에 있어서 압도적으로 중요한 변수라는 것과 함께 시계열 모델로 계절성과 트렌드에 민감한 향후 2년간의 관객 수를 예측했다. 앞서 독립성을 만족하지 못하여, 분석의 의미가 퇴색된 선형회귀모델과 앙상블하여 더 뛰어난 모델을 생성할 경우 더욱 뛰어난 예측이 가능할 것으로 보이며 백신의 접종이 꾸준히 진행 되고 있기에, 관람객 수가 회복되기까지 국내 영화산업계가 조금만 더 버텨준다면, 이전 수준으로 회복하여 다시 빛을 볼 수 있을 것으로 예상된다. 보고서 포함된 Microsoft Office 문서, 제공: Office 느낀점협업에서의 양식 통일의 필요성을 느꼈다.또한 소스 코드 업데이트 시, 기록이 남아있지 않아 좀 애먹었다. (사실 아직도 애먹고있다. 나중에 다시봐도 뭔말인지 읽기 힘들정도)덕분에 Git을 사용해야겠다는 생각을 시작하였고, 흐르고 흘러 블로그까지 만들 수 있었다.프로젝트 진행 기간 2021년 5월 7일 금요일 ~ 6월 7일 월요일R 전체 코드 (주의, 좀 김, 정리가 안되어있음..) # settingrm(list=ls())getwd()setwd('C:/Users/eric3/Desktop/example/large')setwd(\"C:\\\\19tak\\\\ai 개발자 과정\\\\prj1\\\\data\")library(car)library(leaps)library(tidyverse)library(lubridate)library(corrplot)library(glmnet)library(ggpubr)library(rstatix)library(onewaytests)library(gganimate)library(dplyr)options(warn = -1)par(mfrow=c(1,1))# Start# 열 재조정# 일단은 전체 데이터에 대해서만all = read.csv('all_final2.csv')all = all[-1]all = all %&gt;% mutate(pm = exp(log_pm), Date = as.Date(Date)) %&gt;% select(-c(log_pm)) %&gt;% select(c(1,26,25,2:11,27,12:27)) %&gt;% rename(research_volume = count)# 미세먼지 # 1. exp 취하기# 2. 범주 만들기dim(all) ## 전체 영화에 대한 분석 ## (all)### EDA ###str(all)# 1. 결측치 확인 : 무sum(!complete.cases(all))### 2. 이상치 확인all_num = all %&gt;% select(-c(Date,covid,weekdays,weekdays_kind,d_index))str(all_num)# u+- 3sigma 밖은 이상치로 판단rm_outlier &lt;- function(x){ mu = mean(x) sigma = sd(x) if (x &gt;= mu-3*sigma &amp; x &lt;= mu+3*sigma){ print('no outlier') } else{ return(x) }}apply(all_num,2,rm_outlier)# 이상치 없음을 확인# 상관관계 시각화cor = all %&gt;% select(-c(Date,covid, weekdays,weekdays_kind, d_index, deathCnt)) %&gt;% cor() %&gt;% round(2)par(mfrow=c(1,1))# 유의성 matrixcor.mtest &lt;- function(mat, conf.level = 0.95) { mat &lt;- as.matrix(mat) n &lt;- ncol(mat) p.mat &lt;- lowCI.mat &lt;- uppCI.mat &lt;- matrix(NA, n, n) diag(p.mat) &lt;- 0 diag(lowCI.mat) &lt;- diag(uppCI.mat) &lt;- 1 for (i in 1:(n - 1)) { for (j in (i + 1):n) { tmp &lt;- cor.test(mat[, i], mat[, j], conf.level = conf.level) p.mat[i, j] &lt;- p.mat[j, i] &lt;- tmp$p.value lowCI.mat[i, j] &lt;- lowCI.mat[j, i] &lt;- tmp$conf.int[1] uppCI.mat[i, j] &lt;- uppCI.mat[j, i] &lt;- tmp$conf.int[2] } } return(list(p.mat, lowCI.mat, uppCI.mat))}res1 &lt;- cor.mtest(cor, 0.95)## 유의수준에 따라 유의하지 않은 경우 X 표시하기corrplot.mixed(cor,lower=\"color\",upper=\"number\",p.mat=res1[[1]],sig.level=0.05, mar = c(4,4,4,4),tl.cex = 0.5, tl.col= 'blue')l=length(cor[1,])for(i in 1:l){ for(j in 1:l) { if(i &gt;= j) next text(i,11-j+1,round(res1[[1]][i,j],2)) }}# 산점도 파악panel.cor &lt;- function(x, y, digits = 2, prefix = \"\", cex.cor=0.1, ...){ usr &lt;- par(\"usr\"); on.exit(par(usr)) par(usr = c(0, 1, 0, 1)) r &lt;- cor(x, y) txt &lt;- format(c(r, 0.123456789), digits = digits)[1] txt &lt;- paste0(prefix, txt) if(missing(cex.cor)) cex.cor &lt;- 0.8/strwidth(txt) text(0.5, 0.5, txt, cex = cex.cor)}# 수치형 변수에 대해서만pairs(all_num, lower.panel = panel.cor, upper.panel = panel.smooth)str(all2)###################################### Visualization# all2 : 연도/월/일로 분할 해보기str(all)all2 = all %&gt;% mutate(year = year(Date), month = month(Date), day = day(Date))# 시간이 지남에 따른 최고 풍속과 관객수간의 관계hwind &lt;- all2 %&gt;% ggplot(aes(mean_high_wind, a_aud, color = covid))+ geom_point(show.legend = T, alpha=1)+ scale_y_log10()+ theme_bw()+ labs(x = \"평균적인 최고 풍속\", y = \"관객수\")hwindhwind + transition_time(year) + labs(title = \"Year: {frame_time}\")+ ease_aes('sine-in-out')# 치료중인 확진자 수과 관객수간의 관계care &lt;- all2 %&gt;% ggplot(aes(careCnt,a_aud, color = covid))+ geom_point(show.legend = T, alpha=1)+ scale_y_log10()+ theme_bw()+ labs(x = \"치료중인 확진자 수 \", y = \"관객수\")carecare + transition_time(year) + labs(title = \"Year: {frame_time}\")+ ease_aes('sine-in-out')# 누적 확진자 수과 관객수간의 관계cumu &lt;- all2 %&gt;% ggplot(aes(decideCnt,a_aud, color = covid))+ geom_point(show.legend = T, alpha=1)+ scale_y_log10()+ theme_bw()+ labs(x = \"누적 확진자 수 \", y = \"관객수\")cumucumu + transition_time(year) + labs(title = \"Year: {frame_time}\")+ ease_aes('sine-in-out')# 신규 확진자 수와 관객수 간의 관계new &lt;- all2 %&gt;% ggplot(aes(newCnt,a_aud, color = covid))+ geom_point(show.legend = T, alpha=1)+ scale_y_log10()+ theme_bw()+ labs(x = \"신규 확진자 수 \", y = \"관객수\")newnew + transition_time(year) + labs(title = \"Year: {frame_time}\")+ ease_aes('sine-in-out')# research volumeresearch &lt;- all2 %&gt;% ggplot(aes(research_volume, a_aud, color = covid))+ geom_point(show.legend = T, alpha=1)+ scale_y_log10()+ theme_bw()+ labs(x = \"검색량\", y = \"관객수\")researchresearch + transition_time(year) + labs(title = \"Year: {frame_time}\")+ ease_aes('sine-in-out')# 최고 풍속과 관객 수## 미세먼지에는 영향을 받는것 같진 않다# 미세먼지 범주 추가해서 봐보자p &lt;- ggplot(data=all2)+ geom_point(aes(x=mean_high_wind, y=a_aud))pp+ facet_grid(covid~weekdays_kind)+ scale_colour_viridis_d(option = \"inferno\")# 불쾌지수도 딱히p1 &lt;- ggplot(data=all2)+ geom_point(aes(x=mean_high_wind, y=a_aud,color= d_index))p1+facet_grid(covid~weekdays_kind)+ scale_colour_viridis_d(option = \"inferno\")# 신규확진자 수와 관객 수p2 &lt;- ggplot(data=all2)+ geom_point(aes(x=newCnt, y=a_aud,color= pm))p2+facet_grid(covid~weekdays_kind)+ scale_colour_viridis_d(option = \"inferno\")# 뚜렷한 경향성을 보이는 변수는 찾지 못함################# 월 단위 ############# 18/19/20/21년 월 단위 평균 관객 수all_2_2018 = all2 %&gt;% filter(year == 2018) %&gt;% group_by(month) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2019 = all2 %&gt;% filter(year == 2019) %&gt;% group_by(month) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2020 = all2 %&gt;% filter(year == 2020) %&gt;% group_by(month) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2021 = all2 %&gt;% filter(year == 2021) %&gt;% group_by(month) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2018 = all_2_2018 %&gt;% mutate(year = 2018)all_2_2019 = all_2_2019 %&gt;% mutate(year = 2019)all_2_2020 = all_2_2020 %&gt;% mutate(year = 2020)all_2_2021 = all_2_2021 %&gt;% mutate(year = 2021)month = rbind(all_2_2018,all_2_2019,all_2_2020,all_2_2021) %&gt;% arrange(month)month# c = month %&gt;% ggplot(aes(month, mean_audience))+ geom_bar(stat = 'identity')+ theme_bw()c = c+facet_wrap(~year)+ scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9,10,11,12))+ theme_minimal()+ theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank())+ ggtitle('월별 평균 관객 수')+ theme(plot.title = element_text(colour = 'black', size=20))+ theme(axis.title.x = element_text(colour = 'blue',size = 12), axis.title.y = element_text(color = 'blue', size = 12))c# animation c +transition_states(year, state_length = 8, transition_length = 3) + ease_aes('quintic-in')################# 요일 단위 ############# 18/19/20/21년 요일 단위 평균 관객 수all_2_2018 = all2 %&gt;% filter(year == 2018) %&gt;% group_by(weekdays) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2019 = all2 %&gt;% filter(year == 2019) %&gt;% group_by(weekdays) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2020 = all2 %&gt;% filter(year == 2020) %&gt;% group_by(weekdays) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2021 = all2 %&gt;% filter(year == 2021) %&gt;% group_by(weekdays) %&gt;% summarise(mean_audience = mean(a_aud))all_2_2018 = all_2_2018 %&gt;% mutate(year = 2018)all_2_2019 = all_2_2019 %&gt;% mutate(year = 2019)all_2_2020 = all_2_2020 %&gt;% mutate(year = 2020)all_2_2021 = all_2_2021 %&gt;% mutate(year = 2021)weekdays = rbind(all_2_2018,all_2_2019,all_2_2020,all_2_2021)# d = weekdays %&gt;% ggplot(aes(weekdays, mean_audience))+ geom_bar(stat = 'identity')+ theme_bw()+facet_wrap(~year)+scale_x_discrete(labels = c('Fri','Mon','Sat','Sun','Thu','Tue','Wed'))d = d+theme_minimal()+ theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank())+ ggtitle('요일별 평균 관객 수')+ theme(plot.title = element_text(colour = 'black', size=20))+ theme(axis.title.x = element_text(colour = 'blue',size = 12), axis.title.y = element_text(color = 'blue', size = 12))d# animation d +transition_states(year, state_length = 8, transition_length = 3) + ease_aes('quintic-in')# EDA 과정에서 통계적 분석###### statistical test ######## one-way anova# 모집단의 분산이 다를 때 표본의 평균차이를 검정하는 Welch Test 확인# p-value가 작다? : 등분산성 만족하지 않음bartlett.test(a_aud ~ covid, data = all)welch.test(a_aud~ covid, data = all)bartlett.test(a_aud ~ weekdays, data = all)welch.test(a_aud~ weekdays, data = all)bartlett.test(a_aud ~ weekdays_kind, data = all)welch.test(a_aud~ weekdays_kind, data = all)bartlett.test(a_aud ~ d_index, data = all) # 등분산 만족summary(aov(a_aud~ d_index, data=all)) # 평균간 차이가 없다!# y를 scaling해보고 시도해보자## box-cox 변환hist(all$a_aud)hist(log(all$a_aud))boxCox(all$a_aud~1)a = boxCox(all$a_aud~1)awhich.max(a$y) # 55 indexa$x[55]all_box = all %&gt;% mutate(a_aud = (a_aud^0.1818182-1)/0.1818182)hist(all_box$a_aud)all_box = all %&gt;% mutate(a_aud = (a_aud^0.1818182-1)/0.1818182)bartlett.test(a_aud ~ covid, data = all_box)bartlett.test(a_aud ~ weekdays, data = all_box)bartlett.test(a_aud ~ weekdays_kind, data = all_box) # 얘만 등분산 만족하지 않음bartlett.test(a_aud ~ d_index, data = all_box)# 추가 testwelch.test(a_aud~ weekdays_kind, data = all_box)summary(aov(a_aud ~ covid, data = all_box))summary(aov(a_aud ~ weekdays, data = all_box))summary(aov(a_aud ~ weekdays_kind, data = all_box))summary(aov(a_aud ~ d_index, data = all_box)) # 혼자 중요하지 않네# weekdays는 그룹이 7개이기 때문에 multiple comparison 필요attach(all_box)weekdays &lt;- factor(weekdays)levels(weekdays) &lt;- c(\"mon\",'tue','wed','thu','fri','sat','sun')tapply(a_aud,weekdays,mean)tapply(a_aud,weekdays,sd)# one way anova - multiple comparison 자주 사용되는 (holm : 본페르니보다 덜 보수적)pairwise.t.test(a_aud, weekdays, \"bonferroni\")pairwise.t.test(a_aud, weekdays, \"holm\")# 결론 : 두 방법 모두 (월요일,금요일),(월요일과 일요일),(화요일과 금요일),(화요일과 토요일),(수요일과 목요일),(금요일과 토요일),(금요일과 일요일)은 모평균의 차이가 없다 # 차이가 있는 요일쌍은 (월,화) (월,수) (월,목) (월,토) (화,수) (화,목) (화,일) (수,금) (수,토) (수,일) (목,토) (목,금) (목,일) (토,일)# 오늘 영화관에 사람이 많다면, 언제가야 사람이 적을까에 대한 고찰 가능#1# covid &amp; 평일여부interaction.plot(x.factor = all_box$covid, trace.factor = all_box$weekdays_kind, response = all_box$a_aud, fun = mean, type = \"b\", legend = TRUE, xlab = \"covid\", ylab=\"영화관객 수\", pch=c(1,19), col = c(\"#00AFBB\", \"#E7B800\") , main = 'Covid &amp; 평일여부', trace.label = \"평일 여부\",lwd = 2)#2# covid &amp; 요일interaction.plot(x.factor = all_box$covid, trace.factor = all_box$weekdays, response = all_box$a_aud, fun = mean, type = \"b\", legend = TRUE, xlab = \"covid\", ylab=\"영화관객 수\", pch=c(1,19), col = 1:7, main = 'Covid &amp; 요일', trace.label = \"요일\",lwd = 2)boxplot(a_aud ~ covid * weekdays, data=all_box, frame = F, col=4:5, xlab = 'covid*요일',ylab=\"영화관객 수\")#3# 요일 &amp; 평일여부interaction.plot(x.factor = all_box$weekdays_kind, trace.factor = all_box$weekdays, response = all_box$a_aud, fun = mean, type = \"b\", legend = TRUE, xlab = \"요일\", ylab=\"영화관객 수\", pch=c(1,19), col = 10:16, main = '요일 &amp; 평일여부', trace.label = \"평일 여부\",lwd = 2)#4# covid &amp; 미세먼지all_box_pm = all_box %&gt;% mutate(pm = ifelse(pm&lt;=30, '좋음', ifelse(pm&lt;=80, '보통', ifelse(pm&lt;=150,'나쁨','매우나쁨'))))# 순서형 범주로 만들어야함all_box_pm[,\"pm\"] &lt;- factor(all_box_pm[, \"pm\"], ordered=TRUE)levels(all_box_pm$pm) = c('좋음','보통','나쁨','매우 나쁨')table(all_box_pm$pm)# 미세먼지와 코로나 전후 변수 사이 교호작용 존재 Xall_box_pm %&gt;% ggline(x = \"covid\", y = \"a_aud\", color = \"pm\", add = c(\"mean_se\"), colour = c(\"#00AFBB\", \"#E7B800\",'#FC4E07','#GA3E07'))boxplot(a_aud ~ covid * pm, data=all_box_pm, frame = FALSE, col = 3:4, xlab = 'covid*미세먼지',ylab=\"영화관객 수\")#5 평일여부 &amp; 미세먼지interaction.plot(x.factor = all_box$weekdays_kind, trace.factor = all_box_pm$pm, response = all_box$a_aud, fun = mean, type = \"b\", legend = TRUE, xlab = \"평일 여부\", ylab=\"영화관객 수\", pch=c(1,19), col = 5:8, main = '미세먼지 &amp; 평일여부', trace.label = \"미세먼지 정도\",lwd = 2)#6 요일 &amp; 미세먼지interaction.plot(x.factor = all_box$weekdays, trace.factor = all_box_pm$pm, response = all_box$a_aud, fun = mean, type = \"b\", legend = TRUE, xlab = \"요일\", ylab=\"영화관객 수\", pch=c(1,19), col = 5:8, main = '미세먼지 &amp; 요일', trace.label = \"미세먼지 정도\",lwd = 2)## two way anova test#1aov1 &lt;- aov(a_aud ~ weekdays_kind + covid + weekdays_kind*covid, data = all_box)summary(aov1) #2aov2 &lt;- aov(a_aud ~ weekdays + covid + weekdays*covid, data = all_box_pm)summary(aov2)#3aov3 &lt;- aov(a_aud ~ weekdays + weekdays_kind + weekdays*weekdays_kind, data = all_box_pm)summary(aov3)#4aov4 &lt;- aov(a_aud ~ pm + covid + pm*covid, data = all_box_pm)summary(aov4)#5aov5 &lt;- aov(a_aud ~ pm + weekdays_kind + pm*weekdays_kind, data = all_box_pm)summary(aov5)#6aov6 &lt;- aov(a_aud ~ pm + weekdays + pm*weekdays, data = all_box_pm)summary(aov6)#7aov7 &lt;- aov(a_aud ~ pm + weekdays + weekdays_kind+ covid, data = all_box_pm)summary(aov7)# 3-way anovareplications(a_aud~ covid*weekdays*weekdays_kind, data=all_box)with(all_box, tapply(a_aud, list(covid, weekdays), mean));with(all_box, tapply(a_aud, list(covid, weekdays_kind), mean));with(all_box, tapply(a_aud, list(weekdays, weekdays_kind), mean));#8aov_v &lt;- aov(a_aud ~ covid*weekdays*weekdays_kind, data=all_box)summary(aov_v)TukeyHSD(aov_v, conf.level=.95)options('contrasts')summary.lm(aov_v)### Modeling ###all_box = all_box %&gt;% select(-c(Date))m3 = lm(a_aud ~., data=all_box)summary(m3) # 0.81 # 모든 변수포함m4 = lm(a_aud ~ a_screen+covid+weekdays+weekdays_kind+covid*weekdays_kind + decideCnt + careCnt + d_val , data = all_box) # 상호작용 텀 추가 : 0.805summary(m4)m5 = lm(a_aud ~ a_screen+covid+weekdays+weekdays_kind+decideCnt + careCnt + d_val , data = all_box)summary(m5)m5 %&gt;% durbinWatsonTest()# 회귀 진단par(mfrow = c(2,2))m4 %&gt;% plotm4 %&gt;% durbinWatsonTest()m4%&gt;% residuals %&gt;% durbinWatsonTest() # 독립성 위반 # -&gt; 시계열모형 고려를 해야한다.m4%&gt;% residuals %&gt;% shapiro.test() # 정규성 만족a = all %&gt;% select(-c(Date))v = lm(a_aud~., data=a)summary(v)# 자기상관 모델par(mfrow=c(1,1))plot(a$a_aud, type=\"b\")z &lt;- acf(a$a_aud, type=c('correlation'),plot=TRUE)round(z$acf,4)# User Defined Function of Autocorrelationacf_func &lt;- function(y, lag_k){ # y: input vector # lag_k : Lag order of k N = length(y) # total number of observations y_bar = mean(y) # Variance var = sum((y - y_bar)^2) / N # Autocovariance auto_cov = sum((y[1:(N-lag_k)] - y_bar) * (y[(1+lag_k):(N)] - y_bar)) / N # Autocorrelation coefficient = Autocovariance / Variance r_k = auto_cov / var return(r_k) }acf &lt;- data.frame()y = all_box$a_audfor (k in 0:(length(y)-1)){ acf_k &lt;- round(acf_func(y, lag_k = k), 4) acf[k+1, 'lag'] = k acf[k+1, 'ACF'] = acf_k}acf %&gt;% head()N &lt;- length(y)qnorm(0.975, mean=0, sd=1, lower.tail=TRUE)/ sqrt(N)# 1.96 / 루트(1096)qnorm(0.025, mean=0, sd=1, lower.tail=TRUE)/ sqrt(N)# 시계열 분석 #all %&gt;% head()before_c = a %&gt;% filter(covid == 'before')before_c %&gt;% nrow()after_c = a %&gt;% filter(covid == 'after')after_c %&gt;% nrow()plot.ts(cbind(before_c$Date, before_c$a_aud), main = '추세선')plot.ts(cbind(after_c$Date, after_c$a_aud), main = '추세선')# 전처리 간단한# 시계열 .... y값만 가지고 y값을 예측한다 # y값만 이용a$a_audall2$a_aud# 월마다 평균 (관객 수를 월마다 평균)all2 %&gt;% head()all3 = all2 %&gt;% mutate(ym = ifelse(nchar(month)==1,'one','two'))nrow(all3)p = all3 %&gt;% filter(ym =='one') %&gt;% mutate(month = paste0('0',month), ym = paste0(year,month)) q = all3 %&gt;% filter(ym !='one') %&gt;% mutate(ym = paste0(year,month)) all3 = rbind(p,q) # 2018년 5월 / 18년 6월 ... 21년 5월 .. 관객수의 평균# 2018 + 05 -&gt; 201805 .. 문자열 all3ts = all3 %&gt;% group_by(ym) %&gt;% summarise(m = mean(a_aud)) tsdata = ts$mdata# 시계열 자료형성tsdata &lt;- ts(data, start = c(2018,5), frequency = 12)tsdata# 추세선 확인par(mfrow = c(1,1))ts.plot(tsdata)# 시계열 분해plot(stl(tsdata, 'periodic'))# 변동 요인제거t &lt;- decompose(tsdata)attributes(t)plot(t)# 계절요인 제거 rm_season = tsdata - t$seasonalplot(rm_season)# 추세요인 제거rm_trend = tsdata - t$trendplot(rm_trend)# 불규칙 요인만 확인random = t$randomplot(random)# 자기상관 함수acf(na.omit(tsdata, main = '자기상관함수', col='red'))acf(na.omit(rm_season, main = '자기상관함수', col='red'))acf(na.omit(rm_trend, main = '자기상관함수', col='red'))acf(na.omit(random, main = '자기상관함수', col='red'))# 부분 자기상관 함수pacf(na.omit(tsdata, main = '자기상관함수', col='red'))pacf(na.omit(rm_season, main = '자기상관함수', col='red'))pacf(na.omit(rm_trend, main = '자기상관함수', col='red'))pacf(na.omit(random, main = '자기상관함수', col='red'))# 차분 시각화plot(diff(tsdata, differnces=1))plot(diff(rm_season, differnces=1))par(mfrow= c(1,2))ts.plot(tsdata)diff &lt;- diff(tsdata)plot(diff)library(forecast)# 시계열 모형 식별ts_model &lt;- auto.arima(tsdata)ts_modelmodel &lt;- arima(tsdata, c(0,1,0), seasonal = list(order = c(1,0,0)))modeltsdiag(model)# 자기상관 없고, 규칙성 없음 Box.test(model$residuals, lag=1, type = 'Ljung')par(mfrow=c(2,2))fore &lt;- forecast(model,h=3)plot(fore)fore2 &lt;- forecast(model, h=6)fore2plot(fore2)fore3 &lt;- forecast(model, h=12)fore3plot(fore3)fore4 &lt;- forecast(model, h=24)fore4plot(fore4)forefore2fore3fore4# 이동평균법 vs 지수평활법#install.packages('TTR')library(TTR)###### graph ######library(car)library(MASS)library(leaps)library(corrplot)library(glmnet)######### 본격적인 모델링# best subset selection ## 요일 포함 bs - 0.79# 요일 포함하는게 나음bs = regsubsets(a_aud~., data=all_box, nbest=1)bs1 = summary(bs)bs1$adjr2bs1$bicbs1$cpround(coef(bs,5),5)names(coef(bs,8))[2:9]par(mfrow =c(2,2))plot(bs1$adjr2, xlab = '# of Variables', ylab ='AdjR2', type = 'l')l = which.max(bs1$adjr2)points(l, bs1$adjr2[l], col= 'red', cex=2, pch=20)plot(bs1$adjr2, xlab = '# of Variables', ylab ='rss', type = 'l')l = which.max(bs1$adjr2)points(l, bs1$adjr2[l], col= 'red', cex=2, pch=20)plot(bs1$cp, xlab = '# of Variables', ylab ='cp', type = 'l')l = which.min(bs1$cp)points(l, bs1$cp[l], col= 'red', cex=2, pch=20)plot(bs1$bic, xlab = '# of Variables', ylab ='bic', type = 'l')l = which.min(bs1$bic)points(l, bs1$bic[l], col= 'red', cex=2, pch=20)par(mfrow =c(2,2))plot(bs, scale='r2')plot(bs, scale='adjr2')plot(bs, scale='Cp')plot(bs, scale='bic')# forwardfw = regsubsets(a_aud~., data=all_box, nbest=1, method= 'forward')fs = summary(fw)fs$adjr2fs$bicfs$cppar(mfrow=c(1,1))plot(fs$adjr2, xlab = '# of Variables', ylab ='AdjR2', type = 'l')l = which.max(fs$adjr2)points(l, fs$adjr2[l], col= 'red', cex=2, pch=20)round(coef(fw,5),5)round(coef(fw,8),5)# backwardbk = regsubsets(a_aud~., data=all_box, nbest=1, method= 'backward')bk1= summary(bk)bk1$adjr2bk1$bicbk1$cpplot(bk1$adjr2, xlab = '# of Variables', ylab ='AdjR2', type = 'l')l = which.max(bk1$adjr2)points(l, bk1$adjr2[l], col= 'red', cex=2, pch=20)coef(bk,8)# stepwisesw = regsubsets(a_aud~., data=all_box, nbest=1, method= 'seqrep')ss = summary(sw)ss$adjr2ss$bicss$cpround(coef(bs,8),5)round(coef(fw,8),5)round(coef(bk,8),5)round(coef(sw,8),5)# 모두 동일# 회귀 진단 d = lm(a_aud~ covid+a_screen+weekdays+weekdays_kind+decideCnt+careCnt+d_val, data = all_box)summary(d) # 설명력 80.1퍼# vif checkvif(d)par(mfrow = c(3,2))plot(d, which=1:6)# cook's distancecooks.distance(d)[cooks.distance(d)&gt;1] # 0개의 influential pointlength(rstudent(d)) # 1096개# 표준잔차 &gt;2 : 이상치라고 판단 (선형회귀분석에 있어서)aa = rstudent(d)[rstudent(d)&gt;2] length(aa) # 길이 : 31idx = rownames(as.data.frame(aa))idx = as.numeric(idx)# 이상치 제거all_box = all_box[-idx,]# 확인차d2 = lm(a_aud~ covid+a_screen+weekdays+weekdays_kind+decideCnt+careCnt+d_val, data = all_box)summary(d2)vif(d2)# 0.83의 설명력plot(d2) # good fitting# 모델 검증dim(all_box) # 31개 항 제거# train_test splitlibrary(caTools)set.seed(6)train_idx = sample.split(all_box$a_aud, SplitRatio = 0.8)train = all_box[train_idx,]test = all_box[train_idx==F,]# checkdim(all_box) #1065nrow(train) #852nrow(test) #213# x,y splity_train = train[,c('a_aud')]x_train = train %&gt;% select(-c(a_aud))y_test = test[,c('a_aud')]x_test = test %&gt;% select(-c(a_aud))predict(d2, newdata = test, interval = 'confidence')base_yhat = predict(d2, newdata = test)base_yhat# test mse functiontest_mse &lt;- function(true_y, yhat) mean((true_y-yhat)^2)# baseline : 변수 선택없이 회귀 # 18.10643test_mse(base_yhat, y_test)test_mse(base_yhat, y_test)# 변수선택한 회귀# 변수를 몇개 선택해야할까?predict.regsubsets = function(object,newdata,id,...){ form = as.formula(object$call[[2]]) # object은 regsubsets() object mat = model.matrix(form,newdata) # model.matrix(model fit한 formula, data) coefi = coef(object, id=id) # regsubsets() 결과에서 var이 ~개일 때의 coef 저장하기 xvars = names(coefi) # coefi 칼럼명 뽑아내기 mat[,xvars]%*%coefi}cc = regsubsets(a_aud~., data=all_box, nbest=1, nvmax=19)val.error = rep(0,19)for (i in 1:19){ yhat = predict.regsubsets(cc,newdata = test, i) val.error[i] = test_mse(y_test,yhat)}which.min(val.error)val.error # MSE# 계속 줄어드는 양상... but 차원까지 생각해서# id = 19, 15.70039 최저 ... id=5 , 22.03 / id=12, 16.63519# y 변수 : box-cox# x 변수 : 어떠한 변환도 없음# 이 이후부터## x 변수에 scaling 적용한다면?# standardscalingstr(x_train)# all_box2 : x변수 스케일링, y변수 box cox O# all_box : x변수 스케일링 X, y변수 box cox O# scaling 한 df 를 따로 만들기all_box2 = all_boxfor (i in 1:length(all_box2)){ if (colnames(all_box2[i]) != 'covid' &amp; colnames(all_box2[i]) != 'weekdays' &amp; colnames(all_box2[i]) != 'weekdays_kind' &amp; colnames(all_box2[i]) != 'd_index' &amp; colnames(all_box2[i]) != 'a_aud'){ all_box2[,i] = scale(all_box2[,i]) all_box2[,i] = as.vector(all_box2[,i]) }}str(all_box2)# 다시 스플릿set.seed(6)train_idx = sample.split(all_box2$a_aud, SplitRatio = 0.8)train = all_box2[train_idx,]test = all_box2[train_idx==F,]# checkdim(all_box2) #1065nrow(train) #852nrow(test) #213# x,y splity_train = train[,c('a_aud')]x_train = train %&gt;% select(-c(a_aud))y_test = test[,c('a_aud')]x_test = test %&gt;% select(-c(a_aud))dd = regsubsets(a_aud~., data=all_box2, nbest=1, nvmax=19)val.error = rep(0,19)for (i in 1:19){ yhat = predict.regsubsets(dd,newdata = test, i) val.error[i] = test_mse(y_test,yhat)}which.min(val.error)val.errorround(coef(dd,5),5)round(coef(cc,5),5) # 달라지지 않음 # 어차피 예측값도 같고, coef도 같아서!# all_box로 해도 되고 all_box2로 해도 됨################################## cv # Ridge, Lasso 돌리려면 더미변수로 만들어야한다# cv 돌리기 전# all_box = 더미 변수 만들기 전# all_new2 = 더미변수 만든 후str(all_box)all_dummy = all_box %&gt;% mutate(weekdays_kind = ifelse(weekdays_kind == 'on',1,0), weekdays = ifelse(weekdays == 'Sunday',0, ifelse(weekdays == 'Monday',1, ifelse(weekdays == 'Tuesday',2, ifelse(weekdays == 'Wednesday',3, ifelse(weekdays == 'Thursday',4, ifelse(weekdays == 'Friday',5,6)))))), d_index = ifelse(d_index == 'comfy',0,1), covid = ifelse(covid == '후',1,0)) table(all_dummy$weekdays)# Re - splitset.seed(6)train_idx = sample.split(all_dummy$a_aud, SplitRatio = 0.8)train = all_dummy[train_idx,]test = all_dummy[train_idx==F,]# checkdim(all_dummy) #1065nrow(train) #852nrow(test) #213# x,y splity_train = train[,c('a_aud')]x_train = train %&gt;% select(-c(a_aud))y_test = test[,c('a_aud')]x_test = test %&gt;% select(-c(a_aud))str(all_dummy)str(x_train)######## Ridge ######### ridge 1 : 모든 변수를 이용해서 ridge cvfit1 &lt;- glmnet(as.matrix(x_train), as.matrix(y_train), family= 'gaussian', alpha = 0)cv1 &lt;- cv.glmnet(as.matrix(x_train), as.matrix(y_train), family = 'gaussian', alpha = 0)cv1$lambda.min # 0.6503258coef(cv1, s='lambda.min')par(mfrow = c(2,2))plot(fit1, xvar='lambda')plot(cv1)log(0.067) # -2.7 # log(lambda)가 -2.7일때 최저의 mse# 최적의 람다로 재피팅 후 predict 구하기ridge1.fit &lt;- glmnet(as.matrix(x_train), as.matrix(y_train), family = 'gaussian',alpha=0, lambda = cv1$lambda.min)ridge1_coef = predict(ridge.fit, s=cv1$lambda.min, type = 'coefficients',newdata=test)ridge1_coef = round(ridge1_coef,4)ridge1_coef# newdata를 쓰나 안쓰나 coefficient 값은 동일ridge1.yhat &lt;- predict(ridge1.fit, s=cv1$lambda.min, newx = as.matrix(test.x))te.mse(yhat, test_y) # OLS :0.3470985te.mse(ridge1.yhat, test.y) # ridge : 0.2934386## ridge 2 : 8개 변수만을 이용해서 ridge cvsummary(d2)# weekday_kindon / covid후 / a_released / a_screen / careCnt / mean_high_wind / mean_av_wind / count# -&gt; weekdays_kind / covid / a_released / a_screen / careCnt / mean_high_wind / mean_av_wind / counttrain.xx = train.x %&gt;% select(weekdays_kind, covid, a_released, a_screen, careCnt, mean_high_wind, mean_av_wind, count)test.xx = test.x %&gt;% select(weekdays_kind, covid, a_released, a_screen, careCnt, mean_high_wind, mean_av_wind, count)test_new = test %&gt;% select(a_aud, weekdays_kind, covid, a_released, a_screen, careCnt, mean_high_wind, mean_av_wind, count)# train.y는 동일fit2 &lt;- glmnet(as.matrix(train.xx), as.matrix(train.y), family= 'gaussian', alpha = 0)cv2 &lt;- cv.glmnet(as.matrix(train.xx), as.matrix(train.y), family = 'gaussian', alpha = 0)cv2$lambda.min # 0.06703521 -&gt; 0.0670562ridge2_coef = round(coef(cv2, s='lambda.min'),4)ridge2_coef # 차이가 있음par(mfrow = c(1,1))plot(fit2, xvar='lambda')plot(cv2)log(0.067) # -2.7 # log(lambda)가 -2.7일때 최저의 mse# 8개 변수만으로 fitting# 최적의 람다로 재피팅 후 predict 구하기ridge2.fit &lt;- glmnet(as.matrix(train.xx), as.matrix(train.y), family = 'gaussian',alpha=0, lambda = cv2$lambda.min)ridge2_coef = predict(ridge2.fit, s=cv2$lambda.min, type = 'coefficients',newdata=test_new)ridge2_coef = round(ridge2_coef,4)ridge2_coefridge1_coef # 비교# newdata를 쓰나 안쓰나 coefficient 값은 동일ridge2.yhat &lt;- predict(ridge2.fit, s=cv2$lambda.min, newx = as.matrix(test.xx))te.mse(yhat, test_y) # OLS :0.3470985te.mse(ridge1.yhat, test.y) # ridge : 0.2934386te.mse(ridge2.yhat, test.y) # ridge : 0.2866408###### Lasso ######## lasso 1 : 모든 변수를 이용해서 lasso cvfit3 &lt;- glmnet(as.matrix(train.x), as.matrix(train.y), family= 'gaussian', alpha = 1)cv3 &lt;- cv.glmnet(as.matrix(train.x), as.matrix(train.y), family = 'gaussian', alpha = 1)cv3$lambda.min # 0.001444682coef(cv3, s='lambda.min')par(mfrow = c(1,1))plot(fit3, xvar='lambda')plot(cv3)log(0.001444682) # -6.539866# 최적의 람다로 재피팅 후 predict 구하기lasso1.fit &lt;- glmnet(as.matrix(train.x), as.matrix(train.y), family = 'gaussian',alpha=1, lambda = cv3$lambda.min)lasso1_coef = predict(lasso1.fit, s=cv3$lambda.min, type = 'coefficients',newdata=test)lasso1_coef = round(lasso1_coef,4)lasso1_coef # coef(cv3, s='lambda.min')와 같음lasso1.yhat &lt;- predict(lasso1.fit, s=cv3$lambda.min, newx = as.matrix(test.x))te.mse(lasso1.yhat, test.y) # lasso : 0.3013272## lasso 2 : 8개 변수를 이용해서 lasso_cvtrain.xx = train.x %&gt;% select(weekdays_kind, covid, a_released, a_screen, careCnt, mean_high_wind, mean_av_wind, count)test.xx = test.x %&gt;% select(weekdays_kind, covid, a_released, a_screen, careCnt, mean_high_wind, mean_av_wind, count)# train.y는 동일fit4 &lt;- glmnet(as.matrix(train.xx), as.matrix(train.y), family= 'gaussian', alpha = 1)cv4 &lt;- cv.glmnet(as.matrix(train.xx), as.matrix(train.y), family = 'gaussian', alpha = 1)cv4$lambda.min # 0.001444682 -&gt; 0.0008267002 (더 낮아짐)lasso2_coef = round(coef(cv4, s='lambda.min'),4)lasso2_coef # 차이가 있음par(mfrow = c(2,2))plot(fit4, xvar='lambda')plot(cv4)log(0.0008267002) # -7.098068# 8개 변수만으로 fitting# 최적의 람다로 재피팅 후 predict 구하기lasso2.fit &lt;- glmnet(as.matrix(train.xx), as.matrix(train.y), family = 'gaussian',alpha=1, lambda = cv4$lambda.min)lasso2_coef = predict(lasso2.fit, s=cv4$lambda.min, type = 'coefficients',newdata=test_new)lasso2_coef = round(lasso2_coef,4)lasso2_coef# newdata를 쓰나 안쓰나 coefficient 값은 동일lasso2.yhat &lt;- predict(lasso2.fit, s=cv4$lambda.min, newx = as.matrix(test.xx))te.mse(lasso2.yhat, test.y) # lasso : 0.292503# 랜덤포레스트와 부스팅은 나중에# ###################### all_box = 더미 변수 만들기 전# all_new2 = 더미변수 만든 후# random forest 적용하려고 만든 코드all_dummy = all_1_noout %&gt;% mutate(weekdays_kind = ifelse(weekdays_kind == 'on',1,0), d_index = ifelse(d_index == 'comfy',0,1), covid = ifelse(covid == '후',1,0)) str(all_dummy)## 더미변수 만든 후 모델 돌려보기# 더미변수 만들기 전과 비교해보았을 때 summary 결과가 같음d_dummy = lm(a_aud~ weekdays_kind+covid+a_released+a_screen+careCnt+mean_high_wind+mean_av_wind+count, data=all_dummy)summary(d_dummy)par(mfrow = c(3,2))plot(d_new, which=1:6)head(all_1_noout)str(all_1_noout)set.seed(10)idx &lt;- createDataPartition(all_dummy$weekdays_kind, p=0.8, list=F)length(idx)train &lt;- all_1_noout[idx,]test &lt;- all_1_noout[-idx,]nrow(all_dummy) # 1051nrow(train) # 842nrow(test) # 209test_y = test$a_audstr(all_dummy)# 에러 : variables ‘weekdays_kind’, ‘covid’ were specified with different types from the fit# predict(d_dummy, newdata = test, interval = 'confidence')# yhat = predict(d_dummy, newdata = test)# yhat# # yhat - test_y# # mean(abs(yhat- test_y)) # MAE : 0.4575668# # mean((yhat- test_y)^2) #MSE : 0.3470985# # sqrt(mean((yhat- test_y)^2)) # rMSE : 0.5891507# # summary(d_new) # 67퍼의 설명력# tidymodels 이용하기 ### 랜덤포레스트 #### RFlibrary(tidyverse)library(tidymodels)# install.packages('tidymodels')str(all)split &lt;- all_box %&gt;% select(-c(Date,covid,weekdays,weekdays_kind,d_index))%&gt;% initial_split(prop=0.8)splitsplit %&gt;% training()split %&gt;% testing()str(split)# 모든 변수 다 사용해보기 # x 변수 : 16개recipe &lt;- split %&gt;% training() %&gt;% recipe(a_aud ~. ) %&gt;% step_corr(all_predictors()) %&gt;% step_center(all_predictors(), -all_outcomes()) %&gt;% step_scale(all_predictors(), -all_outcomes()) %&gt;% prep()recipe # 다중공산성 문제는 없음testing &lt;- recipe %&gt;% bake(split %&gt;% testing()) # juicetraining &lt;- recipe %&gt;% juice()training# modelingrf &lt;- rand_forest(trees=100, mode='regression') %&gt;% set_engine('randomForest') %&gt;% fit(a_aud~., data= training)rfrf %&gt;% predict(testing)rf %&gt;% predict(testing) %&gt;% bind_cols(testing)# 성능 검증rf %&gt;% predict(testing) %&gt;% bind_cols(testing) %&gt;% metrics(truth = a_aud, estimate= .pred)# 랜덤포레스트 - adjR^2: 0.812pred = rf %&gt;% predict(testing)pred = pred$.predreal_y = testing$a_auderror = (pred - real_y)/real_ymean(error)### 0601 shiny 활용library(shiny)getwd()setwd(\"C:/Users/eric3/Documents/AI 프로젝트/0524/final_cor/shiny\")getwd()runApp() " }, { "title": "[RL] 강화 학습 개념과 마르코프 결정, 벨만 방정식, 정책 반복법, 모델 기반 강화학습", "url": "/posts/01-rl/", "categories": "Study, AI", "tags": "AI, ReinforcementLearning, MDP, Markov Decision Process, Markov, Bellman, Bellman Equation, Model Based Reinforcement Learning, Model Based", "date": "2021-08-19 00:00:00 +0900", "snippet": "본 포스팅은 “Do it! 강화 학습 입문” - (이지스퍼블리싱, 조규남, 맹윤호, 임지순 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 강화학습 마르코프 결정 (MDP, Markov Decision Process) 영화를 예시로 바라보는 마르코프 결정 상태, 행동, 보상 행동에 의한 상태 전이에 확률 도입 벨만 방정식 (Bellman Equation) 보상 총합이 무한으로 발산하는 문제 시간에 따른 할인 개념 도입하기 보상 총합, 가치 함수 현재 상태의 가치 구하기, 벨만 방정식 정책 정책 반복법 1. 강화학습 (Reinforcement Learning)머신러닝 (Machine Learning)은 크게 다음과 같이 나눌 수 있다. 지도학습 (Supervised Learning) 데이터와 레이블이 주어진 상태에서, 새 데이터에 레이블을 매기는 방법을 학습. 비지도학습 (Un-Supervised Learning) 레이블 없이 데이터만 주어진 상태에서, 새 데이터의 분류, 밀도 추정 등의 방법을 학습. 특징을 요약할 때 등. 강화학습 (Reinforcement Learning) 행동과 보상으로, 어떤 상태에서 최적의 행동을 찾아가는 방법을 학습. 1906년 마르코프 결정 과정(MDP, Markov Decision Process), 1950년 동적 계획법 (DP, Dynamic Programming)의 오랜 역사 이후, 강화학습은 딥러닝과의 결합 (대표적으로 DQN, Deep Q-Network)으로 다시 주목 받고 있다.강화학습의 공부 방향강화학습의 기본인 MDP의 용어들과 그 의미, 모델 기반 강화 학습, 모델 프리 강화 학습, 시간차 학습, Q 학습.이후 CNN (Convolution Neural Network)과 결합한 DQN나 PPO, GPT 등으로 공부 방향을 잡으면 될 것 같다.내가 내린 강화 학습의 짧막한 요약은 다음과 같다.“강화 학습은 상태에서 행동에 대한 보상을 최적화 하는 함수, 정책 (Policy)을 찾는 것.” 강화 학습은 지금 상태에서 해야 할 최적의 행동이 무엇인지 방향을 세워 나가는 과정이다.2. 마르코프 결정 (MDP, Markov Decision Process) 마르코프 결정 과정 (MDP, Markov Decision Process)은 의사 결정을 하는데 필요한 체계로 볼 수 있다.영화를 예시로 바라보는 마르코프 결정책에서는 이를 설명하기 위해 예시로 영화 엣지 오브 투모로우를 들고 있다. 엣지 오브 투모로우 (Edge of Tomorrow, 2014) 주인공 빌 케이지(톰 크루즈)는 외계인이 점령한 지구를 해방하기 위한 인류 연합군에서 상륙작전에 투입되고, 우연히 외계인의 시간 리셋 능력을 얻고죽을 때마다 작전의 전날에 부활한다. 케이지는 전투와 사망을 수백 번 반복하며, 인류의 승리를 위해 싸워나간다.강화학습의 관점에서 해당 줄거리를 바라보았을 때, 다음 그림과 같이 나타낼 수 있다.강화학습에서 에이전트 (Agent)는 해당 예시에서 행동의 주체인 주인공으로 볼 수 있다.에이전트는 전투라는 환경에서 상호 작용하며 가장 큰 보상인 외계인 대장 제거를 위해,죽을 때마다 작전 전날에 부활하며 초기 상태에서 출발하여,새로운 에피소드에서 다양한 상태와 그 때의 행동을 통해 대장을 물리치는 과정을 탐색한다.\\(s_{1}\\)이나 \\(a_{1-1}\\)과 같은 표기는 각각 상태 (state)와 행동 (action)을 의미한다. 본진(\\(s_{1}\\))에서 깨어난 에이전트는 상륙 작전 전투에 참가(\\(a_{1-1}\\)), 본진 이탈(\\(a_{1-2}\\))가 가능. 상륙 작전 투입(\\(s_{2}\\))된 에이전트는 혼자 전투(\\(a_{2-1}\\)), 전투를 도울 영웅을 구출(\\(a_{2-2}\\))가 가능. 본진 이탈(\\(s_{5}\\))한 에이전트는 다시 상륙 작전(\\(a_{5-1}\\))을 향할 수도, 비밀을 조사하러 후방 연구소로 이동(\\(a_{5-2}\\)) 가능. 후방 연구소 이동(\\(s_{6}\\))한 에이전트는 전투 훈련(\\(a_{6-1}\\))을 받을 수도, 외계인 보스 조사(\\(a_{6-2}\\))도 가능.상태, 행동, 보상이런 식으로 에이전트는 시작 상태와 종단 상태를 포함한 7가지 상태,그 둘을 제외한 각 상태에서 2개의 행동을 취할 수 있다.각 상태 \\(s_{1}, s_{2}, \\ldots, s_{7}\\)의 상태 집합을 \\(S\\)로 표현하고, 행동의 집합을 \\(A(s)\\)로 표현.\\(s_{1}\\)에서 취할 수 있는 행동의 집합은 \\(A(s_{1})\\)이 된다.그림에서 각 상태에서의 보상이 명시 되어있다.\\[R(s_{3})=-1, R(s_{4})=-1, R(s_{7})=1\\]\\[R(s_{1})=R(s_{2})=R(s_{5})=R(s_{6})=0\\]행동에 의한 상태 전이에 확률 도입에이전트가 \\(s_{1}\\)에서 \\(a_{1-2}\\)를 했을 때, 상태 전이에는 확률이 있다.80% 확률로 \\(s_{5}\\), 20% 확률로 \\(s_{1}\\)로 전이될 수도 있다.상태 전이 확률 (State Transition Probablity)는 수식으로 표현가능 하며, 상태-행동 한 쌍의 전이 확률 합은 1이다.\\[P(s_{5} \\mid s_{1},a_{1-2})=0.8\\]\\[P(s_{1} \\mid s_{1},a_{1-2})=0.2\\]이런 확률의 집합을 모델 (Model)이라 한다. 표로 이들을 표현하면 다음과 같다. 상태 (Status, S) 에이전트가 환경 내 특정 시점에서 관찰할 수 있는 것을 수치화 행동 (Action, A) 에이전트가 환경에게 전달하는 입력 보상 (Reward, R) 에이전트가 환경으로부터 전달받은 목적을 달성하기 위해 행동 수행에 대한 피드백 모델 (Model, M) 행동에 따른 상태 전이가 일어날 확률을 담은 규칙 즉, MDP는 상태 집합 \\(S\\)로 이루어지며, 행동 집합 \\(A\\)가 있고,상태 \\(s\\)에서 행동 \\(a\\)를 통해 상태 \\(s^\\prime\\)로 전이할 확률은 \\(P(s^\\prime \\mid s,a)\\)이며, 보상은 \\(R(s,a)\\)이다. 마르코프 특성 (Markov Property)를 만족한다고 가정하면 모든 상태는 직전의 상태와 행동에 의해서만 결정된다.MDP에서는 에이전트의 오직 현재 상태만 다음 상태 전이 확률에 영향을 미친다. ‘과거는 상관없다’3. 벨만 방정식 (Bellman Equation)장기적 보상의 예측치를 극대화하는 행동을 찾는 것. MDP 상태 안에서 최적의 행동을 찾는 방법.에이전트가 특정 상태에서 미래 보상의 총합을 구할 수 있다고 가정하면,보상의 예측치를 최대로 만드는 상태로 가는 행동이 곧 최적의 행동이다. 같이 식을 세워나가자.보상 총합이 무한으로 발산하는 문제예시로 한 에피소드에서 에이전트가 취할 수 있는 일부 상태 경로와 그에 따른 보상의 총합은 다음과 같다. 상태 경로: \\(s_{1} \\rightarrow s_{2} \\rightarrow s_{3}\\) 보상 총합: \\(R(s_{1})+R(s_{2})+R(s_{3})\\) 상태 경로: \\(s_{1} \\rightarrow s_{5} \\rightarrow s_{2} \\rightarrow s_{3}\\) 보상 총합: \\(R(s_{1})+R(s_{5})+R(s_{2})+R(s_{3})\\) 상태 경로: \\(s_{1} \\rightarrow s_{5} \\rightarrow s_{1} \\rightarrow s_{5} \\ldots\\) 보상 총합: \\(R(s_{1})+R(s_{5})+R(s_{1})+R(s_{5})+\\ldots\\)이 때, 3번째 에피소드에서는 \\(s_{1}\\)과 \\(s_{5}\\)를 무한히 왕복하여, 보상 총합이 무한으로 발산하는 문제가 발생한다.시간에 따른 할인 개념 도입하기시간에 따른 할인 (Discount) 개념을 도입하며, 위에서 서술한 문제를 해결할 수 있다.에이전트가 최대한 가까운 시점에 보상을 얻을 수 있도록 하는 것이다.0과 1사이의 할인율을 감마 \\(\\gamma\\)로 나타내면 다음과 같다. 상태 경로: \\(s_{1} \\rightarrow s_{2} \\rightarrow s_{3}\\) 보상 총합: \\(R(s_{1})+\\gamma R(s_{2})+\\gamma ^2 R(s_{3})\\) 상태 경로: \\(s_{1} \\rightarrow s_{5} \\rightarrow s_{2} \\rightarrow s_{3}\\) 보상 총합: \\(R(s_{1})+\\gamma R(s_{5})+\\gamma ^2 R(s_{2})+\\gamma ^3 R(s_{3})\\) 상태 경로: \\(s_{1} \\rightarrow s_{5} \\rightarrow s_{1} \\rightarrow s_{5} \\ldots\\) 보상 총합: \\(R(s_{1})+\\gamma R(s_{5})+\\gamma ^2 R(s_{1})+\\gamma ^3 R(s_{5})+\\ldots\\)보상 \\(R(s)\\)의 값이 모두 1이라 가정하면, 보상 총합은 공비가 \\(\\gamma\\)인 등비급수로 \\(\\mid \\gamma \\mid &lt; 1\\)이기에 수렴한다.따라서 보상 총합이 무한으로 발산하는 문제를 해결 할 수 있다. MDP에서 보상은 상태와 행동의 함수 \\(R(s,a)\\)와마르코프 보상 과정 (MRP, Markov Reward Process)에서 사용하는 상태만의 함수인 \\(R(s)\\)는 다른 의미이지만,할인율의 개념을 간단하게 보여주기 위해 사용했다.보상 총합, 가치 함수우리는 주어진 상태에서 최적의 행동을 찾는 방법이 필요하다.한 에피소드에서 얻을 수 있는 보상 총합이 아닌, 주어진 상태에서 미래에 얻을 수 있는 보상 총합을 구해야한다.이익 (Return)은 할인율과 t번째 상태를 이용해 수식으로 다음과 같이 나타낼 수 있다.\\[G_{t}=\\sum \\limits_{k=0}^\\infty \\gamma ^k R_{t+k+1}\\]이 때, 특정 상태에서 미래에 얻을 수 있는 보상의 총합, 가치함수 (Value Function)는특정 상태에서 갈 수 있는 전체 경로에 대한 평균, 이익의 기댓값이다.\\[V(s)=E[G_{t} \\mid S_{t}=s]\\] 보상 (R) 특정 상태에서 얻을 수 있는 즉각적 피드백 이익 (G) 한 에피소드의 특정 상태에서 종단 상태까지 받을 수 있는 보상 총합 가치 함수 (V) 특정 상태로부터 기대할 수 있는 보상 예시로, 예방 주사를 맞을 때, 병원비와 아픔으로 즉각적인 보상은 음수.장기적으로 건강이라는 가치를 제공하여 가치는 양수.현재 상태의 가치 구하기, 벨만 방정식현재 상태의 가치의 기댓값을 구하는 과정은 다음과 같다. 종단 상태를 제외한 모든 상태의 가치를 0으로 초기화한다. 종단 상태는 상태 전이가 없으니, 보상=가치이다. 종단 상태와 인접한 상태의 가치를 구한다. 행동의 기대 가치에 할인율을 곱한 다음 더한다.앞서 보여준 영화 예시 그림으로 풀어 나가면 다음과 같다. 상태 \\(s_{2}\\)에서 행동 \\(a_{2-1}\\) 선택 \\(s_{3}\\)으로 전이할 확률: \\(P(s_{3} \\mid s_{2},a_{2-1})=1\\) \\(s_{3}\\)의 가치: \\(-0\\) 가치의 기댓값: \\(s_{3}\\)의 보상 + \\(s_{3}\\)의 가치 \\(0\\) \\(\\times\\) 전이 확률 \\(1\\) \\(\\times\\) 할인율\\(0.9=-1\\) 상태 \\(s_{2}\\)에서 행동 \\(a_{2-2}\\) 선택 \\(s_{4}\\)으로 전이할 확률: \\(P(s_{4} \\mid s_{2},a_{2-2})=0.6\\) \\(s_{7}\\)으로 전이할 확률: \\(P(s_{7} \\mid s_{2},a_{2-2})=0.4\\) \\(s_{4}\\)의 가치: \\(0\\) \\(s_{7}\\)의 가치: \\(0\\) 가치의 기댓값: [전이 확률 \\(0.6\\) \\(\\times\\) (\\(s_{4}\\)의 보상 \\(-1\\) + \\(s_{4}\\)의 가치 \\(0\\) \\(\\times\\) 할인율 \\(0.9\\)) + 전이 확률 0.4 \\(\\times\\) (\\(s_{7}\\)의 보상 \\(1\\) + \\(s_{7}\\)의 가치 \\(0\\) \\(\\times\\) 할인율 \\(0.9\\))]\\(=-0.2\\) 이 과정을 수식으로 표현하면 다음과 같은 벨만 방정식 (Bellman Equation)이 된다.\\[V(s)=max_{a} \\sum \\limits_{s^\\prime} P(s^\\prime \\mid s,a)[R(s,a)+\\gamma V(s^\\prime)]\\]벨만 방정식은 다음 상태의 가치를 사용해서 현재 상태의 가치를 구한다.현재를 구하기 위해 다음 상태를 계속 추적하여, 결국 종단 상태에 도달한다.이를 코드로 구현하면 동적 계획법 (Dynamic Programming)이라는 알고리즘을 사용한다.이처럼 동적 계획법을 기반으로 가치 함수를 산출하는 방식을 가치 반복법 (Value Iteration)이라 한다.이제 우리는 미래 보상을 최대화하는 최적 행동을 선택 할 수 있다.이렇게 상태를 입력으로 받아 최적 행동을 출력하는 함수를 정책 (Policy)이라 한다..이 정책이 강화 학습에서 구하고자 하는 목표이다.4. 정책정책이란 지금 상태에서 해야 할 최적의 행동이 무엇인지 알려주는 것이다.\\[\\pi (s)=a\\]강화 학습은 이 정책을 세워 나가는 과정이다.가치 반복법가치 반복법을 통해 수렴한 가치 함수는 최적의 가치 함수 (Optimal Value Function)는 \\(V\\pi (s)\\) 이다.이를 이용해 벨만 방정식을 조금 수정하면 다음과 같다.\\[\\pi (s)=\\gamma \\sum \\limits_{s^\\prime} p(s,a) V_{\\pi}(s^\\prime)\\] 가치 함수가 수렴 할 때까지 반복하기 보다는, 가치 갱신값 차이가 일정한 임곗값 이내에 들어오면 반복을 종료하는 방식을 사용하기도 한다.최적의 정책 함수는 가치 함수를 업데이트 하는 가치 반복법 외에도, 정책 함수 자체를 업데이트하는 방식으로도 구할 수 있다.정책 반복법정책 평가 (Policy Evaluation)정책 \\(\\pi (s)\\)는 처음에 무작위로 초기화한다.\\(\\pi (s)\\)가 주어진 것은 에이전트가 어떤 상황에서 어떤 행동을 해야할지 지시받았음을 의미한다.상태 \\(s\\)에서 선택할 수 있는 모든 행동에 대해 이익의 기댓값을 계산하고 최대치를 고르는 것이 아니라,주어진 행동 \\(\\pi (s)\\)에 대한 이익의 기댓값만 계산하면 된다.주어진 정책에 따라 가치 함수를 구하는 일을 정책 평가 (Policy Evaluation)라 한다.정책 개선 (Policy Improvement)가치 함수 계산을 통해, 각 상태에서 정책 \\(\\pi (s)\\)를 따라 행동했을 때와정책과 아무 관련 없는 다른 행동을 선택했을 때 어느 쪽 가치가 더 큰지 알 수 있다.정책과 무관한 다른 행동의 가치가 클 경우,기존 정책을 가치가 더 큰 새로운 행동으로 업데이트하는 것을 정책 개선 (Policy Improvement)이라 한다. 정책 평가는 정책 함수를 기반으로 가치 함수를 갱신하고, 정책 개선은 가치 함수를 기반으로 정책 함수를 갱신한다.정책 평가와 정책 개선을 반복하여, 가치 함수와 정책 함수가 변화하지 않는,가치와 정책이 모두 수렴하게 하는 이것을 정책 반복법이라 한다.\\(E \\rightarrow\\)는 정책 평가, \\(I \\rightarrow\\)를 정책 개선으로 하여 수식으로 표현하면 다음과 같다.\\[\\pi _{0} E \\rightarrow v_{\\pi 0} I \\rightarrow \\pi _{1} E \\rightarrow v_{\\pi 1} I \\rightarrow \\ldots I \\rightarrow \\pi _{*} E \\rightarrow v_{*}\\]정책 반복법은 가치 반복법 알고리즘보다 반복문도 깊고, 알고리즘 자체도 복잡하지만,상황에 따라 더 빠르게 최적의 정책 함수로 수렴하기도하여, 둘 중 절대적 우위는 없다.또한, 이들은 에이전트가 환경 안에서 가질 수 있는모든 상태와 각 상태 간의 전이 확률을 미리 안다는 전제가 깔려 있다.MDP를 이루는 구성 요소 중 모델에 대한 모든 지식을 미리 알고 있다는 것이다.종단 상태로부터 역추적해 모든 상태와 행동의 가치를 계산하는 완전 탐색이라는 특징까지도,가치 반복법과 정책 반복법은 현실 세계에 적용하기 어렵다.참고“Do it! 강화 학습 입문” - (이지스퍼블리싱, 조규남, 맹윤호, 임지순 지음) 깃허브: https://github.com/yunho0130/start-RL" }, { "title": "[ML] 머신러닝의 기본 개념과 Numpy", "url": "/posts/03-ml/", "categories": "Study, AI", "tags": "AI, MachineLearning, Anaconda, Jupyter Notebook", "date": "2021-08-17 00:00:00 +0900", "snippet": "본 포스팅은 “파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 머신러닝의 개념 머신러닝의 분류 Numpy1. 머신러닝의 개념머신러닝 (Machine Learning)은 일반적으로, 어플리케이션 수정 없이 데이터를 기반으로 패턴을 학습하고 결과를 예측하는 알고리즘 기법을 통칭.머신러닝 알고리즘은 데이터를 기반으로 통계적인 신뢰도를 강화하고, 예측 오류를 최소화하기 위한 수학적 기법을 적용.2. 머신러닝의 분류일반적으로 크게 세가지. 지도학습 (Supervised Learning) 분류 (Classification) 회귀 (Regression) 추천 시스템 시각/음성 감지/인지 텍스트분석, NLP (Natural Language Processing, 자연어처리) 비지도학습 (Un-Supervised Learning) 클러스터링 (Clustering) 차원 축소 (Dimensionality Reduction) 강화학습 (Reinforcement Learning)3. 넘파이 (Numpy)머신러닝의 가장 큰 단점은 데이터 의존적이라는 것. 좋은 품질의 데이터, 데이터 핸들링, 전처리 등이 매우 중요하다. Garbage In, Garbage Out데이터 핸들링을 하기에 앞서, Numerical Python을 의미하는 넘파이 (Numpy)는 파이썬에서 선형대수 기반 프로그래밍을 지원하는 대표 패키지이다.머신러닝의 주요 알고리즘은 선형대수, 통계 등에 기반하기에 넘파이의 대량 데이터 배열 연산 기능이 필요하다.또한 C/C++ 등의 저수준 언어 기반의 호환 API 제공으로 수행 성능도 뛰어나다.적절한 알고리즘을 선택하기 위해서, 넘파이 이해는 머신러닝에서 필수.Numpy ndarrayimport numpy as np넘파이의 기반 데이터 타입은 ndarray, 이를 이용해 다차원 배열 (Multi-dimension array)을 쉽게 생성하고 다양한 연산 수행이 가능하다.array1 = np.array([1,2,3])print('array1 type:',type(array1))print('array1 array 형태:',array1.shape)array2 = np.array([[1,2,3], [2,3,4]])print('array2 type:',type(array2))print('array2 array 형태:',array2.shape)array3 = np.array([[1,2,3]])print('array3 type:',type(array3))print('array3 array 형태:',array3.shape)print('array1: {:0}차원, array2: {:1}차원, array3: {:2}차원'.format(array1.ndim,array2.ndim,array3.ndim))[결과]array1 type: &lt;class 'numpy.ndarray'&gt;array1 array 형태: (3,)array2 type: &lt;class 'numpy.ndarray'&gt;array2 array 형태: (2, 3)array3 type: &lt;class 'numpy.ndarray'&gt;array3 array 형태: (1, 3)array1: 1차원, array2: 2차원, array3: 2차원np.array()에 입력한 인자는 ndarray로 반환. ndarray.shape는 차원과 크기를 튜플(tuple) 형태로, ndarray.ndim은 차원을 보여준다.참고“파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음) 깃허브: https://github.com/wikibook/pymldg-rev" }, { "title": "[ML] Jupyter Notebook 초기 폴더 설정", "url": "/posts/02-ml/", "categories": "Study, AI", "tags": "AI, MachineLearning, Anaconda, Jupyter Notebook", "date": "2021-08-17 00:00:00 +0900", "snippet": "Jupyter Notebook의 Default Directory는 C:\\Users\\사용자명이다.본인이 원하는 경로로 수정하여 Anaconda Prompt에서 바로 접속해보자. Anaconda3 - Jupyter Notebook - 자세히 - 파일 위치 열기 Jupyter Notebook 우클릭 - 속성 - 대상 “%USERPROFILE%/” 제거 C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\cwp.py C:\\ProgramData\\Anaconda3 C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\Scripts\\jupyter-notebook-script.py \"%USERPROFILE%/\" 위의 상태로 되어있을 것이다. 다음과 같이 바꿔주자. C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\cwp.py C:\\ProgramData\\Anaconda3 C:\\ProgramData\\Anaconda3\\python.exe C:\\ProgramData\\Anaconda3\\Scripts\\jupyter-notebook-script.py Anaconda Prompt 실행 - jupyter notebook --generate-config overwrite 해주자. jupyter_notebook_config.py 수정 ## The directory to use for notebooks and kernels. # Default: '' c.NotebookApp.notebook_dir = '경로지정' 반드시 '와 ' 사이에 폴더 경로를 넣고, 폴더간 상하 관계는 /로 표기. 확인 Anaconda Prompt에서 jupyter notebook 실행 시켜보자. 설정한 경로로 실행되면 성공! 참고 [hikwail] 님의 포스팅 Jupyter Notebook 시작경로 변경방법 [DayGo] 님의 포스팅 03. ANACONDA 초기 폴더 설정하기“파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음) 깃허브: https://github.com/wikibook/pymldg-rev" }, { "title": "[ML] 파이썬 머신러닝 환경 구성", "url": "/posts/01-ml/", "categories": "Study, AI", "tags": "AI, MachineLearning, Anaconda, Jupyter Notebook", "date": "2021-08-17 00:00:00 +0900", "snippet": "본 포스팅은 “파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음)을 바탕으로 공부한 내용을 정리한 것입니다. 머신러닝, Python vs R Anaconda, Jupyter Notebook Anaconda 설치 설치 확인 Microsoft Visual Studio Build Tools 설치1. 머신러닝, Python vs R머신러닝 프로그램을 작성할 수 있는 대표적인 오픈 소스 프로그램 언어는 Python과 R이다.딥러닝 프레임워크 텐서플로(TensorFlow), 케라스(Keras), 파이토치(PyTorch) 등에서 파이썬 우선 정책으로 파이썬을 지원하는 등의 이유로 R보다 파이썬으로 공부하는 것이 유리할 것이라 책에서 서술한다. 나의 생각에도, 파이썬은 Stack Overflow Annual Dveloper Survey 2021에서도 보이듯이 더 유리해보인다.여담으로, 노마드 코더, 2021년 개발 트렌드는 과연 어떻게 변화했나? 덕분에 프로그래밍 언어 선호도 조사에 대해 알게되었다.아이파이썬 (IPython, Interactive Python)은 대화형 파이썬 툴을 지칭한다. 주피터 노트북 (Jupyter Notebook)은 대표적인 아이파이썬 지원 툴이다.윈도우10에 Anaconda와 Jupyter Notebook, 그리고 Visual Studio 설치를 통해 파이썬 머신러닝의 환경 구성을 해보자.2. Anaconda, Jupyter NotebookAnaconda 설치https://www.anaconda.com/download에 접속하여 해당하는 설치 파일 다운로드 및 설치나는 windows 10 x86 64-bit 환경으로, 64-Bit Graphical Installer를 설치했다.Anaconda 설치시, 파이썬과 머신러닝 패키지인 numpy, pandas, matplotlib, seaborn과 jupyter notebook이 함께 설치된다.설치 확인설치된 Anaconda Prompt를 실행하여 파이썬 버전 확인. Windows 10 환경에서 Anaconda Prompt 사용시 관리자 권한으로 실행해야 제대로 패키지가 설치된다.(base) C:\\Users\\wjdxk&gt;python -VPython 3.8.8Jupyter Notebook을 실행하여 numpy, pandas, matplotlib, seaborn, sklearn 모듈을 import하여 정상 설치 확인 지금은 확인만 하는 것이니, 웹 브라우저를 이용해 http://localhost:8888에 접속하거나, Jupyter Notebook을 실행하자. Jupyter Notebook 기본 경로 설정 관련하여 포스팅 할 것이다. Default Directory는 C:\\Users\\사용자명이다.오류가 발생하지 않으면 정상 설치가 완료된 것이다.3. Microsoft Visual Studio Build Tools 설치Windows 환경에서 서드파티 패키지를 설치할 때, Microsoft Visual Studio Build Tools가 필요한 경우가 있다.분류에 사용하는 LightGBM, 추천 시스템의 Surprise 패키지 등에서 필요하다고 한다.https://visualstudio.microsoft.com/ko/downloads/에 접속하여 Build Tools를 다운로드 설치하자.참고“파이썬 머신러닝 완벽가이드” - (위키북스, 권철민 지음) 깃허브: https://github.com/wikibook/pymldg-rev" }, { "title": "[Error] jekyll 오류 / Address already in use - bind for 127.0.0.1:4000 (Errno::EADDIRINUSE) ", "url": "/posts/jekyll-01/", "categories": "Etc, Errors", "tags": "Port, address already in use - bind for, EADDIRINUSE", "date": "2021-08-15 00:00:00 +0900", "snippet": "오류 메세지/usr/lib/ruby/2.7.0/socket.rb:201:in 'bind': Address already in use - bind(2) for 127.0.0.1:4000 (Errno::EADDRINUSE)원인이미 포트 4000을 사용하는 프로세스가 존재할 때 발생하는 에러로 파악하고 있다.해결 방법해당 포트를 사용하는 프로세스를 종료하면 된다.ubuntu$ sudo lsof -wni tcp:4000$ sudo kill -60048 PID참고https://stackoverflow.com/questions/25151736/jekyll-2-2-0-error-address-already-in-use-bind2/25293131" }, { "title": "[ROS] Ubuntu 20.04.2.0 LTS에 ROS noetic 설치", "url": "/posts/01-ros/", "categories": "Study, ROS", "tags": "ROS, ubuntu, Robot", "date": "2021-08-15 00:00:00 +0900", "snippet": "본 포스팅은 “ROS 로봇 프로그래밍” - (루비페이퍼, 표윤석.조한철.정려운.임태훈 지음)과 http://wiki.ros.org/ROS을 바탕으로 공부한 내용을 정리한 것입니다. ROS 파티션 분리 후 ubuntu linux 설치 ROS 설치 NTP (Network Time Protocol) 설정 Installation Environment setup Dependencies for building packages Initialize rosdep 확인1. ROS로보틱스 분야의 플랫폼은 크게 소프트웨어 플랫폼과 하드웨어 플랫폼으로 나뉜다.로봇 소프트웨어 플랫폼은 로봇 응용프로그램을 개발할 때 필요한 하드웨어 추상화, 기능 구현 등을 포함한다.그 중 대표적으로 ROS (Robot Operating System), 일본의 OpenRTM, 유럽의 OROCOS, 한국의 OPRoS 등이 있다.ROS는 가장 많이 사용되고 있는 로봇 소프트웨어 플랫폼이다. ROS의 5가지 특징 프로그램 재사용성 통신 기반 프로그램 개발 도구 지원 활성화된 커뮤니티 생태계 조성 ROS는 운영체제와 비슷한 역할인 하드웨어 추상화를 포함하며, 전통적인 운영체제가 아니기에 이기종 하드웨어에서 사용할 수 있는 특징이 있다.ROS는 Robot Operating System, Meta-Operation System으로애플리케이션과 분산 컴퓨팅 자원 간의 가상화 레이어로 분산 컴퓨팅 자원을 활용하여스케줄링 및 로드, 감시, 에러 처리 등을 실행하는 시스템이다.미들웨어 (Middleware) 또는 소프트웨어 프레임워크 (Software framework)으로 볼 수 있다.ROS의 목적은 “로보틱스 소프트웨어 개발을 전 세계 레벨에서 공동 작업이 가능하도록 하는 환경을 구축하는 것!” ROS의 5가지 특징 분산 프로세스 패키지 단위 관리 공개 리포지토리 API 형태 복수의 프로그래밍 언어 지원 ROS의 구성요소는 클라이언트 라이브러리, 하드웨어 인터페이스, 커뮤니케이션, 로보틱스 애플리케이션 프레임워크, 로보틱스 애플리케이션, 시뮬레이션, 소프트웨어 개발 툴 등.ROS 서포트 기간은 기본적으로 2년에 한 번씩 릴리즈 되는 ubuntu LTS(Long Term Support) 버전에 맞추어 나오는 ROS 버전들은 LTS 서비스가 종료되는 시점인 5년간 지원한다.2. 파티션 분리 후 ubuntu linux 설치[jimnong 블로그] 파티션 분리 후 우분투 리눅스 듀얼부팅 설치방법에 설명이 자세히 잘 되어있다.이를 참고하여 설치해보자. 우분투 한글 설정방법 https://webnautes.tistory.com/1199 ros noetic (최신버젼) 설치 https://pinkwink.kr/1319 본인은 20.04.2.0 LTS 버전으로 설치하였다. Ubunutu 20.04.2.0 LTS 3. ROS 설치본인은 ros noetic으로 설치하였다.공식 ros noetic 설치 문서와“ROS 로봇 프로그래밍” - (루비페이퍼, 표윤석.조한철.정려운.임태훈 지음)를 따라가며 설치해보자.NTP (Network Time Protocol) 설정서로 다른 pc 간 통신을 위함. (개인 pc - Turtlebot 등)$ sudo apt-get install -y chrony ntpdate$ sudo ntpdate -q ntp.ubuntu.comInstallationsetup sources.list$ sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list'set up keysROS 저장소로부터 패키지 설치 위한 공개키 추가.ROS 버전마다 상이함. http://wiki.ros.org 참고noetic 버전은 다음과 같다.sudo apt-key adv --keyserver 'hktp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654noetic 버전은 다음과 같다.$ sudo apt install curl # if you haven't already installed curl$ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -installationROS 설치 이전 모든 ubuntu 패키지 업데이트$ sudo apt-get update &amp;&amp; sudo apt-get upgrade -y이후 셋 중 하나를 설치하자. 본인은 desktop-full 버전으로 설치하였다.Desktop-Full install (recommended)$ sudo apt install ros-noetic-desktop-fullDesktop install$ sudo apt install ros-noetic-desktopROS-Base (Bare Bones), no GUI tools$ sudo apt install ros-noetic-ros-base 추후에 추가 패키지를 설치할 때는 sudo apt install ros-noetic-PCKAGE의 형태로 패키지를 직접 설치.사용 가능한 패키지 검색은 apt search ros-noeticDependencies for building packages rosinstall은 ros 관련 패키지 인스톨 프로그램 $ sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential Initialize rosdep rosdep은 ros의 핵심 컴포넌트, 컴파일 시 의존성 패키지 설치에 도움을 주는 편의 기능. $ sudo apt install python3-rosdep$ sudo rosdep init$ rosdep update Environment setup 환경설정 파일 불러오기, 작업 폴더 생성 및 초기화$ mkdir -p ~/catkin_ws/src$ cd ~/catkin_ws/src$ source /opt/ros/noetic/setup.bash # noetic 부분에 ros 버전에 맞게 기입 $ catkin_init_workspace bashrc 수정~/. bashrc에 추가할 내용# Set ROS Noeticsource /opt/ros/noetic/setup.bashsource ~/catkin_ws/devel/setup.bash# Set Ros Networkexport ROS_HOSTNAME=localhostexport ROS_MASTER_URI=http://localhost:11311# Set ROS alias commandalias cw='cd ~/catkin_ws'alias cs='cd ~/catkin_ws/src'alias cm='cd ~/catkin_ws &amp;&amp; catkin_make' Network 설정시 마스터 PC 따로 존재, 로봇은 호스트 PC 사용할경우에 다음을 구분하여 입력할경우 서로 통신 가능. Network 설정시 ifconfig 등을 이용하여 본인 ip 입력 # Set ROS Networkexport ROS_HOSTNAME=localhostexport ROS_MASTER_URI=http://{ROS_HOSTNAME}:11311 bashrc의 ros network 설정 시,다른 기기와의 통신을 위해서는 ip를 구분해서 작성. 하나의 pc에서만 패키지 구동하는 경우에는 위의 설정으로 가능.본인 ip 확인 위해서는 ip addr, ifconfig 활용 가능 참고 블로그 ifconfig sudo apt-get install net-tools ip addr ip addr 여기 뭔가 잘안된다. 나중에 다시 확인. 4. 확인catkin은 ros 전용 빌드 시스템. test 해보자면$ cd ~/catkin_ws/ # catkin_ws로 폴더이동, bashrc 설정을 따라왔으면 cw로 가능 $ catkin_make # catkin make 명령어, bashrc 설정을 따라왔으면 cm으로 가능빌드가 성공하면 ls 명령어로 build와 devel 폴더가 생성되는 것을 확인 (catkin make 성공)$ roscore #ros 실행 명령어, 종료는 ctrl+c5. 추가 내용ros 구동은 기본적으로 터미널 창에서 이루어진다. 따라서 여러개의 터미널 창의 사용은 필수적.이에 나는 다중 터미널 창을 추천한다. 내가 사용하는 것은 terminator$ sudo apt-get install terminatorTerminator 주요 단축키 단축키 설명 사용법 터미네이터 실행 ctrl + alt + t 터미네이터 종료 ctrl + shift + q 수평 분할 ctrl + shift + o 수직 분할 ctrl + shift + e 분할 창 이동 ctrl + shift + p 분할 창 이동 (반대 방향) ctrl + shift + m 분할 창 종료 ctrl + shift + w 분할 창 확대 ctrl + shift + x ROS 동작 테스트 roscore 실행 ros 실행 명령어 $ roscore turtlesim 패키지의 turtlesim_node 예제 turtlesim 실행 $ rosrun turtlesim turtlesim_node turtlesim 패키지의 turtle_teleop_key 실행 키보드로 조종할 수 있는 node $ rosrun turtlesim turtle_teleop_key rqt_graph 패키지의 rgq_graph 실행 topic과 node 간 message 송수신을 확인하는 rqt_graph 실행 $ rqt_graph 참고ros 공식 wiki 주소: http://wiki.ros.org/ROS“ROS 로봇 프로그래밍” - (루비페이퍼, 표윤석.조한철.정려운.임태훈 지음) 깃허브: http://github.com/ROBOTIS-GIT/ros_tutorials" }, { "title": "[DL] Keras 설치", "url": "/posts/01-dl/", "categories": "Study, AI", "tags": "AI, DeepLearning, TensorFlow, Keras, Python, Jupyter Notebook", "date": "2021-08-10 00:00:00 +0900", "snippet": "본 포스팅은 “케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김)을 바탕으로 공부한 내용을 정리한 것입니다. 딥러닝에서 ‘딥’은? 딥러닝의 특징 텐서플로우, 케라스 설치 가상환경 생성 Tensorflow, Keras 등 설치 1. 딥러닝에서 ‘딥’은?머신러닝은 데이터로부터 많은 입력과 타깃의 샘플을 관찰하여 타깃에 매핑하는 것.데이터로부터 모델을 만들 때 얼마나 많은 층 (layer)을 사용했는지가 그 모델의 깊이라고 한다.층 기반 표현 학습 (layered representations learning) 또는 계층적 표현 학습 (hierarchical representations learning)이라 표현하기도 한다.딥러닝 모델은 이 층이 많은 것.딥러닝과 비교하여 머신러닝은 1~2개의 데이터 표현 층만을 학습하는 경향이 있어서 얕은 학습 (shallow kearning)이라 부르기도한다.딥러닝에서는 기본 층을 겹겹이 쌓아 올린 신경망 (neural network)라는 모델을 사용하여 표현 층을 학습한다.층에서 입력 데이터가 처리되는 내용은 가중치 (weight)에 저장되고, 그 층에서 일어나는 변환은 이 가중치를 파라미터 (parameter)로 가지는 함수로 표현된다.출력이 기대하는 것보다 얼마나 벗어나는지를 측정하는 신경망의 손실 함수 (loss function), 목적 함수 (objective function), 비용 함수 (cost function). 비용 함수는 모든 훈련 데이터에 대한 손실 함수의 합, 목적 함수는 최적화하기 위한 대상 함수. 보통 구분 짓지 않고 혼용해서 사용한다.손실 함수는 예측의 정확도를 손실 점수로 측정, 이를 피드백 신호로 사용하여 손실 점수가 감소되는 방향으로 가중치 값을 수정해 나간다.역전파 (backpropagation) 알고리즘을 구현한 옵티마이저 (optimizer)가 이 수정 과정을 담당한다.초기에는 네트워크의 가중치가 랜덤한 값, 훈련 반복 (training loop)을 통해 가중치와 손실 점수가 조정되며 타깃에 가장 가까운 출력을 만드는 모델이 된다.2. 딥러닝의 특징머신 러닝에서 처리하기 용이하게, 데이터의 좋은 표현을 수동으로 만들어가는 것을 특성 공학 (feature engineering)이라 한다.딥러닝은 이 과정을 자동화 한다. 또한 모든 표현 층을 동시에 공동 학습한다. 각 층은 상위 층과 화위 층의 표현이 변함에 따라 함께 바뀐다. 층을 거치면서 점진적으로 더 복잡한 표현이 만들어진다. 점진적인 중간 표현이 공동으로 학습된다.3. 텐서플로우, 케라스 설치윈도우에 CPU 버전의 텐서플로우를 설치하는 방법이다.범용적으로 가장 인기 있는 파이썬 배포판인 Anaconda에 설치해보자.가상환경 생성독립적인 환경을 생성할 수 있어서, 코드 마다 다른 dependency 문제를 해결 할 수 있다.Anaconda prompt에서 원하는 경로로 위치를 바꾸고 다음과 같이 입력하면 생성할 수 있다.$ conda update conda$ conda create -n py38 python=3.8Python 3.8 버전으로 py38이라는 이름으로 Anaconda 가상환경을 생성해주었다.해당 가상환경을 활성화하기 위해서는 해당 경로에서 conda activate py38이라 입력하면 된다.경로 상관없이 conda activate py38이라 입력하면 된다.Tensorflow, Keras 등 설치$ pip install numpy pandas matplot jupyter$ pip install tensorflow==2.4$ conda install -c anaconda pywin32$ pip install keras==2.2.2$ pip uninstall keras-preprocessing$ pip install keras-preprocessing==1.1.2 GPU 버전의 tensorflow를 설치하려면 다르게 입력해주어야한다. 본인의 노트북 GPU는 내장 그래픽 수준의 스펙이기에 CPU 버전으로 설치했다. Tensorflow와 Keras를 설치할 때 가장 중요한 점은 서로 호환이 되도록 Dependency 문제를 해결하기 위해서 버전을 맞춰주는 것이다. 버전이 맞지 않으면 실행이 되지않는다. 또한 정확히 기억나지 않지만 2.4 버전 전후쯤으로 import 하는 법이 바뀌었기에 코드가 사용된 환경도 확인해주어야한다. 다음과 같이 Jupyter notebook에서 import가 성공하면 tensorflow 2.4 버전의 설치가 성공적으로 완료된 것이다.참고“케라스 창시자에게 배우는 딥러닝” - (길벗출판사, 프랑소와 숄레 지음, 박해선 옮김) 깃허브: http://github.com/gilbutITbook/006975 길벗출판사 홈페이지: http://www.gilbut.co.kr tensorflow 2.4 버전 호환 코드 https://github.com/rickiepark/deep-learning-with-python-notebooks/tree/tf2" }, { "title": "[R] 데이터 분석 환경 만들기", "url": "/posts/01-r/", "categories": "Study, AI", "tags": "R", "date": "2021-08-02 00:00:00 +0900", "snippet": "본 포스팅은 “Do it! 쉽게 배우는 R 데이터 분석” - (이지스퍼블리싱, 데이터 분석가 김영우 지음)을 바탕으로 공부한 내용을 정리한 것입니다. R이란? R 설치 R과 R Studio 설치 프로젝트 생성 환경설정 데이터 분석 준비 변수 함수 패키지 1. R이란? R은 데이터 분석에 사용되는 소프트웨어 통계 분석, 머신러닝 모델링, 텍스트 마이닝, 소셜 네트워크 분석, 지도 시각화, 주식·이미지·사운드 분석, 웹 애플리케이션 개발 등에 사용 데이터 분석 도구에는 크게 GUI 방식과 프로그래밍 방식이 있다.프로그래밍 방식을 채택한 R을 사용할 경우 다음과 같은 장점이 있다. 재현성이 확보된다. 동일한 분석 방법과 데이터에서 같은 결과물을 얻을 수 있다. 오류가 줄어든다. 코드와 실행 결과의 기록이 남아서 검토와 오류 수정이 수월하다. 공동 작업을 할 수 있다. 코드를 공유하며 분석 과정을 여러 단계로 나눠 공동 작업을 할 수 있다. 2. R 설치R을 사용하기 위해 PC에 R과 R 스튜디오를 설치한다.R 설치 &gt; R 스튜디오 설치 의 순으로 진행한다.R Studio는 R을 편리하게 사용하기 위한 IDE(Integrated Development Environment, 통합 개발 환경) 소프트웨어R과 R Studio 설치 R 프로젝트 공식 사이트 접속 이후, 한국 서버 링크에서 OS에 맞는 버전으로 설치한다. R 프로젝트 공식 사이트의 CRAN 미러 페이지에서 다운로드. CRAN 미러 페이지 https://cran.r-project.org/mirrors.html 나는 맨위의 주소 https://ftp.harukasan.org/CRAN/에 접속했다. 나는 Windows 환경에 설치하였다. 처음 설치시 base를 선택하여 설치. R Studio 사이트의 다운로드 페이지에 접속하여 설치한다. R Studio 다운로드 페이지 https://www.rstudio.com/products/rstudio/download 32비트 윈도우에서는 R 스튜디오 1.1 이하 버전을 설치 http://bit.ly/2udnk. 하단의 ‘All Installers’ 항목에서 맞는 OS로 설치한다. 나는 Windows 환경에 설치하였다. 설치가 완료된 R Studio를 실행 시켜보자. R Studio 실행 크게 다음과 같이 네 가지로 창이 구분되어 있다. 콘솔 창 명령과 결과가 출력되는 곳 소스 창 소스 코드를 기록 할 수있는 곳. 이로 만들어진 문서를 스크립트(Script)라 한다. Ctrl + Enter단축키로 실행 가능 환경 창 분석 과정에서 생성한 데이터를 보여주는 곳 파일 창 워킹 디렉터리(Working Directory)의 내용물을 보여준다. 프로젝트 생성 File &gt; New Project New Directory &gt; New Project Directory name과 경로에 한글이 들어갈 경우 오류가 발생할 수 있다. 프로젝트가 성공적으로 생성되면 ~.Rproj라는 프로젝트 파일이 생성된 것을 확인 가능.스크립트 저장시 ~.R라는 스크립트 파일 생성 확인 가능.환경설정R Studio에는 두 종류의 환경 설정 메뉴가 있다. 글로벌 옵션 (Global Options) R Studio 사용 전반에 영향을 미치는 옵션 프로젝트 옵션 (Project Options) 해당 프로젝트에만 영향을 미치는 옵션 본인의 성격에 맞게 환경 설정을 진행하면 될 것 같다. 나는 기본적인 설정은 글로벌 옵션에서 진행했다. Soft-Wrap 자동 줄바꿈 옵션 소스 코드가 길어질 때, 자동으로 줄을 바꿔주어서 가독성에서 유리하다고 생각한다. Tools &gt; Global Options &gt; Code에서 Soft-wrap R source files 인코딩 방식 설정 한글이 깨지는 것을 방지 하기 위하여 Text encoding 방식을 설정. Tools &gt; Project Options &gt; Code Editing에서 Text encoding을 UTF-8로 설정. 3. 데이터 분석 준비변수변수는 ‘변하는 수’다 다양한 값을 지니고 있는 하나의 속성을 ‘변수(Variable)’이라 한다.상수는 ‘변하지 않는 수’다 하나의 값으로만 되어 있는 속성을 ‘상수(Constant)’라 한다. 변수는 데이터 분석의 대상, 상수는 분석할 수 없다.변수명 생성 규칙 문자로 시작해야 하고, 문자·숫자·대시(-)·언더바(_)를 조합해서 생성. 대소문자 구분, 인코딩 이슈로 영어로 변수 생성 추천. 대소문자 혼용시 오타 찾는데 시간이 오래 걸릴 수 있다. 변수는 소문자로만 구성하는 습관을 추천.문자로 된 변수는 연산이 불가 단어를 붙이거나 자르는 문자 처리 기능은 사칙연산이 아닌 다른 함수를 사용해야한다.함수데이터 분석은 함수로 시작해 함수로 끝난다 데이터 분석은 함수를 이용해서 변수를 조작하는 일.패키지 패키지(Packages)는 정제된 다양한 기능의 함수가 포함됨. 패키지는 한번만 설치하면 되지만 로드는 R 스튜디오를 새로 시작할때마다 반복필요.ggplot2 패키지 그래프로 표현할 때, 가장 많이 사용하는 패키지이다.# ggplto2 패키지 설치install.packages(\"ggplot2\") 설치가 완료된 이후, 사용 할 때에는 항상 로드과정이 필요하다.# ggplot2 패키지 로드library(ggplot2)다음 포스팅으로는 ggplot2 패키지 내부의 mpg 데이터를 활용한 다양한 예제부터 하나씩 올릴 예정이다.참고“Do it! 쉽게 배우는 R 데이터 분석” - (이지스퍼블리싱, 데이터 분석가 김영우 지음) 깃허브: http://bit.ly/start_r 이지스퍼블리싱 홈페이지: http://www.easyspub.com [자료실] 게시판" }, { "title": "[Ruby] Jekyll을 사용하여 블로그 만들기 02 (Chirpy 테마)", "url": "/posts/02-jekyll-blog/", "categories": "Etc, Tips", "tags": "blog, portfolio, jekyll, chirpy, jekyll-chirpy, jekyll theme, 19tak", "date": "2021-07-28 00:00:00 +0900", "snippet": "처음에 정한 테마가 너무 못생겼다..계속 실패하던 chirpy 테마를 적용한 다른 블로거분들이 너무 부러워서 도전하다가깔끔한 포스팅으로 설명해두신 최근 글을 찾았고, 큰 도움을 받아서 성공했다.아직 댓글 구현을 안해놨는데, 조만간 하면서 은인의 포스팅에 댓글 하나 남겨야겠다.. CI / CD Chirpy 테마와 gh-page branch 호스팅 설치과정 배포 (github push)1. CI / CDCI / CD (지속적 통합 / 지속적 제공)의 개념, 방법, 장점, 구현 과정 등 더 자세한 내용은 RedHat의 게시글을 참고.CI (Countinuous Integration) production에 대해 여러 개발자가 참여하여 버전 관리를 할때, 테스트 통과로 안정성을 높이기 위함. 버전관리툴에 새로운 버전이 올라올 때, 자동으로 테스트 코드가 동작하는 파이프라인 생성. 대표적인 예로, github에 commit을 push하는 과정.CD (Countinuous Delivery) CI를 통과하면 코드가 자동으로 release, production에 적합한 빌드 파일 생성.CD (Countinuous Deployment) 빌드 파일 생성되면 실제 production으로 release하는 과정을 자동화 한것.2. Chirpy 테마와 gh-page branch 호스팅jekyll 빌드 빌드시 _site 디렉토리 생성, 호스팅 서버에서 실제로 참조하는 정적 파일 저장되는 곳. 로컬에서 github에 push하면 자동으로 jekyll build가 실행되고, github에서 _site를 호스팅.chirpy 빌드 jekyll 테마 중 하나이기에 동일한 과정. 기본 설정으로는, push시 자동으로 CI / CD 진행, 정상 완료시 gh-page branch 생성. 안정성 고려하여 master branch가 아닌 gh-page branch 호스팅 권고.gh-page branch 호스팅chirpy github repository README.md의 deployment 참고 _config.yml의 url이 정상적으로 https://&lt;username&gt;.github.io의 형태인지 확인한다. (개인계정의 경우) https://&lt;username&gt;.github.io의 repository의 settings &gt; Github PagesSource를 gh-page branch로 변경한다.3. 설치과정기본 세팅이전의 포스팅에서도 설명이 나와있으니 빠르게 넘어간다. Ruby 설치 및 버전 확인 jekyll, bundle 설치 및 버전 확인 Ruby 3.0.0 이상은 webrick을 따로 설치해야한다. gem install webrick 블로그 생성ruby prompt에서 진행된다.jekyll new &lt;username&gt;.github.iocd &lt;username&gt;.github.iobundle exec jekyll servelocalhost:4000에 정상적으로 호스팅이 되는지 확인, 이후 chirpy 테마 적용chirpy 테마 설치Gemfile에 다음 문구 추가gem \"jekyll-theme-chirpy\"_config.yml에 다음 문구 추가theme: jekyll-theme-chirpybundle을 실행하여 theme를 다운로드한다.$ bundle다운로드된 테마의 위치를 파악하고 해당 경로와 jekyll 블로그 경로를 탐색기로 열어둔다.$ bundle info --path jekyll-theme-chirpy jekyll 블로그 경로에 index.markdown과 about.markdown conflict 요소 파일 제거한다. 테마 경로에서 다음 파일들을 복사하여 블로그 경로에 붙여넣기한다. ├── _data ├── _plugins ├── _tabs ├── _config.yml └── index.html 테마 경로에 다음 파일이 존재하면 역시 옮겨온다. .github/workflows/pages-deploy.yml.hooktools/test.shtools/deploy.sh 없다면 chirpy 테마의 github에서 파일을 다운받고 얘네만 가져오자. _config.yml 수정, github remote repo 연결 설정 등 나는 이전 포스트에서 README.md가 상관 없다 했는데, 해야하는듯. 브렌치 명 확인 4. 배포 (github push)pages-deploy.yml과정을 따라왔다면 파일 이름은 pages-deploy.yml.hook일 것이다.파일명을 pages-deploy.yml로 변경해주고 열어서 다음을 확인하자.앞서 확인한 브렌치 명으로 변경해준다.bundle lockCI / CD 과정에서 생성된 파이프라인의 테스트 과정을 위한 설정이다.테스트 리눅스 환경에 필요한 라이브러리를 설치해주자.$ bundle lock --add-platform x86_64-linux미설치시 테스트 과정에서 다음과 같은 오류가 발생한다.htmlproofer 설치Gemfile에 다음을 추가한다.group :test do gem \"html-proofer\", \"~&gt; 3.18\"end그리고 bundle install 진행해주자.html proofer는 다음과 같이 html 관련 오류를 검증해준다. 해당 부분 수정하여 다시 push하도록 하자.github에서 확인할 것push가 정상적으로 진행되고 CI / CD 과정도 정상적으로 완료 된 것을 확인해야한다.이 과정이 이뤄지지 않으면 제대로 _site가 생성되지 않는다.https://&lt;username&gt;.github.io의 repository의 Actions &gt; All workflows에 automatic build가 정상적으로 완료되어야한다.참고 의사줌치 님의 포스팅gem 기반으로 jekyll 블로그 만들기(chirpy 테마, windows) 의사줌치 님의 포스팅Jekyll-theme-Chirpy의 안전한 배포 김석진 님의 포스팅GitHub 블로그 시작하기 " }, { "title": "[Error] Visual Studio Code - 오류 / 'source' 용어가 cmdlet, 함수, 스크립트 파일 또는 실행할 수 있는 프로그램 이름... ", "url": "/posts/vsc-01/", "categories": "Etc, Errors", "tags": "vsc, visual studio code, error", "date": "2021-07-27 00:00:00 +0900", "snippet": "오류 메세지source : 'source' 용어가 cmdlet, 함수, 스크립트 파일 또는 실행할 수 있는 프로그램 이름으로 인식되지 않습니다. 이름이 정확한지 확인하고 경로가 포함된 경우 경로가 올바른지 검증한 다음 다시 시도하십시오.위치 줄:1 문자:1+ source \"c:/&lt;파이썬 가상환경 경로&gt;/Scripts/activat ...+ ~~~~~~ + CategoryInfo : ObjectNotFound: (source:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException이와 유사한 오류 메세지로 다음과 같은 경우도 존재한다.'git' 용어가 cmdlet, 함수, 스크립트 파일 또는 실행할 수 있는 프로그램 이름으로 인식되지 않습니다. 이름이 정확한지 확인하고 경로가 포함된 경우 경로가 올바른지 검증한 다음 다시 시도하십시오.위치 줄:1 문자:1+ git init+ ~~~~~~ + CategoryInfo : ObjectNotFound: (git:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException원인Visual Studio Code의 기본 터미널이 Windows의 Power Shell로 설정되어 있기 때문이라고 한다.본인은 설정을 바꾸다보니 해결이 되는 것 같다.해결 방법VSC의 기본 터미널을 cmd 또는 Git Bash로 변경한다. VSC에서 ctrl + , 또는 파일 - 기본설정 - 설정 으로 설정 창에 진입한다. 설정 검색 칸에 windows shell을 검색하고 기본 터미널 설정을 변경한다. " }, { "title": "[Ruby] Jekyll을 사용하여 블로그 만들기 01", "url": "/posts/01-jekyll-blog/", "categories": "Etc, Tips", "tags": "blog, portfolio, ruby, jekyll, 19tak", "date": "2021-07-23 00:00:00 +0900", "snippet": "2021년 7월 21일평소 공부할 때, 구글링으로 다른 분들의 블로그 포스팅을 보며아.. 나도 멋있는 블로그를 하나 만들어야겠다..는 생각이 들었다.아니, 그렇게 멋있지는 않더라도 나도'19tak.github.io'라는 멋있는 주소가 가지고 싶었다.그렇게 이 포스팅이 탄생하게 되었다.Github Blog 시작하기순서가 뒤죽박죽일 확률이 있다.. 술먹은 상태로 울다가 공부하는 것이 요즘 나의 취미이자 특기이다..그래서 순서가 기억이 안난다.. 그래도 열심히 포스팅 해보도록 하겠다.본인의 노트북 OS 는 윈도우10과, VSCode를 사용하고 있으며, 상세 스펙은 다음과 같다.큰 의미는 없을 것 같지만, 첫 포스팅인만큼 뭔가 더 담아야 할 것 같은 그런기분이다.비전공자이기 때문에 더욱 고생한 것 같고, 그러고 있을 다른 사람들을 위해서라도..Github는 21년 5월쯤 첫 존재를 알았고, 6월 중순부터 진행한 교육기간 내 팀프로젝트에서 처음으로 사용하였다.여러분들도 하나씩 하나씩 따라가보자. 순서는 다음과 같다. Git &amp; Github Ruby &amp; Jekyll Hosting Blog + New Repository + Using Jekyll Theme Errors Tips for Blogging1. Git &amp; GithubGit은 일종의 관리시스템이라 생각하면 될 것 같다.개발과정 전역에 걸쳐서 Local repository에서 각 파일의 수정 등을 기록으로 남길 수 있고이를 github에서 Remote repository를 만들어 주면 타인과도 그 기록에 대해서 같이 나눌 수 있다.이때의 Remote repository를 활용하여 게시글을 보여주는 것이 github를 활용한 블로그 관리라고 할 수 있겠다.자세한 내용은 다른 블로그를 참고하는 것이 좋을 것 같다.2. Ruby &amp; JekyllRuby와 Jekyll은 Github Blog를 제작할때 가장 많이 사용하는 tool 이다.순서는 다음과 같다. Ruby 설치 - Jekyll 설치 &amp; bundler 설치Jekyll은 Ruby로 만들어져있고, bundler는 gem의 관리 프로그램..라고 생각하면 될 것 같다. 단, Ruby는 Linux 시스템 위에서 동작한다. Windows Subsystem for Linux (WSL)을 활용하여 Windows 에서도 Linux 환경을 바로 이용하자.현재는 WSL2도 배포 중이며 자세한 설치는 WSL 설치 공식문서를 참고하자.현재 우리는 WSL2를 사용하기 때문에 WSL의 Linux Terminal에서 Ruby를 설치해도 괜찮고,Windows 환경에서 RubyInstaller로 설치해도 괜찮을 것이다. cmd가 실행되고 다음과 같은 화면에서 3번을 눌러주면 된다.Linux Terminal에서 설치를 진행할때는 다음과 같이 입력하면 될 것이다.$ sudo apt-get update$ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt1-dev libcurl4-openssl-dev libffi-dev software-properties-common$ sudo apt install ruby-full설치가 완료되었으면 다음 명령어로 Ruby의 설치와 버전을 확인해 준다.$ ruby -vgem은 Ruby의 패키지다. gem들은 RubyGems에 의해 관리되지만, 패키지 의존성 문제로 bundler를 사용한다.다음 명령어로 jekyll과 bundler를 설치하도록 하자.$ gem install jekyll$ gem install bundler3. Hosting Blog기초적인 준비가 이제 끝났다고 생각하면 될 것 같다. 이제 블로그를 호스팅 해보도록 하자.Making New Repositorygithub에서 새로운 repository를 생성해준다.이 때, 이름은 반드시 &lt;username&gt;.github.io 의 형태로 &lt;username&gt;에 자신의 아이디를 넣어서 생성해준다.본인은 이런식으로 README 체크를 해주었는데 크게 상관 없다.이후 git clone을 통해 Local repository에 복사해준다.$ git clone &lt;remote repository url&gt;앞서 생성해준 &lt;username&gt;.github.io의 repository url을 &lt;remote repository url 에 넣어서 명령을 내린다.이제 이 Local repository를 통해 jekyll로 이쁘게 만든 파일들을 git push하게 될 경우&lt;username&gt;.github.io 의 주소로 당신의 블로그가 만들어진다.clone을 포함한 git의 사용법은 다른 블로그를 참고하는 것이 좋을 것 같다.Using Jekyll Theme직접 블로그의 전체적인 디자인을 하기에는 시간과 노력이 너무 많이 든다.다른 사람들이 만들어둔 테마를 이용해서 커스텀을 해보자. jamstackthemes.dev jekyllthemes.org jekyllthemes.io jekyll-themes.com 해당 사이트들에서 원하는 디자인으로 하나 골라보자.이런 식으로 theme 들의 github repository 링크와 live demo 버전이 있으니 여러 후보를 만들자.theme 의 github 로 이동하였을때, fork~clone , Download ZIP 등 편한 방법으로 theme 파일들을&lt;username&gt;.github.io Local repository에 다운받자. README.md 등이 덮어씌워져도 지금은 상관이 없다.터미널에서 Local repository로 경로 이동을 한 뒤 다음 명령어를 실행해주자.$ jekyll new ./$ bundle install이제 로컬 서버에 띄워서 확인을 해보자.$ bundle exec jekyll serve다음과 같이 로컬 서버의 주소가 보이면 성공. http://127.0.0.1:4000으로 접속이 가능하다.이제 git push를 통해 Remote repository에 올리면로컬 서버가 아닌 username.github.io으로 접속이 가능할 것이다.이제 남은 것은 직접 디자인 커스텀과, 정보를 채워 나가는 것, 그리고 게시글 포스팅 정도이다.디자인과 정보는 _config.yml ,~.html, ~.css, ~.js 의 파일들을 보면 될 것이다.포스팅은 _posts 폴더의 ~.md 파일들로 이루어진다. mark down 작성법은 다른 블로그를 참고하는 것이 좋을 것 같다.4. Errors기억이 잘 나지 않지만, Ruby, Jekyll, bundler의 설치과정,그리고 마지막의 로컬 서버 호스팅 bundle exec jekyll serve 까지많은 오류가 있었고, 해결을 하기 위해 구글 바다를 헤엄쳐 다녔다. 그 중 기억나는 것부터 작성한다.첫 번째, git bash 오류나는 터미널을 VSCode 에서 사용하고 있는데, 사실 여기가 헷갈리는 부분이다.내가 wsl과 ubuntu도 설치 하였고, git bash도 사용하고, 뭐를 쓰고있었는지 모르겠는데,결국 지금 사용하고 있는것은 git bash라는 점에서, 아마 나와 같은 길을 걷게 되실 분이 좀 있을 것 같다.여기까지 오는 길도 험난했는데 git bash syntax error near unexpected token 오류만 반나절 겪은 것 같다. home directory 내의 .bashrc 파일 내부의 오타 같은 것에 의해서 발생한 오류로 파악하고 있다. export PATH의 경로에 따옴표 를 붙여주거나, 경로 중간의 소괄호 양 끝에 따옴표 를 붙여주며 해결되었다. 명령어로 하는 법을 몰라서 나는 .bashrc를 메모장으로 열어서 직접 수정해주었다.export PATH = ~어쩌구~export PATH = \" ~저쩌구~ \"export PATH = ' ~절씨구~ 'export PATH = /c/Program Files (x86)/브라움만미드라구~export PATH = /c/Program Files \"(x86)\"/~두 번째, jekyll 오류나는 테마를 정하기 위해 바꾸는 과정에서 매번 발생했다. bundle exec jekyll serve로 jekyll 서버 실행을 할때 로컬 주소가 나오지 않고 'require': cannot load such file -- webrick (LoadError)라는 오류메세지가 나오는 경우이다. 해결법은 매우 간단한데, ruby 3.0.0 부터 webrick 이 기본으로 포함된 gem 에서 빠져있기 때문에 추가만 해주면 된다. $ bundle add webrick$ bundle exec jekyll serve세 번째, bundle install 오류이 역시 간단하게 해결이 된다. jekyll new와 bundle install를 할 때 발생했던 것으로 기억하고있다. Could not locate Gemfile or .bundle/ directory라는 오류메세지가 나오는 경우이다. 해결 방법은 생각 보다 간단하고, 오류메세지도 매우 친절한 것이었다.현재 커맨드라인이 위치한 경로에 Gemfile이라는 파일이 존재하지 않는 것이다. 경로를 다시 설정해주자. 이 외에도 오류가 좀 많이 발생했는데 기억이 나지 않거나, 해결하지 못하였다.제일 어이 없던 것은 로컬에서 완벽하게 잘 나오는 테마였는데깃허브에서 돌아가지 않는 것이었다. 원인도 알고 있는데 해결을 못해서 지금 보이는이런 몬생긴 테마를 커스텀해서 사용하고 있다. 나는 똥손인데 ㅠㅠㅠ깃허브 actions를 사용하는 테마들은 Ubuntu 버전 차이로 에러가 발생 할 수 있다.그런 테마들은 보통 폴더에 ~.sh 확장자의 shell scripts 파일들이 있더라.우분투를 다시 깔기에는 너무 귀찮다..5. Tips for Blogging이번엔 꿀팁이다… 꿀팁인가..?포스팅을 연습하다 보면 생각이 들 것이다. “사진을 디렉토리 안에 다 넣으면 repository 용량이 너무 커질거 같은데??” “외부에서 받아올까? 외부 어디에 사진을 올려두지??”본인의 github remote repository인 github.com/&lt;username&gt;.github.io로 이동하자.위의 사진처럼 Issues 메뉴가 보이지 않는다면 다른 아무 repository를 들어가서 확인해보자.본인은 팀으로 만든 repository에 이슈가 보여서 사용한다. github.com/&lt;repository name&gt;/issues/new새로이 이슈를 만들어 주기로 하고 들어가고 Leave a comment에 사진을 바로 붙여넣기 하면![Uploading image.png…]() 라는 문장이 잠시 떠있다가 짜잔하고,![image](https://user-images.githubusercontent.com/어쩌구.png) 하고 md 문법이..!일단 이친구를 그대로 가져다 사용하면 되는데, Issue 등록의 코멘트가 github 정적 컨텐츠 서버에 업로드가 자동으로 되고,그 친구의 주소를 가져다 사용하는 것이므로, 우리가 건드릴 수 없는 영역이기에, 개인정보 사진 같은거 잘못 올리지 말자.Issue 등록하지 않고 코멘트 창에 사진만 올려도 바로 컨텐츠 서버에 업로드 되는 것이기에 이슈 등록은 취소하면 된다.참고 AhriBori 님의 포스팅 Github 마크다운 작성 시 이미지 업로드 꿀팁" }, { "title": "About Me", "url": "/posts/about-me/", "categories": "", "tags": "", "date": "1995-11-10 00:00:00 +0900", "snippet": "19takcontact: 010-3006-7085email: wjdxkrdl123@naver.comemail: jthan_tak@lgcns.com(22.08 ~ ) : LG CNS(21.04 ~ 21.11) : 한국품질재단 AI 개발자 교육 과정 이수(15.03 ~ 21.08) : 동국대학교 기계로봇에너지공학과(17.01 ~ 18.10) : 30사단 311 포병대대 HQ(15.03 ~ 20.12) : 동국대학교 중앙 힙합동아리 Ajax 2016, 2019 회장직(15.03 ~ 20.12) : 동국대학교 연합 봉사동아리 KUSA (Korea UNESCO Student Association)(19.08 ~ 19.12) : 동국대학교 문학동아리 (15.03 ~ 15.12) : 동국대학교 영화동아리 디딤돌 " } ]
